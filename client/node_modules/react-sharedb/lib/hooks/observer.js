'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.observer = observer;

var _react = require('react');

var React = _interopRequireWildcard(_react);

var _observerUtil = require('@nx-js/observer-util');

var _batching = require('../batching');

var _batching2 = _interopRequireDefault(_batching);

var _destroyer = require('./destroyer');

var _destroyer2 = _interopRequireDefault(_destroyer);

var _model = require('@react-sharedb/model');

var _model2 = _interopRequireDefault(_model);

var _helpers = require('./helpers');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ref: https://github.com/mobxjs/mobx-react-lite/blob/master/src/observer.ts
function NullComponent() {
  return null;
}

function observer(baseComponent) {
  var baseComponentName = baseComponent.displayName || baseComponent.name;
  // memo; we are not intested in deep updates
  // in props; we assume that if deep objects are changed,
  // this is in observables, which would have been tracked anyway

  var memoComponent = React.memo(function (props) {
    // forceUpdate 2.0
    var forceUpdate = useForceUpdate();

    // wrap the baseComponent into an observe decorator once.
    // This way it will track any observable changes and will trigger rerender
    var observedComponent = React.useMemo(function () {
      var blockUpdate = { value: false };
      var update = function update() {
        // TODO: Decide whether the check for unmount is needed here
        // Force update unless update is blocked. It's important to block
        // updates caused by rendering
        // (when the sync rendening is in progress)
        if (!blockUpdate.value) forceUpdate();
      };
      var batchedUpdate = function batchedUpdate() {
        return _batching2.default.add(update);
      };
      return (0, _observerUtil.observe)(wrapBaseComponent(baseComponent, blockUpdate), {
        scheduler: batchedUpdate,
        lazy: true
      });
    }, []);

    // clean up observer on unmount
    useUnmount(function () {
      return (0, _observerUtil.unobserve)(observedComponent);
    });

    return observedComponent(props);
  });
  memoComponent.displayName = baseComponentName;
  if (baseComponent.propTypes) {
    memoComponent.propTypes = baseComponent.propTypes;
  }
  var suspenseWrapper = function suspenseWrapper(props) {
    var componentMeta = React.useMemo(function () {
      return {
        componentId: _model2.default.id(),
        createdAt: Date.now()
      };
    }, []);
    return React.createElement(_helpers.ComponentMetaContext.Provider, { value: componentMeta }, React.createElement(React.Suspense, { fallback: React.createElement(NullComponent, null, null) }, React.createElement(memoComponent, props)));
  };
  suspenseWrapper.displayName = baseComponentName;
  return suspenseWrapper;
}

function wrapBaseComponent(baseComponent, blockUpdate) {
  return function () {
    blockUpdate.value = true;
    var res = void 0;
    try {
      _destroyer2.default.reset();
      res = baseComponent.apply(undefined, arguments);
    } catch (err) {
      if (!err.then) throw err;
      // If the Promise was thrown, we catch it before Suspense does.
      // And we run destructors for each hook previous to the one
      // which did throw this Promise.
      // We have to manually do it since the unmount logic is not working
      // for components which were terminated by Suspense as a result of
      // a promise being thrown.
      _destroyer2.default.run();
      throw err;
    }
    blockUpdate.value = false;
    return res;
  };
}

function useForceUpdate() {
  var _React$useState = React.useState(),
      _React$useState2 = (0, _slicedToArray3.default)(_React$useState, 2),
      setTick = _React$useState2[1];

  return function () {
    setTick(Math.random());
  };
}

// TODO: Might change to just `useEffect` in future. Don't know which one fits here better yet.
function useUnmount(fn) {
  React.useLayoutEffect(function () {
    return fn;
  }, []);
}