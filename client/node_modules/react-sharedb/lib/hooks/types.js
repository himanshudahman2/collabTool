'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useApi = exports.useValue = exports.useLocal = exports.useQuery = exports.useDoc = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

exports.getCollectionName = getCollectionName;
exports.getItemFromParams = getItemFromParams;

var _react = require('react');

var _Doc = require('../types/Doc');

var _Doc2 = _interopRequireDefault(_Doc);

var _Query = require('../types/Query');

var _Query2 = _interopRequireDefault(_Query);

var _QueryExtra = require('../types/QueryExtra');

var _QueryExtra2 = _interopRequireDefault(_QueryExtra);

var _Local = require('../types/Local');

var _Local2 = _interopRequireDefault(_Local);

var _Value = require('../types/Value');

var _Value2 = _interopRequireDefault(_Value);

var _Api = require('../types/Api');

var _Api2 = _interopRequireDefault(_Api);

var _batching = require('../batching');

var _batching2 = _interopRequireDefault(_batching);

var _subscriptionTypeFns = require('../subscriptionTypeFns');

var _model = require('@react-sharedb/model');

var _model2 = _interopRequireDefault(_model);

var _destroyer = require('./destroyer');

var _destroyer2 = _interopRequireDefault(_destroyer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HOOKS_COLLECTION = '$hooks';
var $hooks = _model2.default.scope(HOOKS_COLLECTION);
var WARNING_MESSAGE = "[react-sharedb] Warning. Item couldn't initialize. " + 'This might be normal if several resubscriptions happened ' + 'quickly one after another. Error:';

var useDoc = exports.useDoc = generateUseItemOfType(_subscriptionTypeFns.subDoc);
var useQuery = exports.useQuery = generateUseItemOfType(_subscriptionTypeFns.subQuery);
var useLocal = exports.useLocal = generateUseItemOfType(_subscriptionTypeFns.subLocal);
var useValue = exports.useValue = generateUseItemOfType(_subscriptionTypeFns.subValue);
var useApi = exports.useApi = generateUseItemOfType(_subscriptionTypeFns.subApi);

function generateUseItemOfType(typeFn) {
  var isQuery = typeFn === _subscriptionTypeFns.subQuery;
  var isSync = typeFn === _subscriptionTypeFns.subLocal || typeFn === _subscriptionTypeFns.subValue;
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var hookId = (0, _react.useMemo)(function () {
      return _model2.default.id();
    }, []);
    var hashedArgs = (0, _react.useMemo)(function () {
      return (0, _stringify2.default)(args);
    }, args);

    var initsCountRef = (0, _react.useRef)(0);
    var cancelInitRef = (0, _react.useRef)();
    var itemRef = (0, _react.useRef)();
    var destructorsRef = (0, _react.useRef)([]);

    var destroy = (0, _react.useCallback)(function () {
      if (cancelInitRef.current) cancelInitRef.current.value = true;
      itemRef.current = undefined;
      destructorsRef.current.forEach(function (destroy) {
        return destroy();
      });
      destructorsRef.current.length = 0;
      $hooks.destroy(hookId);
    }, []);

    // For normal component destruction process
    useUnmount(destroy);

    // Manual destruction handling for the case of
    // throwing Promise out of hook
    useSync(function () {
      return _destroyer2.default.add(destroy);
    }, []);

    var params = (0, _react.useMemo)(function () {
      return typeFn.apply(undefined, args);
    }, [hashedArgs]);

    var finishInit = (0, _react.useCallback)(function () {
      // destroy the previous item and all unsuccessful item inits which happened until now.
      // Unsuccessful inits means the inits of those items which were cancelled, because
      // while the subscription was in process, another new item init started
      // (this might happen when the query parameter, like text search, changes quickly)
      // Don't destroy self though.
      destructorsRef.current.forEach(function (destroy, index) {
        if (index !== destructorsRef.current.length - 1) destroy();
      });

      // Clear all destructors array other then current item's destroy
      destructorsRef.current.splice(0, destructorsRef.current.length - 1);

      // Mark that initialization completed
      initsCountRef.current++;

      // Reference the new item data
      itemRef.current && itemRef.current.refModel();
    }, []);

    var initItem = (0, _react.useCallback)(function (params) {
      var item = getItemFromParams(params, $hooks, hookId);
      destructorsRef.current.push(function () {
        item.unrefModel();
        item.destroy();
      });

      if (isSync) {
        // since initialization happens synchronously,
        // there is no need to bother with cancellation of
        // the previous item
        itemRef.current = item;
        _batching2.default.batch(finishInit);
      } else {
        // Cancel initialization of the previous item
        if (cancelInitRef.current) cancelInitRef.current.value = true;
        // and init new
        var cancelInit = {};
        cancelInitRef.current = cancelInit;

        // If there is no previous item, it means we are the first
        var firstItem = !itemRef.current;
        // Cancel previous item
        if (itemRef.current) itemRef.current.cancel();
        // and init new
        itemRef.current = item;

        // It might or might NOT return the promise, depending on whether
        // we need to wait for the new data
        try {
          var initPromise = item.init(firstItem);
          // Async variant
          if (initPromise) {
            initPromise.then(function () {
              // Handle situation when a new item already started initializing
              // and it cancelled this (old) item.
              // This is only possible when the current item was initializing
              // asynchronously
              if (cancelInit.value) return;
              _batching2.default.batch(finishInit);
            }).catch(function (err) {
              console.warn(WARNING_MESSAGE, err);
              // Ignore the .init() error
              return _promise2.default.resolve();
            });
            // Sync variant (when data is taken from cache)
          } else {
            _batching2.default.batch(finishInit);
          }
        } catch (err) {
          // rethrow if it's a Promise for <Suspend> to catch it
          if (err.then) throw err;
          console.warn(WARNING_MESSAGE, err);
        }
      }
    }, []);

    useSync(function () {
      return initItem(params);
    }, [hashedArgs]);

    // ----- model -----

    // For Query and QueryExtra return the scoped model targeting the actual collection path.
    // This is much more useful since you can use that use this returned model
    // to update items with: $queryCollection.at(itemId).set('title', 'FooBar')
    var collectionName = (0, _react.useMemo)(function () {
      return isQuery ? getCollectionName(params) : undefined;
    }, [hashedArgs]);
    var $queryCollection = (0, _react.useMemo)(function () {
      return isQuery ? _model2.default.scope(collectionName) : undefined;
    }, [collectionName]);

    // For Doc, Local, Value return the model scoped to the hook path
    // But only after the initialization actually finished, otherwise
    // the ORM won't be able to properly resolve the path which was not referenced yet
    var $model = (0, _react.useMemo)(function () {
      return !isQuery && initsCountRef.current ? $hooks.at(hookId) : undefined;
    }, [initsCountRef.current]);

    // ----- data -----

    // In any situation force access data through the object key to let observer know that the data was accessed
    var data = $hooks.get()[hookId];

    // ----- return -----

    return [initsCountRef.current ? data : undefined,

    // Query, QueryExtra: return scoped model to collection path.
    // Everything else: return the 'hooks.<randomHookId>' scoped model.
    $queryCollection || $model,

    // explicit ready flag
    initsCountRef.current

    // TODO: Maybe enable returning array of ids for Query in future.
    //       The potential drawback is that the rendering might fire twice
    //       when the subscribed data changes (items added or removed from query).
    //       This needs to be tested before enabling.
    // Return ids array as the third parameter for useQuery
    // idsName ? res.push($hooks.get()[idsName]) : undefined
    ];

    // TODO: Maybe enable returning array of ids for Query in future.
    //       See below for more info.
    // ----- ids -----
    // const idsName = useMemo(() => (
    //   hasIds(params) ? getIdsName(hookId) : undefined
    // ), [])
  };
}

function getCollectionName(params) {
  return params && params.params && params.params[0];
}

// TODO: Maybe enable returning array of ids for Query in future.
function hasIds(params) {
  var explicitType = params && params.__subscriptionType;
  return explicitType === 'Query';
}

function getItemFromParams(params, model, key) {
  var explicitType = params && params.__subscriptionType;
  var subscriptionParams = params.params;
  var constructor = getItemConstructor(explicitType);
  return new constructor(model, key, subscriptionParams);
}

function getItemConstructor(type) {
  switch (type) {
    case 'Local':
      return _Local2.default;
    case 'Doc':
      return _Doc2.default;
    case 'Query':
      return _Query2.default;
    case 'QueryExtra':
      return _QueryExtra2.default;
    case 'Value':
      return _Value2.default;
    case 'Api':
      return _Api2.default;
    default:
      throw new Error('Unsupported subscription type: ' + type);
  }
}

function useUnmount(fn) {
  (0, _react.useLayoutEffect)(function () {
    return fn;
  }, []);
}

function useSync(fn, inputs) {
  (0, _react.useMemo)(function () {
    fn();
  }, inputs);
}

function useAsync(fn, inputs) {
  (0, _react.useLayoutEffect)(function () {
    fn();
  }, inputs);
}

// TODO: Might be useful in future as a sync alternative to useEffect
function useSyncEffect(fn, inputs) {
  var prevCleanup = (0, _react.useRef)();
  (0, _react.useMemo)(function () {
    _batching2.default.batch(function () {
      prevCleanup.current && prevCleanup.current();
      prevCleanup.current = fn();
    });
  }, inputs);
  useUnmount(function () {
    _batching2.default.batch(function () {
      prevCleanup.current && prevCleanup.current();
    });
  });
}