'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

exports.default = function (racer) {
  racer.Model.prototype.subDoc = generateMethodOfType(_subscriptionTypeFns.subDoc);
  racer.Model.prototype.subQuery = generateMethodOfType(_subscriptionTypeFns.subQuery);
  racer.Model.prototype.subLocal = generateMethodOfType(_subscriptionTypeFns.subLocal);
  racer.Model.prototype.subValue = generateMethodOfType(_subscriptionTypeFns.subValue);
  racer.Model.prototype.subApi = generateMethodOfType(_subscriptionTypeFns.subApi);
};

exports.getCollectionName = getCollectionName;
exports.getItemFromParams = getItemFromParams;

var _Doc = require('./types/Doc');

var _Doc2 = _interopRequireDefault(_Doc);

var _Query = require('./types/Query');

var _Query2 = _interopRequireDefault(_Query);

var _QueryExtra = require('./types/QueryExtra');

var _QueryExtra2 = _interopRequireDefault(_QueryExtra);

var _Local = require('./types/Local');

var _Local2 = _interopRequireDefault(_Local);

var _Value = require('./types/Value');

var _Value2 = _interopRequireDefault(_Value);

var _Api = require('./types/Api');

var _Api2 = _interopRequireDefault(_Api);

var _subscriptionTypeFns = require('./subscriptionTypeFns');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SUBS_COLLECTION = '$subs';

function generateMethodOfType(typeFn) {
  var _this = this;

  var isQuery = typeFn === _subscriptionTypeFns.subQuery;
  var isSync = typeFn === _subscriptionTypeFns.subLocal || typeFn === _subscriptionTypeFns.subValue;
  return function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
      var $subs,
          subId,
          params,
          item,
          unsubscribe,
          collectionName,
          $queryCollection,
          $model,
          data,
          _args = arguments;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              $subs = _this.scope(SUBS_COLLECTION);
              subId = _this.id();
              params = typeFn.apply(undefined, _args);
              item = getItemFromParams(params, $subs, subId);

              unsubscribe = function unsubscribe() {
                item.unrefModel();
                item.destroy();
                $subs.destroy(subId);
              };

              if (isSync) {
                _context.next = 8;
                break;
              }

              _context.next = 8;
              return item.init(true);

            case 8:
              item.refModel();

              // For Query and QueryExtra return the scoped model targeting the actual collection path.
              // This is much more useful since you can use that use this returned model
              // to update items with: $queryCollection.at(itemId).set('title', 'FooBar')
              collectionName = isQuery ? getCollectionName(params) : undefined;
              $queryCollection = isQuery ? _this.scope(collectionName) : undefined;

              // For Doc, Local, Value return the model scoped to the hook path
              // But only after the initialization actually finished, otherwise
              // the ORM won't be able to properly resolve the path which was not referenced yet

              $model = !isQuery ? $subs.at(subId) : undefined;

              // In any situation force access data through the object key to let observer know that the data was accessed

              data = $subs.get()[subId];
              return _context.abrupt('return', [unsubscribe, data,

              // Query, QueryExtra: return scoped model to collection path.
              // Everything else: return the 'hooks.<randomHookId>' scoped model.
              $queryCollection || $model]);

            case 14:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function () {
      return _ref.apply(this, arguments);
    };
  }();
}

function getCollectionName(params) {
  return params && params.params && params.params[0];
}

function getItemFromParams(params, model, key) {
  var explicitType = params && params.__subscriptionType;
  var subscriptionParams = params.params;
  var constructor = getItemConstructor(explicitType);
  return new constructor(model, key, subscriptionParams);
}

function getItemConstructor(type) {
  switch (type) {
    case 'Local':
      return _Local2.default;
    case 'Doc':
      return _Doc2.default;
    case 'Query':
      return _Query2.default;
    case 'QueryExtra':
      return _QueryExtra2.default;
    case 'Value':
      return _Value2.default;
    case 'Api':
      return _Api2.default;
    default:
      throw new Error('Unsupported subscription type: ' + type);
  }
}