'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

exports.getIdsName = getIdsName;
exports.getShareResultsIds = getShareResultsIds;

var _Base2 = require('./Base');

var _Base3 = _interopRequireDefault(_Base2);

var _observerUtil = require('@nx-js/observer-util');

var _util = require('../util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_LISTENERS = 100;

var Query = function (_Base) {
  (0, _inherits3.default)(Query, _Base);

  function Query() {
    var _ref;

    (0, _classCallCheck3.default)(this, Query);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = Query.__proto__ || (0, _getPrototypeOf2.default)(Query)).call.apply(_ref, [this].concat(args)));

    var _this$params = (0, _slicedToArray3.default)(_this.params, 2),
        collection = _this$params[0],
        query = _this$params[1];

    _this.collection = collection;
    _this.query = query;
    _this.listeners = [];
    return _this;
  }

  (0, _createClass3.default)(Query, [{
    key: 'init',
    value: function init(firstItem) {
      return this._subscribe(firstItem);
    }
  }, {
    key: 'refModel',
    value: function refModel() {
      if (this.cancelled) return;
      var key = this.key;

      this.subscription.ref(this.model.at(key));
      (0, _util.observablePath)(this.model.path(key));
      this.subscription.refIds(this.model.at(getIdsName(key)));
    }
  }, {
    key: 'unrefModel',
    value: function unrefModel() {
      var key = this.key;

      this.model.removeRef(getIdsName(key));
      this.model.removeRef(key);
    }
  }, {
    key: '_subscribe',
    value: function _subscribe(firstItem) {
      var _this2 = this;

      var collection = this.collection,
          query = this.query;

      this.subscription = this.model.root.query(collection, query);
      var promise = this.model.root.subscribeSync(this.subscription);

      // if promise wasn't resolved synchronously it means that we have to wait
      // for the subscription to finish, in that case we unsubscribe from the data
      // and throw the promise out to be caught by the wrapping <Suspense>
      if (firstItem && !promise.sync) {
        throw promise.then(function () {
          return new _promise2.default(function (resolve) {
            _this2._unsubscribe(); // unsubscribe the old hook to prevent memory leaks
            setTimeout(resolve, 0);
          });
        });
      }

      var finish = function finish() {
        if (_this2.cancelled) return;
        // TODO: if (err) return reject(err)
        // observe ids and extra
        var path = '$queries.' + _this2.subscription.hash;
        (0, _util.observablePath)(path);

        // observe initial docs
        var docIds = _this2.subscription.getIds();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(docIds), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var docId = _step.value;

            var shareDoc = _this2.model.root.connection.get(collection, docId);
            shareDoc.data = (0, _observerUtil.observable)(shareDoc.data);
          }
          // Increase the listeners cap
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        _this2.subscription.shareQuery.setMaxListeners(MAX_LISTENERS);

        // [insert]
        var insertFn = function insertFn(shareDocs) {
          // observe new docs
          var ids = getShareResultsIds(shareDocs);
          ids.forEach(function (docId) {
            var shareDoc = _this2.model.root.connection.get(collection, docId);
            shareDoc.data = (0, _observerUtil.observable)(shareDoc.data);
          });
        };
        _this2.subscription.shareQuery.on('insert', insertFn);
        _this2.listeners.push({
          ee: _this2.subscription.shareQuery,
          eventName: 'insert',
          fn: insertFn
        });
      };

      if (promise.sync) {
        finish();
      } else {
        return promise.then(finish);
      }
    }
  }, {
    key: '_clearListeners',
    value: function _clearListeners() {
      // remove query listeners
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.listeners), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var listener = _step2.value;

          listener.ee.removeListener(listener.eventName, listener.fn);
          delete listener.ee;
          delete listener.fn;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      delete this.listeners;
    }
  }, {
    key: '_unsubscribe',
    value: function _unsubscribe() {
      if (!this.subscription) return;
      this.model.root.unsubscribe(this.subscription);
      // setTimeout(() => {
      //   console.log('>> unsubscribe')
      //   model.unsubscribe(subscription)
      // }, 3000)
      delete this.subscription;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      try {
        this._clearListeners();
        // this.unrefModel() // TODO: Maybe enable unref in future
        // TODO: Test what happens when trying to unsubscribe from not yet subscribed
        this._unsubscribe();
      } catch (err) {}
      delete this.query;
      delete this.collection;
      (0, _get3.default)(Query.prototype.__proto__ || (0, _getPrototypeOf2.default)(Query.prototype), 'destroy', this).call(this);
    }
  }]);
  return Query;
}(_Base3.default);

exports.default = Query;
function getIdsName(plural) {
  if (/ies$/i.test(plural)) return plural.replace(/ies$/i, 'y') + 'Ids';
  return plural.replace(/s$/i, '') + 'Ids';
}

function getShareResultsIds(results) {
  var ids = [];
  for (var i = 0; i < results.length; i++) {
    var shareDoc = results[i];
    ids.push(shareDoc.id);
  }
  return ids;
}