'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Base2 = require('./Base');

var _Base3 = _interopRequireDefault(_Base2);

var _observerUtil = require('@nx-js/observer-util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Doc = function (_Base) {
  (0, _inherits3.default)(Doc, _Base);

  function Doc() {
    var _ref;

    (0, _classCallCheck3.default)(this, Doc);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = Doc.__proto__ || (0, _getPrototypeOf2.default)(Doc)).call.apply(_ref, [this].concat(args)));

    var _this$params = (0, _slicedToArray3.default)(_this.params, 2),
        collection = _this$params[0],
        docId = _this$params[1];

    _this.collection = collection;
    _this.docId = docId;
    _this.listeners = [];
    return _this;
  }

  (0, _createClass3.default)(Doc, [{
    key: 'init',
    value: function init(firstItem) {
      return this._subscribe(firstItem);
    }
  }, {
    key: 'refModel',
    value: function refModel() {
      if (this.cancelled) return;
      var key = this.key;

      this.model.ref(key, this.subscription);
    }
  }, {
    key: 'unrefModel',
    value: function unrefModel() {
      var key = this.key;

      this.model.removeRef(key);
    }
  }, {
    key: '_subscribe',
    value: function _subscribe(firstItem) {
      var _this2 = this;

      var collection = this.collection,
          docId = this.docId;

      this.subscription = this.model.root.scope(collection + '.' + docId);
      var promise = this.model.root.subscribeSync(this.subscription);

      // if promise wasn't resolved synchronously it means that we have to wait
      // for the subscription to finish, in that case we unsubscribe from the data
      // and throw the promise out to be caught by the wrapping <Suspense>
      if (firstItem && !promise.sync) {
        throw promise.then(function () {
          return new _promise2.default(function (resolve) {
            _this2._unsubscribe(); // unsubscribe the old hook to prevent memory leaks
            setTimeout(resolve, 0);
          });
        });
      }

      var finish = function finish() {
        if (_this2.cancelled) return;
        // TODO: if (err) return reject(err)
        var shareDoc = _this2.model.root.connection.get(collection, docId);
        shareDoc.data = (0, _observerUtil.observable)(shareDoc.data);

        // Listen for doc creation, intercept it and make observable
        var createFn = function createFn() {
          var shareDoc = _this2.model.root.connection.get(collection, docId);
          shareDoc.data = (0, _observerUtil.observable)(shareDoc.data);
        };
        // Add listener to the top of the queue, since we want
        // to modify shareDoc.data before racer gets to it
        prependListener(shareDoc, 'create', createFn);
        _this2.listeners.push({
          ee: shareDoc,
          eventName: 'create',
          fn: createFn
        });
      };

      if (promise.sync) {
        finish();
      } else {
        return promise.then(finish);
      }
    }
  }, {
    key: '_clearListeners',
    value: function _clearListeners() {
      // remove query listeners
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.listeners), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var listener = _step.value;

          listener.ee.removeListener(listener.eventName, listener.fn);
          delete listener.ee;
          delete listener.fn;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      delete this.listeners;
    }
  }, {
    key: '_unsubscribe',
    value: function _unsubscribe() {
      if (!this.subscription) return;
      this.model.root.unsubscribe(this.subscription);
      delete this.subscription;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      try {
        this._clearListeners();
        // this.unrefModel() // TODO: Maybe enable unref in future
        // TODO: Test what happens when trying to unsubscribe from not yet subscribed
        this._unsubscribe();
      } catch (err) {}
      delete this.docId;
      delete this.collection;
      (0, _get3.default)(Doc.prototype.__proto__ || (0, _getPrototypeOf2.default)(Doc.prototype), 'destroy', this).call(this);
    }
  }]);
  return Doc;
}(_Base3.default);

// Shim for EventEmitter.prependListener.
// Right now this is required to support older build environments
// like react-native and webpack v1.
// TODO: Replace this with EventEmitter.prependListener in future


exports.default = Doc;
function prependListener(emitter, event, listener) {
  var old = emitter.listeners(event) || [];
  emitter.removeAllListeners(event);
  var rv = emitter.on(event, listener);
  for (var i = 0, len = old.length; i < len; i++) {
    emitter.on(event, old[i]);
  }
  return rv;
}
module.exports = exports['default'];