{"ast":null,"code":"var Doc = require('./doc');\n\nvar Query = require('./query');\n\nvar Presence = require('./presence/presence');\n\nvar DocPresence = require('./presence/doc-presence');\n\nvar SnapshotVersionRequest = require('./snapshot-request/snapshot-version-request');\n\nvar SnapshotTimestampRequest = require('./snapshot-request/snapshot-timestamp-request');\n\nvar emitter = require('../emitter');\n\nvar ShareDBError = require('../error');\n\nvar types = require('../types');\n\nvar util = require('../util');\n\nvar logger = require('../logger');\n\nvar ERROR_CODE = ShareDBError.CODES;\n\nfunction connectionState(socket) {\n  if (socket.readyState === 0 || socket.readyState === 1) return 'connecting';\n  return 'disconnected';\n}\n/**\n * Handles communication with the sharejs server and provides queries and\n * documents.\n *\n * We create a connection with a socket object\n *   connection = new sharejs.Connection(sockset)\n * The socket may be any object handling the websocket protocol. See the\n * documentation of bindToSocket() for details. We then wait for the connection\n * to connect\n *   connection.on('connected', ...)\n * and are finally able to work with shared documents\n *   connection.get('food', 'steak') // Doc\n *\n * @param socket @see bindToSocket\n */\n\n\nmodule.exports = Connection;\n\nfunction Connection(socket) {\n  emitter.EventEmitter.call(this); // Map of collection -> id -> doc object for created documents.\n  // (created documents MUST BE UNIQUE)\n\n  this.collections = {}; // Each query and snapshot request is created with an id that the server uses when it sends us\n  // info about the request (updates, etc)\n\n  this.nextQueryId = 1;\n  this.nextSnapshotRequestId = 1; // Map from query ID -> query object.\n\n  this.queries = {}; // Maps from channel -> presence objects\n\n  this._presences = {}; // Map from snapshot request ID -> snapshot request\n\n  this._snapshotRequests = {}; // A unique message number for the given id\n\n  this.seq = 1; // A unique message number for presence\n\n  this._presenceSeq = 1; // Equals agent.src on the server\n\n  this.id = null; // This direct reference from connection to agent is not used internal to\n  // ShareDB, but it is handy for server-side only user code that may cache\n  // state on the agent and read it in middleware\n\n  this.agent = null;\n  this.debug = false;\n  this.state = connectionState(socket);\n  this.bindToSocket(socket);\n}\n\nemitter.mixin(Connection);\n/**\n * Use socket to communicate with server\n *\n * Socket is an object that can handle the websocket protocol. This method\n * installs the onopen, onclose, onmessage and onerror handlers on the socket to\n * handle communication and sends messages by calling socket.send(message). The\n * sockets `readyState` property is used to determine the initaial state.\n *\n * @param socket Handles the websocket protocol\n * @param socket.readyState\n * @param socket.close\n * @param socket.send\n * @param socket.onopen\n * @param socket.onclose\n * @param socket.onmessage\n * @param socket.onerror\n */\n\nConnection.prototype.bindToSocket = function (socket) {\n  if (this.socket) {\n    this.socket.close();\n    this.socket.onmessage = null;\n    this.socket.onopen = null;\n    this.socket.onerror = null;\n    this.socket.onclose = null;\n  }\n\n  this.socket = socket; // State of the connection. The corresponding events are emitted when this changes\n  //\n  // - 'connecting'   The connection is still being established, or we are still\n  //                    waiting on the server to send us the initialization message\n  // - 'connected'    The connection is open and we have connected to a server\n  //                    and recieved the initialization message\n  // - 'disconnected' Connection is closed, but it will reconnect automatically\n  // - 'closed'       The connection was closed by the client, and will not reconnect\n  // - 'stopped'      The connection was closed by the server, and will not reconnect\n\n  var newState = connectionState(socket);\n\n  this._setState(newState); // This is a helper variable the document uses to see whether we're\n  // currently in a 'live' state. It is true if and only if we're connected\n\n\n  this.canSend = false;\n  var connection = this;\n\n  socket.onmessage = function (event) {\n    try {\n      var data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n    } catch (err) {\n      logger.warn('Failed to parse message', event);\n      return;\n    }\n\n    if (connection.debug) logger.info('RECV', JSON.stringify(data));\n    var request = {\n      data: data\n    };\n    connection.emit('receive', request);\n    if (!request.data) return;\n\n    try {\n      connection.handleMessage(request.data);\n    } catch (err) {\n      util.nextTick(function () {\n        connection.emit('error', err);\n      });\n    }\n  }; // If socket is already open, do handshake immediately.\n\n\n  if (socket.readyState === 1) {\n    connection._initializeHandshake();\n  }\n\n  socket.onopen = function () {\n    connection._setState('connecting');\n\n    connection._initializeHandshake();\n  };\n\n  socket.onerror = function (err) {\n    // This isn't the same as a regular error, because it will happen normally\n    // from time to time. Your connection should probably automatically\n    // reconnect anyway, but that should be triggered off onclose not onerror.\n    // (onclose happens when onerror gets called anyway).\n    connection.emit('connection error', err);\n  };\n\n  socket.onclose = function (reason) {\n    // node-browserchannel reason values:\n    //   'Closed' - The socket was manually closed by calling socket.close()\n    //   'Stopped by server' - The server sent the stop message to tell the client not to try connecting\n    //   'Request failed' - Server didn't respond to request (temporary, usually offline)\n    //   'Unknown session ID' - Server session for client is missing (temporary, will immediately reestablish)\n    if (reason === 'closed' || reason === 'Closed') {\n      connection._setState('closed', reason);\n    } else if (reason === 'stopped' || reason === 'Stopped by server') {\n      connection._setState('stopped', reason);\n    } else {\n      connection._setState('disconnected', reason);\n    }\n  };\n};\n/**\n * @param {object} message\n * @param {string} message.a action\n */\n\n\nConnection.prototype.handleMessage = function (message) {\n  var err = null;\n\n  if (message.error) {\n    err = wrapErrorData(message.error, message);\n    delete message.error;\n  } // Switch on the message action. Most messages are for documents and are\n  // handled in the doc class.\n\n\n  switch (message.a) {\n    case 'init':\n      // Client initialization packet\n      return this._handleLegacyInit(message);\n\n    case 'hs':\n      return this._handleHandshake(err, message);\n\n    case 'qf':\n      var query = this.queries[message.id];\n      if (query) query._handleFetch(err, message.data, message.extra);\n      return;\n\n    case 'qs':\n      var query = this.queries[message.id];\n      if (query) query._handleSubscribe(err, message.data, message.extra);\n      return;\n\n    case 'qu':\n      // Queries are removed immediately on calls to destroy, so we ignore\n      // replies to query unsubscribes. Perhaps there should be a callback for\n      // destroy, but this is currently unimplemented\n      return;\n\n    case 'q':\n      // Query message. Pass this to the appropriate query object.\n      var query = this.queries[message.id];\n      if (!query) return;\n      if (err) return query._handleError(err);\n      if (message.diff) query._handleDiff(message.diff);\n      if (message.hasOwnProperty('extra')) query._handleExtra(message.extra);\n      return;\n\n    case 'bf':\n      return this._handleBulkMessage(err, message, '_handleFetch');\n\n    case 'bs':\n    case 'bu':\n      return this._handleBulkMessage(err, message, '_handleSubscribe');\n\n    case 'nf':\n    case 'nt':\n      return this._handleSnapshotFetch(err, message);\n\n    case 'f':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleFetch(err, message.data);\n      return;\n\n    case 's':\n    case 'u':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleSubscribe(err, message.data);\n      return;\n\n    case 'op':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleOp(err, message);\n      return;\n\n    case 'p':\n      return this._handlePresence(err, message);\n\n    case 'ps':\n      return this._handlePresenceSubscribe(err, message);\n\n    case 'pu':\n      return this._handlePresenceUnsubscribe(err, message);\n\n    case 'pr':\n      return this._handlePresenceRequest(err, message);\n\n    default:\n      logger.warn('Ignoring unrecognized message', message);\n  }\n};\n\nfunction wrapErrorData(errorData, fullMessage) {\n  // wrap in Error object so can be passed through event emitters\n  var err = new Error(errorData.message);\n  err.code = errorData.code;\n\n  if (fullMessage) {\n    // Add the message data to the error object for more context\n    err.data = fullMessage;\n  }\n\n  return err;\n}\n\nConnection.prototype._handleBulkMessage = function (err, message, method) {\n  if (message.data) {\n    for (var id in message.data) {\n      var dataForId = message.data[id];\n      var doc = this.getExisting(message.c, id);\n\n      if (doc) {\n        if (err) {\n          doc[method](err);\n        } else if (dataForId.error) {\n          // Bulk reply snapshot-specific errorr - see agent.js getMapResult\n          doc[method](wrapErrorData(dataForId.error));\n        } else {\n          doc[method](null, dataForId);\n        }\n      }\n    }\n  } else if (Array.isArray(message.b)) {\n    for (var i = 0; i < message.b.length; i++) {\n      var id = message.b[i];\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](err);\n    }\n  } else if (message.b) {\n    for (var id in message.b) {\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](err);\n    }\n  } else {\n    logger.error('Invalid bulk message', message);\n  }\n};\n\nConnection.prototype._reset = function () {\n  this.agent = null;\n}; // Set the connection's state. The connection is basically a state machine.\n\n\nConnection.prototype._setState = function (newState, reason) {\n  if (this.state === newState) return; // I made a state diagram. The only invalid transitions are getting to\n  // 'connecting' from anywhere other than 'disconnected' and getting to\n  // 'connected' from anywhere other than 'connecting'.\n\n  if (newState === 'connecting' && this.state !== 'disconnected' && this.state !== 'stopped' && this.state !== 'closed' || newState === 'connected' && this.state !== 'connecting') {\n    var err = new ShareDBError(ERROR_CODE.ERR_CONNECTION_STATE_TRANSITION_INVALID, 'Cannot transition directly from ' + this.state + ' to ' + newState);\n    return this.emit('error', err);\n  }\n\n  this.state = newState;\n  this.canSend = newState === 'connected';\n\n  if (newState === 'disconnected' || newState === 'stopped' || newState === 'closed') {\n    this._reset();\n  } // Group subscribes together to help server make more efficient calls\n\n\n  this.startBulk(); // Emit the event to all queries\n\n  for (var id in this.queries) {\n    var query = this.queries[id];\n\n    query._onConnectionStateChanged();\n  } // Emit the event to all documents\n\n\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n\n    for (var id in docs) {\n      docs[id]._onConnectionStateChanged();\n    }\n  } // Emit the event to all Presences\n\n\n  for (var channel in this._presences) {\n    this._presences[channel]._onConnectionStateChanged();\n  } // Emit the event to all snapshots\n\n\n  for (var id in this._snapshotRequests) {\n    var snapshotRequest = this._snapshotRequests[id];\n\n    snapshotRequest._onConnectionStateChanged();\n  }\n\n  this.endBulk();\n  this.emit(newState, reason);\n  this.emit('state', newState, reason);\n};\n\nConnection.prototype.startBulk = function () {\n  if (!this.bulk) this.bulk = {};\n};\n\nConnection.prototype.endBulk = function () {\n  if (this.bulk) {\n    for (var collection in this.bulk) {\n      var actions = this.bulk[collection];\n\n      this._sendBulk('f', collection, actions.f);\n\n      this._sendBulk('s', collection, actions.s);\n\n      this._sendBulk('u', collection, actions.u);\n    }\n  }\n\n  this.bulk = null;\n};\n\nConnection.prototype._sendBulk = function (action, collection, values) {\n  if (!values) return;\n  var ids = [];\n  var versions = {};\n  var versionsCount = 0;\n  var versionId;\n\n  for (var id in values) {\n    var value = values[id];\n\n    if (value == null) {\n      ids.push(id);\n    } else {\n      versions[id] = value;\n      versionId = id;\n      versionsCount++;\n    }\n  }\n\n  if (ids.length === 1) {\n    var id = ids[0];\n    this.send({\n      a: action,\n      c: collection,\n      d: id\n    });\n  } else if (ids.length) {\n    this.send({\n      a: 'b' + action,\n      c: collection,\n      b: ids\n    });\n  }\n\n  if (versionsCount === 1) {\n    var version = versions[versionId];\n    this.send({\n      a: action,\n      c: collection,\n      d: versionId,\n      v: version\n    });\n  } else if (versionsCount) {\n    this.send({\n      a: 'b' + action,\n      c: collection,\n      b: versions\n    });\n  }\n};\n\nConnection.prototype._sendAction = function (action, doc, version) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n\n  if (this.bulk) {\n    // Bulk subscribe\n    var actions = this.bulk[doc.collection] || (this.bulk[doc.collection] = {});\n    var versions = actions[action] || (actions[action] = {});\n    var isDuplicate = versions.hasOwnProperty(doc.id);\n    versions[doc.id] = version;\n    return isDuplicate;\n  } else {\n    // Send single doc subscribe message\n    var message = {\n      a: action,\n      c: doc.collection,\n      d: doc.id,\n      v: version\n    };\n    this.send(message);\n  }\n};\n\nConnection.prototype.sendFetch = function (doc) {\n  return this._sendAction('f', doc, doc.version);\n};\n\nConnection.prototype.sendSubscribe = function (doc) {\n  return this._sendAction('s', doc, doc.version);\n};\n\nConnection.prototype.sendUnsubscribe = function (doc) {\n  return this._sendAction('u', doc);\n};\n\nConnection.prototype.sendOp = function (doc, op) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n\n  var message = {\n    a: 'op',\n    c: doc.collection,\n    d: doc.id,\n    v: doc.version,\n    src: op.src,\n    seq: op.seq,\n    x: {}\n  };\n  if ('op' in op) message.op = op.op;\n  if (op.create) message.create = op.create;\n  if (op.del) message.del = op.del;\n  if (doc.submitSource) message.x.source = op.source;\n  this.send(message);\n};\n/**\n * Sends a message down the socket\n */\n\n\nConnection.prototype.send = function (message) {\n  if (this.debug) logger.info('SEND', JSON.stringify(message));\n  this.emit('send', message);\n  this.socket.send(JSON.stringify(message));\n};\n/**\n * Closes the socket and emits 'closed'\n */\n\n\nConnection.prototype.close = function () {\n  this.socket.close();\n};\n\nConnection.prototype.getExisting = function (collection, id) {\n  if (this.collections[collection]) return this.collections[collection][id];\n};\n/**\n * Get or create a document.\n *\n * @param collection\n * @param id\n * @return {Doc}\n */\n\n\nConnection.prototype.get = function (collection, id) {\n  var docs = this.collections[collection] || (this.collections[collection] = {});\n  var doc = docs[id];\n\n  if (!doc) {\n    doc = docs[id] = new Doc(this, collection, id);\n    this.emit('doc', doc);\n  }\n\n  return doc;\n};\n/**\n * Remove document from this.collections\n *\n * @private\n */\n\n\nConnection.prototype._destroyDoc = function (doc) {\n  util.digAndRemove(this.collections, doc.collection, doc.id);\n};\n\nConnection.prototype._addDoc = function (doc) {\n  var docs = this.collections[doc.collection];\n\n  if (!docs) {\n    docs = this.collections[doc.collection] = {};\n  }\n\n  if (docs[doc.id] !== doc) {\n    docs[doc.id] = doc;\n  }\n}; // Helper for createFetchQuery and createSubscribeQuery, below.\n\n\nConnection.prototype._createQuery = function (action, collection, q, options, callback) {\n  var id = this.nextQueryId++;\n  var query = new Query(action, this, id, collection, q, options, callback);\n  this.queries[id] = query;\n  query.send();\n  return query;\n}; // Internal function. Use query.destroy() to remove queries.\n\n\nConnection.prototype._destroyQuery = function (query) {\n  delete this.queries[query.id];\n}; // The query options object can contain the following fields:\n//\n// db: Name of the db for the query. You can attach extraDbs to ShareDB and\n//   pick which one the query should hit using this parameter.\n// Create a fetch query. Fetch queries are only issued once, returning the\n// results directly into the callback.\n//\n// The callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\n\n\nConnection.prototype.createFetchQuery = function (collection, q, options, callback) {\n  return this._createQuery('qf', collection, q, options, callback);\n}; // Create a subscribe query. Subscribe queries return with the initial data\n// through the callback, then update themselves whenever the query result set\n// changes via their own event emitter.\n//\n// If present, the callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\n\n\nConnection.prototype.createSubscribeQuery = function (collection, q, options, callback) {\n  return this._createQuery('qs', collection, q, options, callback);\n};\n\nConnection.prototype.hasPending = function () {\n  return !!(this._firstDoc(hasPending) || this._firstQuery(hasPending) || this._firstSnapshotRequest());\n};\n\nfunction hasPending(object) {\n  return object.hasPending();\n}\n\nConnection.prototype.hasWritePending = function () {\n  return !!this._firstDoc(hasWritePending);\n};\n\nfunction hasWritePending(object) {\n  return object.hasWritePending();\n}\n\nConnection.prototype.whenNothingPending = function (callback) {\n  var doc = this._firstDoc(hasPending);\n\n  if (doc) {\n    // If a document is found with a pending operation, wait for it to emit\n    // that nothing is pending anymore, and then recheck all documents again.\n    // We have to recheck all documents, just in case another mutation has\n    // been made in the meantime as a result of an event callback\n    doc.once('nothing pending', this._nothingPendingRetry(callback));\n    return;\n  }\n\n  var query = this._firstQuery(hasPending);\n\n  if (query) {\n    query.once('ready', this._nothingPendingRetry(callback));\n    return;\n  }\n\n  var snapshotRequest = this._firstSnapshotRequest();\n\n  if (snapshotRequest) {\n    snapshotRequest.once('ready', this._nothingPendingRetry(callback));\n    return;\n  } // Call back when no pending operations\n\n\n  util.nextTick(callback);\n};\n\nConnection.prototype._nothingPendingRetry = function (callback) {\n  var connection = this;\n  return function () {\n    util.nextTick(function () {\n      connection.whenNothingPending(callback);\n    });\n  };\n};\n\nConnection.prototype._firstDoc = function (fn) {\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n\n    for (var id in docs) {\n      var doc = docs[id];\n\n      if (fn(doc)) {\n        return doc;\n      }\n    }\n  }\n};\n\nConnection.prototype._firstQuery = function (fn) {\n  for (var id in this.queries) {\n    var query = this.queries[id];\n\n    if (fn(query)) {\n      return query;\n    }\n  }\n};\n\nConnection.prototype._firstSnapshotRequest = function () {\n  for (var id in this._snapshotRequests) {\n    return this._snapshotRequests[id];\n  }\n};\n/**\n * Fetch a read-only snapshot at a given version\n *\n * @param collection - the collection name of the snapshot\n * @param id - the ID of the snapshot\n * @param version (optional) - the version number to fetch. If null, the latest version is fetched.\n * @param callback - (error, snapshot) => void, where snapshot takes the following schema:\n *\n * {\n *   id: string;         // ID of the snapshot\n *   v: number;          // version number of the snapshot\n *   type: string;       // the OT type of the snapshot, or null if it doesn't exist or is deleted\n *   data: any;          // the snapshot\n * }\n *\n */\n\n\nConnection.prototype.fetchSnapshot = function (collection, id, version, callback) {\n  if (typeof version === 'function') {\n    callback = version;\n    version = null;\n  }\n\n  var requestId = this.nextSnapshotRequestId++;\n  var snapshotRequest = new SnapshotVersionRequest(this, requestId, collection, id, version, callback);\n  this._snapshotRequests[snapshotRequest.requestId] = snapshotRequest;\n  snapshotRequest.send();\n};\n/**\n * Fetch a read-only snapshot at a given timestamp\n *\n * @param collection - the collection name of the snapshot\n * @param id - the ID of the snapshot\n * @param timestamp (optional) - the timestamp to fetch. If null, the latest version is fetched.\n * @param callback - (error, snapshot) => void, where snapshot takes the following schema:\n *\n * {\n *   id: string;         // ID of the snapshot\n *   v: number;          // version number of the snapshot\n *   type: string;       // the OT type of the snapshot, or null if it doesn't exist or is deleted\n *   data: any;          // the snapshot\n * }\n *\n */\n\n\nConnection.prototype.fetchSnapshotByTimestamp = function (collection, id, timestamp, callback) {\n  if (typeof timestamp === 'function') {\n    callback = timestamp;\n    timestamp = null;\n  }\n\n  var requestId = this.nextSnapshotRequestId++;\n  var snapshotRequest = new SnapshotTimestampRequest(this, requestId, collection, id, timestamp, callback);\n  this._snapshotRequests[snapshotRequest.requestId] = snapshotRequest;\n  snapshotRequest.send();\n};\n\nConnection.prototype._handleSnapshotFetch = function (error, message) {\n  var snapshotRequest = this._snapshotRequests[message.id];\n  if (!snapshotRequest) return;\n  delete this._snapshotRequests[message.id];\n\n  snapshotRequest._handleResponse(error, message);\n};\n\nConnection.prototype._handleLegacyInit = function (message) {\n  // If the minor protocol version has been set, we want to use the\n  // new handshake protocol. Let's send a handshake initialize, because\n  // we now know the server is ready. If we've already sent it, we'll\n  // just ignore the response anyway.\n  if (message.protocolMinor) return this._initializeHandshake();\n\n  this._initialize(message);\n};\n\nConnection.prototype._initializeHandshake = function () {\n  this.send({\n    a: 'hs',\n    id: this.id\n  });\n};\n\nConnection.prototype._handleHandshake = function (error, message) {\n  if (error) return this.emit('error', error);\n\n  this._initialize(message);\n};\n\nConnection.prototype._initialize = function (message) {\n  if (this.state !== 'connecting') return;\n\n  if (message.protocol !== 1) {\n    return this.emit('error', new ShareDBError(ERROR_CODE.ERR_PROTOCOL_VERSION_NOT_SUPPORTED, 'Unsupported protocol version: ' + message.protocol));\n  }\n\n  if (types.map[message.type] !== types.defaultType) {\n    return this.emit('error', new ShareDBError(ERROR_CODE.ERR_DEFAULT_TYPE_MISMATCH, message.type + ' does not match the server default type'));\n  }\n\n  if (typeof message.id !== 'string') {\n    return this.emit('error', new ShareDBError(ERROR_CODE.ERR_CLIENT_ID_BADLY_FORMED, 'Client id must be a string'));\n  }\n\n  this.id = message.id;\n\n  this._setState('connected');\n};\n\nConnection.prototype.getPresence = function (channel) {\n  var connection = this;\n  return util.digOrCreate(this._presences, channel, function () {\n    return new Presence(connection, channel);\n  });\n};\n\nConnection.prototype.getDocPresence = function (collection, id) {\n  var channel = DocPresence.channel(collection, id);\n  var connection = this;\n  return util.digOrCreate(this._presences, channel, function () {\n    return new DocPresence(connection, collection, id);\n  });\n};\n\nConnection.prototype._sendPresenceAction = function (action, seq, presence) {\n  // Ensure the presence is registered so that it receives the reply message\n  this._addPresence(presence);\n\n  var message = {\n    a: action,\n    ch: presence.channel,\n    seq: seq\n  };\n  this.send(message);\n  return message.seq;\n};\n\nConnection.prototype._addPresence = function (presence) {\n  util.digOrCreate(this._presences, presence.channel, function () {\n    return presence;\n  });\n};\n\nConnection.prototype._handlePresenceSubscribe = function (error, message) {\n  var presence = util.dig(this._presences, message.ch);\n  if (presence) presence._handleSubscribe(error, message.seq);\n};\n\nConnection.prototype._handlePresenceUnsubscribe = function (error, message) {\n  var presence = util.dig(this._presences, message.ch);\n  if (presence) presence._handleUnsubscribe(error, message.seq);\n};\n\nConnection.prototype._handlePresence = function (error, message) {\n  var presence = util.dig(this._presences, message.ch);\n  if (presence) presence._receiveUpdate(error, message);\n};\n\nConnection.prototype._handlePresenceRequest = function (error, message) {\n  var presence = util.dig(this._presences, message.ch);\n  if (presence) presence._broadcastAllLocalPresence(error, message);\n};","map":null,"metadata":{},"sourceType":"script"}