{"ast":null,"code":"import { Decoration, EditorView, ViewPlugin, logException, WidgetType } from '@codemirror/view';\nimport { StateEffect, StateField, Facet } from '@codemirror/state';\nimport { hoverTooltip, showTooltip } from '@codemirror/tooltip';\nimport { showPanel, getPanel } from '@codemirror/panel';\nimport { gutter, GutterMarker } from '@codemirror/gutter';\nimport { RangeSet } from '@codemirror/rangeset';\nimport elt from 'crelt';\n\nclass SelectedDiagnostic {\n  constructor(from, to, diagnostic) {\n    this.from = from;\n    this.to = to;\n    this.diagnostic = diagnostic;\n  }\n\n}\n\nclass LintState {\n  constructor(diagnostics, panel, selected) {\n    this.diagnostics = diagnostics;\n    this.panel = panel;\n    this.selected = selected;\n  }\n\n  static init(diagnostics, panel, state) {\n    let ranges = Decoration.set(diagnostics.map(d => {\n      // For zero-length ranges or ranges covering only a line break, create a widget\n      return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({\n        widget: new DiagnosticWidget(d),\n        diagnostic: d\n      }).range(d.from) : Decoration.mark({\n        attributes: {\n          class: \"cm-lintRange cm-lintRange-\" + d.severity\n        },\n        diagnostic: d\n      }).range(d.from, d.to);\n    }), true);\n    return new LintState(ranges, panel, findDiagnostic(ranges));\n  }\n\n}\n\nfunction findDiagnostic(diagnostics) {\n  let diagnostic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let found = null;\n  diagnostics.between(after, 1e9, (from, to, _ref) => {\n    let {\n      spec\n    } = _ref;\n    if (diagnostic && spec.diagnostic != diagnostic) return;\n    found = new SelectedDiagnostic(from, to, spec.diagnostic);\n    return false;\n  });\n  return found;\n}\n\nfunction maybeEnableLint(state, effects) {\n  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([lintState, EditorView.decorations.compute([lintState], state => {\n    let {\n      selected,\n      panel\n    } = state.field(lintState);\n    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([activeMark.range(selected.from, selected.to)]);\n  }), hoverTooltip(lintTooltip), baseTheme]));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/\n\n\nfunction setDiagnostics(state, diagnostics) {\n  return {\n    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])\n  };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/\n\n\nconst setDiagnosticsEffect = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/StateEffect.define();\nconst lintState = /*@__PURE__*/StateField.define({\n  create() {\n    return new LintState(Decoration.none, null, null);\n  },\n\n  update(value, tr) {\n    if (tr.docChanged) {\n      let mapped = value.diagnostics.map(tr.changes),\n          selected = null;\n\n      if (value.selected) {\n        let selPos = tr.changes.mapPos(value.selected.from, 1);\n        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n      }\n\n      value = new LintState(mapped, value.panel, selected);\n    }\n\n    for (let effect of tr.effects) {\n      if (effect.is(setDiagnosticsEffect)) {\n        value = LintState.init(effect.value, value.panel, tr.state);\n      } else if (effect.is(togglePanel)) {\n        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n      } else if (effect.is(movePanelSelection)) {\n        value = new LintState(value.diagnostics, value.panel, effect.value);\n      }\n    }\n\n    return value;\n  },\n\n  provide: f => [showPanel.from(f, val => val.panel), EditorView.decorations.from(f, s => s.diagnostics)]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/\n\nfunction diagnosticCount(state) {\n  let lint = state.field(lintState, false);\n  return lint ? lint.diagnostics.size : 0;\n}\n\nconst activeMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-lintRange cm-lintRange-active\"\n});\n\nfunction lintTooltip(view, pos, side) {\n  let {\n    diagnostics\n  } = view.state.field(lintState);\n  let found = [],\n      stackStart = 2e8,\n      stackEnd = 0;\n  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, _ref2) => {\n    let {\n      spec\n    } = _ref2;\n\n    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {\n      found.push(spec.diagnostic);\n      stackStart = Math.min(from, stackStart);\n      stackEnd = Math.max(to, stackEnd);\n    }\n  });\n  if (!found.length) return null;\n  return {\n    pos: stackStart,\n    end: stackEnd,\n    above: view.state.doc.lineAt(stackStart).to < stackEnd,\n\n    create() {\n      return {\n        dom: diagnosticsTooltip(view, found)\n      };\n    }\n\n  };\n}\n\nfunction diagnosticsTooltip(view, diagnostics) {\n  return elt(\"ul\", {\n    class: \"cm-tooltip-lint\"\n  }, diagnostics.map(d => renderDiagnostic(view, d, false)));\n}\n/**\nCommand to open and focus the lint panel.\n*/\n\n\nconst openLintPanel = view => {\n  let field = view.state.field(lintState, false);\n  if (!field || !field.panel) view.dispatch({\n    effects: maybeEnableLint(view.state, [togglePanel.of(true)])\n  });\n  let panel = getPanel(view, LintPanel.open);\n  if (panel) panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n  return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/\n\n\nconst closeLintPanel = view => {\n  let field = view.state.field(lintState, false);\n  if (!field || !field.panel) return false;\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/\n\n\nconst nextDiagnostic = view => {\n  let field = view.state.field(lintState, false);\n  if (!field) return false;\n  let sel = view.state.selection.main,\n      next = field.diagnostics.iter(sel.to + 1);\n\n  if (!next.value) {\n    next = field.diagnostics.iter(0);\n    if (!next.value || next.from == sel.from && next.to == sel.to) return false;\n  }\n\n  view.dispatch({\n    selection: {\n      anchor: next.from,\n      head: next.to\n    },\n    scrollIntoView: true\n  });\n  return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/\n\n\nconst lintKeymap = [{\n  key: \"Mod-Shift-m\",\n  run: openLintPanel\n}, {\n  key: \"F8\",\n  run: nextDiagnostic\n}];\nconst lintPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.timeout = -1;\n    this.set = true;\n    let {\n      delay\n    } = view.state.facet(lintSource);\n    this.lintTime = Date.now() + delay;\n    this.run = this.run.bind(this);\n    this.timeout = setTimeout(this.run, delay);\n  }\n\n  run() {\n    let now = Date.now();\n\n    if (now < this.lintTime - 10) {\n      setTimeout(this.run, this.lintTime - now);\n    } else {\n      this.set = false;\n      let {\n        state\n      } = this.view,\n          {\n        sources\n      } = state.facet(lintSource);\n      Promise.all(sources.map(source => Promise.resolve(source(this.view)))).then(annotations => {\n        var _a, _b;\n\n        let all = annotations.reduce((a, b) => a.concat(b));\n        if (this.view.state.doc == state.doc && (all.length || ((_b = (_a = this.view.state.field(lintState, false)) === null || _a === void 0 ? void 0 : _a.diagnostics) === null || _b === void 0 ? void 0 : _b.size))) this.view.dispatch(setDiagnostics(this.view.state, all));\n      }, error => {\n        logException(this.view.state, error);\n      });\n    }\n  }\n\n  update(update) {\n    let source = update.state.facet(lintSource);\n\n    if (update.docChanged || source != update.startState.facet(lintSource)) {\n      this.lintTime = Date.now() + source.delay;\n\n      if (!this.set) {\n        this.set = true;\n        this.timeout = setTimeout(this.run, source.delay);\n      }\n    }\n  }\n\n  force() {\n    if (this.set) {\n      this.lintTime = Date.now();\n      this.run();\n    }\n  }\n\n  destroy() {\n    clearTimeout(this.timeout);\n  }\n\n});\nconst lintSource = /*@__PURE__*/Facet.define({\n  combine(input) {\n    return {\n      sources: input.map(i => i.source),\n      delay: input.length ? Math.max(...input.map(i => i.delay)) : 750\n    };\n  },\n\n  enables: lintPlugin\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed).\n*/\n\nfunction linter(source) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  return lintSource.of({\n    source,\n    delay: (_a = config.delay) !== null && _a !== void 0 ? _a : 750\n  });\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/\n\n\nfunction forceLinting(view) {\n  let plugin = view.plugin(lintPlugin);\n  if (plugin) plugin.force();\n}\n\nfunction assignKeys(actions) {\n  let assigned = [];\n  if (actions) actions: for (let {\n    name\n  } of actions) {\n    for (let i = 0; i < name.length; i++) {\n      let ch = name[i];\n\n      if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {\n        assigned.push(ch);\n        continue actions;\n      }\n    }\n\n    assigned.push(\"\");\n  }\n  return assigned;\n}\n\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n  var _a;\n\n  let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n  return elt(\"li\", {\n    class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity\n  }, elt(\"span\", {\n    class: \"cm-diagnosticText\"\n  }, diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {\n    let click = e => {\n      e.preventDefault();\n      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n      if (found) action.apply(view, found.from, found.to);\n    };\n\n    let {\n      name\n    } = action,\n        keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n    let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex), elt(\"u\", name.slice(keyIndex, keyIndex + 1)), name.slice(keyIndex + 1)];\n    return elt(\"button\", {\n      type: \"button\",\n      class: \"cm-diagnosticAction\",\n      onclick: click,\n      onmousedown: click,\n      \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n    }, nameElt);\n  }), diagnostic.source && elt(\"div\", {\n    class: \"cm-diagnosticSource\"\n  }, diagnostic.source));\n}\n\nclass DiagnosticWidget extends WidgetType {\n  constructor(diagnostic) {\n    super();\n    this.diagnostic = diagnostic;\n  }\n\n  eq(other) {\n    return other.diagnostic == this.diagnostic;\n  }\n\n  toDOM() {\n    return elt(\"span\", {\n      class: \"cm-lintPoint cm-lintPoint-\" + this.diagnostic.severity\n    });\n  }\n\n}\n\nclass PanelItem {\n  constructor(view, diagnostic) {\n    this.diagnostic = diagnostic;\n    this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n    this.dom = renderDiagnostic(view, diagnostic, true);\n    this.dom.id = this.id;\n    this.dom.setAttribute(\"role\", \"option\");\n  }\n\n}\n\nclass LintPanel {\n  constructor(view) {\n    this.view = view;\n    this.items = [];\n\n    let onkeydown = event => {\n      if (event.keyCode == 27) {\n        // Escape\n        closeLintPanel(this.view);\n        this.view.focus();\n      } else if (event.keyCode == 38 || event.keyCode == 33) {\n        // ArrowUp, PageUp\n        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n      } else if (event.keyCode == 40 || event.keyCode == 34) {\n        // ArrowDown, PageDown\n        this.moveSelection((this.selectedIndex + 1) % this.items.length);\n      } else if (event.keyCode == 36) {\n        // Home\n        this.moveSelection(0);\n      } else if (event.keyCode == 35) {\n        // End\n        this.moveSelection(this.items.length - 1);\n      } else if (event.keyCode == 13) {\n        // Enter\n        this.view.focus();\n      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {\n        // A-Z\n        let {\n          diagnostic\n        } = this.items[this.selectedIndex],\n            keys = assignKeys(diagnostic.actions);\n\n        for (let i = 0; i < keys.length; i++) if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n          let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n          if (found) diagnostic.actions[i].apply(view, found.from, found.to);\n        }\n      } else {\n        return;\n      }\n\n      event.preventDefault();\n    };\n\n    let onclick = event => {\n      for (let i = 0; i < this.items.length; i++) {\n        if (this.items[i].dom.contains(event.target)) this.moveSelection(i);\n      }\n    };\n\n    this.list = elt(\"ul\", {\n      tabIndex: 0,\n      role: \"listbox\",\n      \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n      onkeydown,\n      onclick\n    });\n    this.dom = elt(\"div\", {\n      class: \"cm-panel-lint\"\n    }, this.list, elt(\"button\", {\n      type: \"button\",\n      name: \"close\",\n      \"aria-label\": this.view.state.phrase(\"close\"),\n      onclick: () => closeLintPanel(this.view)\n    }, \"Ã—\"));\n    this.update();\n  }\n\n  get selectedIndex() {\n    let selected = this.view.state.field(lintState).selected;\n    if (!selected) return -1;\n\n    for (let i = 0; i < this.items.length; i++) if (this.items[i].diagnostic == selected.diagnostic) return i;\n\n    return -1;\n  }\n\n  update() {\n    let {\n      diagnostics,\n      selected\n    } = this.view.state.field(lintState);\n    let i = 0,\n        needsSync = false,\n        newSelectedItem = null;\n    diagnostics.between(0, this.view.state.doc.length, (_start, _end, _ref3) => {\n      let {\n        spec\n      } = _ref3;\n      let found = -1,\n          item;\n\n      for (let j = i; j < this.items.length; j++) if (this.items[j].diagnostic == spec.diagnostic) {\n        found = j;\n        break;\n      }\n\n      if (found < 0) {\n        item = new PanelItem(this.view, spec.diagnostic);\n        this.items.splice(i, 0, item);\n        needsSync = true;\n      } else {\n        item = this.items[found];\n\n        if (found > i) {\n          this.items.splice(i, found - i);\n          needsSync = true;\n        }\n      }\n\n      if (selected && item.diagnostic == selected.diagnostic) {\n        if (!item.dom.hasAttribute(\"aria-selected\")) {\n          item.dom.setAttribute(\"aria-selected\", \"true\");\n          newSelectedItem = item;\n        }\n      } else if (item.dom.hasAttribute(\"aria-selected\")) {\n        item.dom.removeAttribute(\"aria-selected\");\n      }\n\n      i++;\n    });\n\n    while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {\n      needsSync = true;\n      this.items.pop();\n    }\n\n    if (this.items.length == 0) {\n      this.items.push(new PanelItem(this.view, {\n        from: -1,\n        to: -1,\n        severity: \"info\",\n        message: this.view.state.phrase(\"No diagnostics\")\n      }));\n      needsSync = true;\n    }\n\n    if (newSelectedItem) {\n      this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n      this.view.requestMeasure({\n        key: this,\n        read: () => ({\n          sel: newSelectedItem.dom.getBoundingClientRect(),\n          panel: this.list.getBoundingClientRect()\n        }),\n        write: _ref4 => {\n          let {\n            sel,\n            panel\n          } = _ref4;\n          if (sel.top < panel.top) this.list.scrollTop -= panel.top - sel.top;else if (sel.bottom > panel.bottom) this.list.scrollTop += sel.bottom - panel.bottom;\n        }\n      });\n    } else if (this.selectedIndex < 0) {\n      this.list.removeAttribute(\"aria-activedescendant\");\n    }\n\n    if (needsSync) this.sync();\n  }\n\n  sync() {\n    let domPos = this.list.firstChild;\n\n    function rm() {\n      let prev = domPos;\n      domPos = prev.nextSibling;\n      prev.remove();\n    }\n\n    for (let item of this.items) {\n      if (item.dom.parentNode == this.list) {\n        while (domPos != item.dom) rm();\n\n        domPos = item.dom.nextSibling;\n      } else {\n        this.list.insertBefore(item.dom, domPos);\n      }\n    }\n\n    while (domPos) rm();\n  }\n\n  moveSelection(selectedIndex) {\n    if (this.selectedIndex < 0) return;\n    let field = this.view.state.field(lintState);\n    let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n    if (!selection) return;\n    this.view.dispatch({\n      selection: {\n        anchor: selection.from,\n        head: selection.to\n      },\n      scrollIntoView: true,\n      effects: movePanelSelection.of(selection)\n    });\n  }\n\n  static open(view) {\n    return new LintPanel(view);\n  }\n\n}\n\nfunction svg(content) {\n  let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : `viewBox=\"0 0 40 40\"`;\n  return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\n}\n\nfunction underline(color) {\n  return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\n}\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-diagnostic\": {\n    padding: \"3px 6px 3px 8px\",\n    marginLeft: \"-1px\",\n    display: \"block\",\n    whiteSpace: \"pre-wrap\"\n  },\n  \".cm-diagnostic-error\": {\n    borderLeft: \"5px solid #d11\"\n  },\n  \".cm-diagnostic-warning\": {\n    borderLeft: \"5px solid orange\"\n  },\n  \".cm-diagnostic-info\": {\n    borderLeft: \"5px solid #999\"\n  },\n  \".cm-diagnosticAction\": {\n    font: \"inherit\",\n    border: \"none\",\n    padding: \"2px 4px\",\n    backgroundColor: \"#444\",\n    color: \"white\",\n    borderRadius: \"3px\",\n    marginLeft: \"8px\"\n  },\n  \".cm-diagnosticSource\": {\n    fontSize: \"70%\",\n    opacity: .7\n  },\n  \".cm-lintRange\": {\n    backgroundPosition: \"left bottom\",\n    backgroundRepeat: \"repeat-x\",\n    paddingBottom: \"0.7px\"\n  },\n  \".cm-lintRange-error\": {\n    backgroundImage: /*@__PURE__*/underline(\"#d11\")\n  },\n  \".cm-lintRange-warning\": {\n    backgroundImage: /*@__PURE__*/underline(\"orange\")\n  },\n  \".cm-lintRange-info\": {\n    backgroundImage: /*@__PURE__*/underline(\"#999\")\n  },\n  \".cm-lintRange-active\": {\n    backgroundColor: \"#ffdd9980\"\n  },\n  \".cm-tooltip-lint\": {\n    padding: 0,\n    margin: 0\n  },\n  \".cm-lintPoint\": {\n    position: \"relative\",\n    \"&:after\": {\n      content: '\"\"',\n      position: \"absolute\",\n      bottom: 0,\n      left: \"-2px\",\n      borderLeft: \"3px solid transparent\",\n      borderRight: \"3px solid transparent\",\n      borderBottom: \"4px solid #d11\"\n    }\n  },\n  \".cm-lintPoint-warning\": {\n    \"&:after\": {\n      borderBottomColor: \"orange\"\n    }\n  },\n  \".cm-lintPoint-info\": {\n    \"&:after\": {\n      borderBottomColor: \"#999\"\n    }\n  },\n  \".cm-panel.cm-panel-lint\": {\n    position: \"relative\",\n    \"& ul\": {\n      maxHeight: \"100px\",\n      overflowY: \"auto\",\n      \"& [aria-selected]\": {\n        backgroundColor: \"#ddd\",\n        \"& u\": {\n          textDecoration: \"underline\"\n        }\n      },\n      \"&:focus [aria-selected]\": {\n        background_fallback: \"#bdf\",\n        backgroundColor: \"Highlight\",\n        color_fallback: \"white\",\n        color: \"HighlightText\"\n      },\n      \"& u\": {\n        textDecoration: \"none\"\n      },\n      padding: 0,\n      margin: 0\n    },\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"2px\",\n      background: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    }\n  }\n});\n\nclass LintGutterMarker extends GutterMarker {\n  constructor(diagnostics) {\n    super();\n    this.diagnostics = diagnostics;\n    this.severity = diagnostics.reduce((max, d) => {\n      let s = d.severity;\n      return s == \"error\" || s == \"warning\" && max == \"info\" ? s : max;\n    }, \"info\");\n  }\n\n  toDOM(view) {\n    let elt = document.createElement(\"div\");\n    elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n\n    elt.onmouseover = () => gutterMarkerMouseOver(view, elt, this.diagnostics);\n\n    return elt;\n  }\n\n}\n\nfunction trackHoverOn(view, marker) {\n  let mousemove = event => {\n    let rect = marker.getBoundingClientRect();\n    if (event.clientX > rect.left - 10\n    /* Margin */\n    && event.clientX < rect.right + 10\n    /* Margin */\n    && event.clientY > rect.top - 10\n    /* Margin */\n    && event.clientY < rect.bottom + 10\n    /* Margin */\n    ) return;\n\n    for (let target = event.target; target; target = target.parentNode) {\n      if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\")) return;\n    }\n\n    window.removeEventListener(\"mousemove\", mousemove);\n    if (view.state.field(lintGutterTooltip)) view.dispatch({\n      effects: setLintGutterTooltip.of(null)\n    });\n  };\n\n  window.addEventListener(\"mousemove\", mousemove);\n}\n\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n  function hovered() {\n    let line = view.visualLineAtHeight(marker.getBoundingClientRect().top + 5);\n    const linePos = view.coordsAtPos(line.from),\n          markerRect = marker.getBoundingClientRect();\n\n    if (linePos) {\n      view.dispatch({\n        effects: setLintGutterTooltip.of({\n          pos: line.from,\n          above: false,\n\n          create() {\n            return {\n              dom: diagnosticsTooltip(view, diagnostics),\n              offset: {\n                x: markerRect.left - linePos.left,\n                y: 0\n              }\n            };\n          }\n\n        })\n      });\n    }\n\n    marker.onmouseout = marker.onmousemove = null;\n    trackHoverOn(view, marker);\n  }\n\n  let hoverTimeout = setTimeout(hovered, 600\n  /* Time */\n  );\n\n  marker.onmouseout = () => {\n    clearTimeout(hoverTimeout);\n    marker.onmouseout = marker.onmousemove = null;\n  };\n\n  marker.onmousemove = () => {\n    clearTimeout(hoverTimeout);\n    hoverTimeout = setTimeout(hovered, 600\n    /* Time */\n    );\n  };\n}\n\nfunction markersForDiagnostics(doc, diagnostics) {\n  let byLine = Object.create(null);\n\n  for (let diagnostic of diagnostics) {\n    let line = doc.lineAt(diagnostic.from);\n    (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\n  }\n\n  let markers = [];\n\n  for (let line in byLine) {\n    markers.push(new LintGutterMarker(byLine[line]).range(+line));\n  }\n\n  return RangeSet.of(markers, true);\n}\n\nconst lintGutterExtension = /*@__PURE__*/gutter({\n  class: \"cm-gutter-lint\",\n  markers: view => view.state.field(lintGutterMarkers)\n});\nconst lintGutterMarkers = /*@__PURE__*/StateField.define({\n  create() {\n    return RangeSet.empty;\n  },\n\n  update(markers, tr) {\n    markers = markers.map(tr.changes);\n\n    for (let effect of tr.effects) if (effect.is(setDiagnosticsEffect)) {\n      markers = markersForDiagnostics(tr.state.doc, effect.value);\n    }\n\n    return markers;\n  }\n\n});\nconst setLintGutterTooltip = /*@__PURE__*/StateEffect.define();\nconst lintGutterTooltip = /*@__PURE__*/StateField.define({\n  create() {\n    return null;\n  },\n\n  update(tooltip, tr) {\n    if (tooltip && tr.docChanged) tooltip = Object.assign(Object.assign({}, tooltip), {\n      pos: tr.changes.mapPos(tooltip.pos)\n    });\n    return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);\n  },\n\n  provide: field => showTooltip.from(field)\n});\nconst lintGutterTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-gutter-lint\": {\n    width: \"1.4em\",\n    \"& .cm-gutterElement\": {\n      padding: \"0 .2em\",\n      display: \"flex\",\n      flexDirection: \"column\",\n      justifyContent: \"center\"\n    }\n  },\n  \".cm-lint-marker\": {\n    width: \"1em\",\n    height: \"1em\"\n  },\n  \".cm-lint-marker-info\": {\n    content: /*@__PURE__*/svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\n  },\n  \".cm-lint-marker-warning\": {\n    content: /*@__PURE__*/svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`)\n  },\n  \".cm-lint-marker-error:before\": {\n    content: /*@__PURE__*/svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\n  }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/\n\nfunction lintGutter() {\n  return [lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];\n}\n\nexport { closeLintPanel, diagnosticCount, forceLinting, lintGutter, lintKeymap, linter, nextDiagnostic, openLintPanel, setDiagnostics, setDiagnosticsEffect };","map":null,"metadata":{},"sourceType":"module"}