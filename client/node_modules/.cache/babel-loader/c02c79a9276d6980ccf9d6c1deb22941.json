{"ast":null,"code":"/*\n This is the implementation of the JSON OT type.\n\n Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations\n\n Note: This is being made obsolete. It will soon be replaced by the JSON2 type.\n*/\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Checks if the passed object is an Array instance. Can't use Array.isArray\n * yet because its not supported on IE8.\n *\n * @param obj\n * @returns {boolean}\n */\nvar isArray = function (obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n/**\n * Checks if the passed object is an Object instance.\n * No function call (fast) version\n *\n * @param obj\n * @returns {boolean}\n */\n\n\nvar isObject = function (obj) {\n  return !!obj && obj.constructor === Object;\n};\n/**\n * Clones the passed object using JSON serialization (which is slow).\n *\n * hax, copied from test/types/json. Apparently this is still the fastest way\n * to deep clone an object, assuming we have browser support for JSON.  @see\n * http://jsperf.com/cloning-an-object/12\n */\n\n\nvar clone = function (o) {\n  return JSON.parse(JSON.stringify(o));\n};\n/**\n * JSON OT Type\n * @type {*}\n */\n\n\nvar json = {\n  name: 'json0',\n  uri: 'http://sharejs.org/types/JSONv0'\n}; // You can register another OT type as a subtype in a JSON document using\n// the following function. This allows another type to handle certain\n// operations instead of the builtin JSON type.\n\nvar subtypes = {};\n\njson.registerSubtype = function (subtype) {\n  subtypes[subtype.name] = subtype;\n};\n\njson.create = function (data) {\n  // Null instead of undefined if you don't pass an argument.\n  return data === undefined ? null : clone(data);\n};\n\njson.invertComponent = function (c) {\n  var c_ = {\n    p: c.p\n  }; // handle subtype ops\n\n  if (c.t && subtypes[c.t]) {\n    c_.t = c.t;\n    c_.o = subtypes[c.t].invert(c.o);\n  }\n\n  if (c.si !== void 0) c_.sd = c.si;\n  if (c.sd !== void 0) c_.si = c.sd;\n  if (c.oi !== void 0) c_.od = c.oi;\n  if (c.od !== void 0) c_.oi = c.od;\n  if (c.li !== void 0) c_.ld = c.li;\n  if (c.ld !== void 0) c_.li = c.ld;\n  if (c.na !== void 0) c_.na = -c.na;\n\n  if (c.lm !== void 0) {\n    c_.lm = c.p[c.p.length - 1];\n    c_.p = c.p.slice(0, c.p.length - 1).concat([c.lm]);\n  }\n\n  return c_;\n};\n\njson.invert = function (op) {\n  var op_ = op.slice().reverse();\n  var iop = [];\n\n  for (var i = 0; i < op_.length; i++) {\n    iop.push(json.invertComponent(op_[i]));\n  }\n\n  return iop;\n};\n\njson.checkValidOp = function (op) {\n  for (var i = 0; i < op.length; i++) {\n    if (!isArray(op[i].p)) throw new Error('Missing path');\n  }\n};\n\njson.checkList = function (elem) {\n  if (!isArray(elem)) throw new Error('Referenced element not a list');\n};\n\njson.checkObj = function (elem) {\n  if (!isObject(elem)) {\n    throw new Error(\"Referenced element not an object (it was \" + JSON.stringify(elem) + \")\");\n  }\n}; // helper functions to convert old string ops to and from subtype ops\n\n\nfunction convertFromText(c) {\n  c.t = 'text0';\n  var o = {\n    p: c.p.pop()\n  };\n  if (c.si != null) o.i = c.si;\n  if (c.sd != null) o.d = c.sd;\n  c.o = [o];\n}\n\nfunction convertToText(c) {\n  c.p.push(c.o[0].p);\n  if (c.o[0].i != null) c.si = c.o[0].i;\n  if (c.o[0].d != null) c.sd = c.o[0].d;\n  delete c.t;\n  delete c.o;\n}\n\njson.apply = function (snapshot, op) {\n  json.checkValidOp(op);\n  op = clone(op);\n  var container = {\n    data: snapshot\n  };\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i]; // convert old string ops to use subtype for backwards compatibility\n\n    if (c.si != null || c.sd != null) convertFromText(c);\n    var parent = null;\n    var parentKey = null;\n    var elem = container;\n    var key = 'data';\n\n    for (var j = 0; j < c.p.length; j++) {\n      var p = c.p[j];\n      parent = elem;\n      parentKey = key;\n      elem = elem[key];\n      key = p;\n      if (parent == null) throw new Error('Path invalid');\n    } // handle subtype ops\n\n\n    if (c.t && c.o !== void 0 && subtypes[c.t]) {\n      elem[key] = subtypes[c.t].apply(elem[key], c.o); // Number add\n    } else if (c.na !== void 0) {\n      if (typeof elem[key] != 'number') throw new Error('Referenced element not a number');\n      elem[key] += c.na;\n    } // List replace\n    else if (c.li !== void 0 && c.ld !== void 0) {\n      json.checkList(elem); // Should check the list element matches c.ld\n\n      elem[key] = c.li;\n    } // List insert\n    else if (c.li !== void 0) {\n      json.checkList(elem);\n      elem.splice(key, 0, c.li);\n    } // List delete\n    else if (c.ld !== void 0) {\n      json.checkList(elem); // Should check the list element matches c.ld here too.\n\n      elem.splice(key, 1);\n    } // List move\n    else if (c.lm !== void 0) {\n      json.checkList(elem);\n\n      if (c.lm != key) {\n        var e = elem[key]; // Remove it...\n\n        elem.splice(key, 1); // And insert it back.\n\n        elem.splice(c.lm, 0, e);\n      }\n    } // Object insert / replace\n    else if (c.oi !== void 0) {\n      json.checkObj(elem); // Should check that elem[key] == c.od\n\n      elem[key] = c.oi;\n    } // Object delete\n    else if (c.od !== void 0) {\n      json.checkObj(elem); // Should check that elem[key] == c.od\n\n      delete elem[key];\n    } else {\n      throw new Error('invalid / missing instruction in op');\n    }\n  }\n\n  return container.data;\n}; // Helper to break an operation up into a bunch of small ops.\n\n\njson.shatter = function (op) {\n  var results = [];\n\n  for (var i = 0; i < op.length; i++) {\n    results.push([op[i]]);\n  }\n\n  return results;\n}; // Helper for incrementally applying an operation to a snapshot. Calls yield\n// after each op component has been applied.\n\n\njson.incrementalApply = function (snapshot, op, _yield) {\n  for (var i = 0; i < op.length; i++) {\n    var smallOp = [op[i]];\n    snapshot = json.apply(snapshot, smallOp); // I'd just call this yield, but thats a reserved keyword. Bah!\n\n    _yield(smallOp, snapshot);\n  }\n\n  return snapshot;\n}; // Checks if two paths, p1 and p2 match.\n\n\nvar pathMatches = json.pathMatches = function (p1, p2, ignoreLast) {\n  if (p1.length != p2.length) return false;\n\n  for (var i = 0; i < p1.length; i++) {\n    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1)) return false;\n  }\n\n  return true;\n};\n\njson.append = function (dest, c) {\n  c = clone(c);\n\n  if (dest.length === 0) {\n    dest.push(c);\n    return;\n  }\n\n  var last = dest[dest.length - 1]; // convert old string ops to use subtype for backwards compatibility\n\n  if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n    convertFromText(c);\n    convertFromText(last);\n  }\n\n  if (pathMatches(c.p, last.p)) {\n    // handle subtype ops\n    if (c.t && last.t && c.t === last.t && subtypes[c.t]) {\n      last.o = subtypes[c.t].compose(last.o, c.o); // convert back to old string ops\n\n      if (c.si != null || c.sd != null) {\n        var p = c.p;\n\n        for (var i = 0; i < last.o.length - 1; i++) {\n          c.o = [last.o.pop()];\n          c.p = p.slice();\n          convertToText(c);\n          dest.push(c);\n        }\n\n        convertToText(last);\n      }\n    } else if (last.na != null && c.na != null) {\n      dest[dest.length - 1] = {\n        p: last.p,\n        na: last.na + c.na\n      };\n    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {\n      // insert immediately followed by delete becomes a noop.\n      if (last.ld !== undefined) {\n        // leave the delete part of the replace\n        delete last.li;\n      } else {\n        dest.pop();\n      }\n    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {\n      last.oi = c.oi;\n    } else if (last.oi !== undefined && c.od !== undefined) {\n      // The last path component inserted something that the new component deletes (or replaces).\n      // Just merge them.\n      if (c.oi !== undefined) {\n        last.oi = c.oi;\n      } else if (last.od !== undefined) {\n        delete last.oi;\n      } else {\n        // An insert directly followed by a delete turns into a no-op and can be removed.\n        dest.pop();\n      }\n    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {// don't do anything\n    } else {\n      dest.push(c);\n    }\n  } else {\n    // convert string ops back\n    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n      convertToText(c);\n      convertToText(last);\n    }\n\n    dest.push(c);\n  }\n};\n\njson.compose = function (op1, op2) {\n  json.checkValidOp(op1);\n  json.checkValidOp(op2);\n  var newOp = clone(op1);\n\n  for (var i = 0; i < op2.length; i++) {\n    json.append(newOp, op2[i]);\n  }\n\n  return newOp;\n};\n\njson.normalize = function (op) {\n  var newOp = [];\n  op = isArray(op) ? op : [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = [];\n    json.append(newOp, c);\n  }\n\n  return newOp;\n}; // Returns the common length of the paths of ops a and b\n\n\njson.commonLengthForOps = function (a, b) {\n  var alen = a.p.length;\n  var blen = b.p.length;\n  if (a.na != null || a.t) alen++;\n  if (b.na != null || b.t) blen++;\n  if (alen === 0) return -1;\n  if (blen === 0) return null;\n  alen--;\n  blen--;\n\n  for (var i = 0; i < alen; i++) {\n    var p = a.p[i];\n    if (i >= blen || p !== b.p[i]) return null;\n  }\n\n  return alen;\n}; // Returns true if an op can affect the given path\n\n\njson.canOpAffectPath = function (op, path) {\n  return json.commonLengthForOps({\n    p: path\n  }, op) != null;\n}; // transform c so it applies to a document with otherC applied.\n\n\njson.transformComponent = function (dest, c, otherC, type) {\n  c = clone(c);\n  var common = json.commonLengthForOps(otherC, c);\n  var common2 = json.commonLengthForOps(c, otherC);\n  var cplength = c.p.length;\n  var otherCplength = otherC.p.length;\n  if (c.na != null || c.t) cplength++;\n  if (otherC.na != null || otherC.t) otherCplength++; // if c is deleting something, and that thing is changed by otherC, we need to\n  // update c to reflect that change for invertibility.\n\n  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {\n    if (c.ld !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.ld = json.apply(clone(c.ld), [oc]);\n    } else if (c.od !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.od = json.apply(clone(c.od), [oc]);\n    }\n  }\n\n  if (common != null) {\n    var commonOperand = cplength == otherCplength; // backward compatibility for old string ops\n\n    var oc = otherC;\n\n    if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {\n      convertFromText(c);\n      oc = clone(otherC);\n      convertFromText(oc);\n    } // handle subtype ops\n\n\n    if (oc.t && subtypes[oc.t]) {\n      if (c.t && c.t === oc.t) {\n        var res = subtypes[c.t].transform(c.o, oc.o, type); // convert back to old string ops\n\n        if (c.si != null || c.sd != null) {\n          var p = c.p;\n\n          for (var i = 0; i < res.length; i++) {\n            c.o = [res[i]];\n            c.p = p.slice();\n            convertToText(c);\n            json.append(dest, c);\n          }\n        } else if (!isArray(res) || res.length > 0) {\n          c.o = res;\n          json.append(dest, c);\n        }\n\n        return dest;\n      }\n    } // transform based on otherC\n    else if (otherC.na !== void 0) {// this case is handled below\n    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {\n      if (otherC.p[common] === c.p[common]) {\n        // noop\n        if (!commonOperand) {\n          return dest;\n        } else if (c.ld !== void 0) {\n          // we're trying to delete the same element, -> noop\n          if (c.li !== void 0 && type === 'left') {\n            // we're both replacing one element with another. only one can survive\n            c.ld = clone(otherC.li);\n          } else {\n            return dest;\n          }\n        }\n      }\n    } else if (otherC.li !== void 0) {\n      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {\n        // in li vs. li, left wins.\n        if (type === 'right') c.p[common]++;\n      } else if (otherC.p[common] <= c.p[common]) {\n        c.p[common]++;\n      }\n\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          // otherC edits the same list we edit\n          if (otherC.p[common] <= c.lm) c.lm++; // changing c.from is handled above.\n        }\n      }\n    } else if (otherC.ld !== void 0) {\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          if (otherC.p[common] === c.p[common]) {\n            // they deleted the thing we're trying to move\n            return dest;\n          } // otherC edits the same list we edit\n\n\n          var p = otherC.p[common];\n          var from = c.p[common];\n          var to = c.lm;\n          if (p < to || p === to && from < to) c.lm--;\n        }\n      }\n\n      if (otherC.p[common] < c.p[common]) {\n        c.p[common]--;\n      } else if (otherC.p[common] === c.p[common]) {\n        if (otherCplength < cplength) {\n          // we're below the deleted element, so -> noop\n          return dest;\n        } else if (c.ld !== void 0) {\n          if (c.li !== void 0) {\n            // we're replacing, they're deleting. we become an insert.\n            delete c.ld;\n          } else {\n            // we're trying to delete the same element, -> noop\n            return dest;\n          }\n        }\n      }\n    } else if (otherC.lm !== void 0) {\n      if (c.lm !== void 0 && cplength === otherCplength) {\n        // lm vs lm, here we go!\n        var from = c.p[common];\n        var to = c.lm;\n        var otherFrom = otherC.p[common];\n        var otherTo = otherC.lm;\n\n        if (otherFrom !== otherTo) {\n          // if otherFrom == otherTo, we don't need to change our op.\n          // where did my thing go?\n          if (from === otherFrom) {\n            // they moved it! tie break.\n            if (type === 'left') {\n              c.p[common] = otherTo;\n              if (from === to) // ugh\n                c.lm = otherTo;\n            } else {\n              return dest;\n            }\n          } else {\n            // they moved around it\n            if (from > otherFrom) c.p[common]--;\n            if (from > otherTo) c.p[common]++;else if (from === otherTo) {\n              if (otherFrom > otherTo) {\n                c.p[common]++;\n                if (from === to) // ugh, again\n                  c.lm++;\n              }\n            } // step 2: where am i going to put it?\n\n            if (to > otherFrom) {\n              c.lm--;\n            } else if (to === otherFrom) {\n              if (to > from) c.lm--;\n            }\n\n            if (to > otherTo) {\n              c.lm++;\n            } else if (to === otherTo) {\n              // if we're both moving in the same direction, tie break\n              if (otherTo > otherFrom && to > from || otherTo < otherFrom && to < from) {\n                if (type === 'right') c.lm++;\n              } else {\n                if (to > from) c.lm++;else if (to === otherFrom) c.lm--;\n              }\n            }\n          }\n        }\n      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {\n        // li\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p > from) c.p[common]--;\n        if (p > to) c.p[common]++;\n      } else {\n        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath\n        // the lm\n        //\n        // i.e. things care about where their item is after the move.\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n\n        if (p === from) {\n          c.p[common] = to;\n        } else {\n          if (p > from) c.p[common]--;\n          if (p > to) c.p[common]++;else if (p === to && from > to) c.p[common]++;\n        }\n      }\n    } else if (otherC.oi !== void 0 && otherC.od !== void 0) {\n      if (c.p[common] === otherC.p[common]) {\n        if (c.oi !== void 0 && commonOperand) {\n          // we inserted where someone else replaced\n          if (type === 'right') {\n            // left wins\n            return dest;\n          } else {\n            // we win, make our op replace what they inserted\n            c.od = otherC.oi;\n          }\n        } else {\n          // -> noop if the other component is deleting the same object (or any parent)\n          return dest;\n        }\n      }\n    } else if (otherC.oi !== void 0) {\n      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {\n        // left wins if we try to insert at the same place\n        if (type === 'left') {\n          json.append(dest, {\n            p: c.p,\n            od: otherC.oi\n          });\n        } else {\n          return dest;\n        }\n      }\n    } else if (otherC.od !== void 0) {\n      if (c.p[common] == otherC.p[common]) {\n        if (!commonOperand) return dest;\n\n        if (c.oi !== void 0) {\n          delete c.od;\n        } else {\n          return dest;\n        }\n      }\n    }\n  }\n\n  json.append(dest, c);\n  return dest;\n};\n\nrequire('./bootstrapTransform')(json, json.transformComponent, json.checkValidOp, json.append);\n/**\n * Register a subtype for string operations, using the text0 type.\n */\n\n\nvar text = require('./text0');\n\njson.registerSubtype(text);\nmodule.exports = json;","map":null,"metadata":{},"sourceType":"script"}