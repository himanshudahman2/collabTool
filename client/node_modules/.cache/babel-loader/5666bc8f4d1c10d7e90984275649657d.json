{"ast":null,"code":"import { Annotation, Facet, combineConfig, StateEffect, StateField, Prec, EditorSelection, Text } from '@codemirror/state';\nimport { Direction, logException, EditorView, ViewPlugin, Decoration, WidgetType, keymap } from '@codemirror/view';\nimport { showTooltip, getTooltip } from '@codemirror/tooltip';\nimport { syntaxTree, indentUnit } from '@codemirror/language';\nimport { codePointAt, codePointSize, fromCodePoint } from '@codemirror/text';\n/**\nAn instance of this is passed to completion source functions.\n*/\n\nclass CompletionContext {\n  /**\n  Create a new completion context. (Mostly useful for testing\n  completion sources‚Äîin the editor, the extension will create\n  these for you.)\n  */\n  constructor(\n  /**\n  The editor state that the completion happens in.\n  */\n  state,\n  /**\n  The position at which the completion is happening.\n  */\n  pos,\n  /**\n  Indicates whether completion was activated explicitly, or\n  implicitly by typing. The usual way to respond to this is to\n  only return completions when either there is part of a\n  completable entity before the cursor, or `explicit` is true.\n  */\n  explicit) {\n    this.state = state;\n    this.pos = pos;\n    this.explicit = explicit;\n    /**\n    @internal\n    */\n\n    this.abortListeners = [];\n  }\n  /**\n  Get the extent, content, and (if there is a token) type of the\n  token before `this.pos`.\n  */\n\n\n  tokenBefore(types) {\n    let token = syntaxTree(this.state).resolveInner(this.pos, -1);\n\n    while (token && types.indexOf(token.name) < 0) token = token.parent;\n\n    return token ? {\n      from: token.from,\n      to: this.pos,\n      text: this.state.sliceDoc(token.from, this.pos),\n      type: token.type\n    } : null;\n  }\n  /**\n  Get the match of the given expression directly before the\n  cursor.\n  */\n\n\n  matchBefore(expr) {\n    let line = this.state.doc.lineAt(this.pos);\n    let start = Math.max(line.from, this.pos - 250);\n    let str = line.text.slice(start - line.from, this.pos - line.from);\n    let found = str.search(ensureAnchor(expr, false));\n    return found < 0 ? null : {\n      from: start + found,\n      to: this.pos,\n      text: str.slice(found)\n    };\n  }\n  /**\n  Yields true when the query has been aborted. Can be useful in\n  asynchronous queries to avoid doing work that will be ignored.\n  */\n\n\n  get aborted() {\n    return this.abortListeners == null;\n  }\n  /**\n  Allows you to register abort handlers, which will be called when\n  the query is\n  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n  */\n\n\n  addEventListener(type, listener) {\n    if (type == \"abort\" && this.abortListeners) this.abortListeners.push(listener);\n  }\n\n}\n\nfunction toSet(chars) {\n  let flat = Object.keys(chars).join(\"\");\n  let words = /\\w/.test(flat);\n  if (words) flat = flat.replace(/\\w/g, \"\");\n  return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\n\nfunction prefixMatch(options) {\n  let first = Object.create(null),\n      rest = Object.create(null);\n\n  for (let {\n    label\n  } of options) {\n    first[label[0]] = true;\n\n    for (let i = 1; i < label.length; i++) rest[label[i]] = true;\n  }\n\n  let source = toSet(first) + toSet(rest) + \"*$\";\n  return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\n\n\nfunction completeFromList(list) {\n  let options = list.map(o => typeof o == \"string\" ? {\n    label: o\n  } : o);\n  let [span, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n  return context => {\n    let token = context.matchBefore(match);\n    return token || context.explicit ? {\n      from: token ? token.from : context.pos,\n      options,\n      span\n    } : null;\n  };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/\n\n\nfunction ifIn(nodes, source) {\n  return context => {\n    for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) if (nodes.indexOf(pos.name) > -1) return source(context);\n\n    return null;\n  };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\n\n\nfunction ifNotIn(nodes, source) {\n  return context => {\n    for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) if (nodes.indexOf(pos.name) > -1) return null;\n\n    return source(context);\n  };\n}\n\nclass Option {\n  constructor(completion, source, match) {\n    this.completion = completion;\n    this.source = source;\n    this.match = match;\n  }\n\n}\n\nfunction cur(state) {\n  return state.selection.main.head;\n} // Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\n\n\nfunction ensureAnchor(expr, start) {\n  var _a;\n\n  let {\n    source\n  } = expr;\n  let addStart = start && source[0] != \"^\",\n      addEnd = source[source.length - 1] != \"$\";\n  if (!addStart && !addEnd) return expr;\n  return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/\n\n\nconst pickedCompletion = /*@__PURE__*/Annotation.define();\n\nfunction applyCompletion(view, option) {\n  let apply = option.completion.apply || option.completion.label;\n  let result = option.source;\n\n  if (typeof apply == \"string\") {\n    view.dispatch({\n      changes: {\n        from: result.from,\n        to: result.to,\n        insert: apply\n      },\n      selection: {\n        anchor: result.from + apply.length\n      },\n      userEvent: \"input.complete\",\n      annotations: pickedCompletion.of(option.completion)\n    });\n  } else {\n    apply(view, option.completion, result.from, result.to);\n  }\n}\n\nconst SourceCache = /*@__PURE__*/new WeakMap();\n\nfunction asSource(source) {\n  if (!Array.isArray(source)) return source;\n  let known = SourceCache.get(source);\n  if (!known) SourceCache.set(source, known = completeFromList(source));\n  return known;\n} // A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\n\n\nclass FuzzyMatcher {\n  constructor(pattern) {\n    this.pattern = pattern;\n    this.chars = [];\n    this.folded = []; // Buffers reused by calls to `match` to track matched character\n    // positions.\n\n    this.any = [];\n    this.precise = [];\n    this.byWord = [];\n\n    for (let p = 0; p < pattern.length;) {\n      let char = codePointAt(pattern, p),\n          size = codePointSize(char);\n      this.chars.push(char);\n      let part = pattern.slice(p, p + size),\n          upper = part.toUpperCase();\n      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n      p += size;\n    }\n\n    this.astral = pattern.length != this.chars.length;\n  } // Matches a given word (completion) against the pattern (input).\n  // Will return null for no match, and otherwise an array that starts\n  // with the match score, followed by any number of `from, to` pairs\n  // indicating the matched parts of `word`.\n  //\n  // The score is a number that is more negative the worse the match\n  // is. See `Penalty` above.\n\n\n  match(word) {\n    if (this.pattern.length == 0) return [0];\n    if (word.length < this.pattern.length) return null;\n    let {\n      chars,\n      folded,\n      any,\n      precise,\n      byWord\n    } = this; // For single-character queries, only match when they occur right\n    // at the start\n\n    if (chars.length == 1) {\n      let first = codePointAt(word, 0);\n      return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200\n      /* CaseFold */\n      , 0, codePointSize(first)] : null;\n    }\n\n    let direct = word.indexOf(this.pattern);\n    if (direct == 0) return [0, 0, this.pattern.length];\n    let len = chars.length,\n        anyTo = 0;\n\n    if (direct < 0) {\n      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n        let next = codePointAt(word, i);\n        if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n        i += codePointSize(next);\n      } // No match, exit immediately\n\n\n      if (anyTo < len) return null;\n    } // This tracks the extent of the precise (non-folded, not\n    // necessarily adjacent) match\n\n\n    let preciseTo = 0; // Tracks whether there is a match that hits only characters that\n    // appear to be starting words. `byWordFolded` is set to true when\n    // a case folded character is encountered in such a match\n\n    let byWordTo = 0,\n        byWordFolded = false; // If we've found a partial adjacent match, these track its state\n\n    let adjacentTo = 0,\n        adjacentStart = -1,\n        adjacentEnd = -1;\n    let hasLower = /[a-z]/.test(word),\n        wordAdjacent = true; // Go over the option's text, scanning for the various kinds of matches\n\n    for (let i = 0, e = Math.min(word.length, 200), prevType = 0\n    /* NonWord */\n    ; i < e && byWordTo < len;) {\n      let next = codePointAt(word, i);\n\n      if (direct < 0) {\n        if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;\n\n        if (adjacentTo < len) {\n          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n            if (adjacentTo == 0) adjacentStart = i;\n            adjacentEnd = i + 1;\n            adjacentTo++;\n          } else {\n            adjacentTo = 0;\n          }\n        }\n      }\n\n      let ch,\n          type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2\n      /* Lower */\n      : next >= 65 && next <= 90 ? 1\n      /* Upper */\n      : 0\n      /* NonWord */\n      : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1\n      /* Upper */\n      : ch != ch.toUpperCase() ? 2\n      /* Lower */\n      : 0\n      /* NonWord */\n      ;\n\n      if (!i || type == 1\n      /* Upper */\n      && hasLower || prevType == 0\n      /* NonWord */\n      && type != 0\n      /* NonWord */\n      ) {\n        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i;else if (byWord.length) wordAdjacent = false;\n      }\n\n      prevType = type;\n      i += codePointSize(next);\n    }\n\n    if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100\n    /* ByWord */\n    + (byWordFolded ? -200\n    /* CaseFold */\n    : 0), byWord, word);\n    if (adjacentTo == len && adjacentStart == 0) return [-200\n    /* CaseFold */\n    - word.length, 0, adjacentEnd];\n    if (direct > -1) return [-700\n    /* NotStart */\n    - word.length, direct, direct + this.pattern.length];\n    if (adjacentTo == len) return [-200\n    /* CaseFold */\n    + -700\n    /* NotStart */\n    - word.length, adjacentStart, adjacentEnd];\n    if (byWordTo == len) return this.result(-100\n    /* ByWord */\n    + (byWordFolded ? -200\n    /* CaseFold */\n    : 0) + -700\n    /* NotStart */\n    + (wordAdjacent ? 0 : -1100\n    /* Gap */\n    ), byWord, word);\n    return chars.length == 2 ? null : this.result((any[0] ? -700\n    /* NotStart */\n    : 0) + -200\n    /* CaseFold */\n    + -1100\n    /* Gap */\n    , any, word);\n  }\n\n  result(score, positions, word) {\n    let result = [score - word.length],\n        i = 1;\n\n    for (let pos of positions) {\n      let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);\n      if (i > 1 && result[i - 1] == pos) result[i - 1] = to;else {\n        result[i++] = pos;\n        result[i++] = to;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nconst completionConfig = /*@__PURE__*/Facet.define({\n  combine(configs) {\n    return combineConfig(configs, {\n      activateOnTyping: true,\n      override: null,\n      maxRenderedOptions: 100,\n      defaultKeymap: true,\n      optionClass: () => \"\",\n      aboveCursor: false,\n      icons: true,\n      addToOptions: []\n    }, {\n      defaultKeymap: (a, b) => a && b,\n      icons: (a, b) => a && b,\n      optionClass: (a, b) => c => joinClass(a(c), b(c)),\n      addToOptions: (a, b) => a.concat(b)\n    });\n  }\n\n});\n\nfunction joinClass(a, b) {\n  return a ? b ? a + \" \" + b : a : b;\n}\n\nfunction optionContent(config) {\n  let content = config.addToOptions.slice();\n  if (config.icons) content.push({\n    render(completion) {\n      let icon = document.createElement(\"div\");\n      icon.classList.add(\"cm-completionIcon\");\n      if (completion.type) icon.classList.add(...completion.type.split(/\\s+/g).map(cls => \"cm-completionIcon-\" + cls));\n      icon.setAttribute(\"aria-hidden\", \"true\");\n      return icon;\n    },\n\n    position: 20\n  });\n  content.push({\n    render(completion, _s, match) {\n      let labelElt = document.createElement(\"span\");\n      labelElt.className = \"cm-completionLabel\";\n      let {\n        label\n      } = completion,\n          off = 0;\n\n      for (let j = 1; j < match.length;) {\n        let from = match[j++],\n            to = match[j++];\n        if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n        let span = labelElt.appendChild(document.createElement(\"span\"));\n        span.appendChild(document.createTextNode(label.slice(from, to)));\n        span.className = \"cm-completionMatchedText\";\n        off = to;\n      }\n\n      if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n      return labelElt;\n    },\n\n    position: 50\n  }, {\n    render(completion) {\n      if (!completion.detail) return null;\n      let detailElt = document.createElement(\"span\");\n      detailElt.className = \"cm-completionDetail\";\n      detailElt.textContent = completion.detail;\n      return detailElt;\n    },\n\n    position: 80\n  });\n  return content.sort((a, b) => a.position - b.position).map(a => a.render);\n}\n\nfunction createInfoDialog(option, view) {\n  let dom = document.createElement(\"div\");\n  dom.className = \"cm-tooltip cm-completionInfo\";\n  let {\n    info\n  } = option.completion;\n\n  if (typeof info == \"string\") {\n    dom.textContent = info;\n  } else {\n    let content = info(option.completion);\n    if (content.then) content.then(node => dom.appendChild(node), e => logException(view.state, e, \"completion info\"));else dom.appendChild(content);\n  }\n\n  return dom;\n}\n\nfunction rangeAroundSelected(total, selected, max) {\n  if (total <= max) return {\n    from: 0,\n    to: total\n  };\n\n  if (selected <= total >> 1) {\n    let off = Math.floor(selected / max);\n    return {\n      from: off * max,\n      to: (off + 1) * max\n    };\n  }\n\n  let off = Math.floor((total - selected) / max);\n  return {\n    from: total - (off + 1) * max,\n    to: total - off * max\n  };\n}\n\nclass CompletionTooltip {\n  constructor(view, stateField) {\n    this.view = view;\n    this.stateField = stateField;\n    this.info = null;\n    this.placeInfo = {\n      read: () => this.measureInfo(),\n      write: pos => this.positionInfo(pos),\n      key: this\n    };\n    let cState = view.state.field(stateField);\n    let {\n      options,\n      selected\n    } = cState.open;\n    let config = view.state.facet(completionConfig);\n    this.optionContent = optionContent(config);\n    this.optionClass = config.optionClass;\n    this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-tooltip-autocomplete\";\n    this.dom.addEventListener(\"mousedown\", e => {\n      for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n        if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n          applyCompletion(view, options[+match[1]]);\n          e.preventDefault();\n          return;\n        }\n      }\n    });\n    this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));\n    this.list.addEventListener(\"scroll\", () => {\n      if (this.info) this.view.requestMeasure(this.placeInfo);\n    });\n  }\n\n  mount() {\n    this.updateSel();\n  }\n\n  update(update) {\n    if (update.state.field(this.stateField) != update.startState.field(this.stateField)) this.updateSel();\n  }\n\n  positioned() {\n    if (this.info) this.view.requestMeasure(this.placeInfo);\n  }\n\n  updateSel() {\n    let cState = this.view.state.field(this.stateField),\n        open = cState.open;\n\n    if (open.selected < this.range.from || open.selected >= this.range.to) {\n      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n      this.list.remove();\n      this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));\n      this.list.addEventListener(\"scroll\", () => {\n        if (this.info) this.view.requestMeasure(this.placeInfo);\n      });\n    }\n\n    if (this.updateSelectedOption(open.selected)) {\n      if (this.info) {\n        this.info.remove();\n        this.info = null;\n      }\n\n      let option = open.options[open.selected];\n\n      if (option.completion.info) {\n        this.info = this.dom.appendChild(createInfoDialog(option, this.view));\n        this.view.requestMeasure(this.placeInfo);\n      }\n    }\n  }\n\n  updateSelectedOption(selected) {\n    let set = null;\n\n    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n      if (i == selected) {\n        if (!opt.hasAttribute(\"aria-selected\")) {\n          opt.setAttribute(\"aria-selected\", \"true\");\n          set = opt;\n        }\n      } else {\n        if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n      }\n    }\n\n    if (set) scrollIntoView(this.list, set);\n    return set;\n  }\n\n  measureInfo() {\n    let sel = this.dom.querySelector(\"[aria-selected]\");\n    if (!sel || !this.info) return null;\n    let listRect = this.dom.getBoundingClientRect();\n    let infoRect = this.info.getBoundingClientRect();\n    let selRect = sel.getBoundingClientRect();\n    if (selRect.top > Math.min(innerHeight, listRect.bottom) - 10 || selRect.bottom < Math.max(0, listRect.top) + 10) return null;\n    let top = Math.max(0, Math.min(selRect.top, innerHeight - infoRect.height)) - listRect.top;\n    let left = this.view.textDirection == Direction.RTL;\n    let spaceLeft = listRect.left,\n        spaceRight = innerWidth - listRect.right;\n    if (left && spaceLeft < Math.min(infoRect.width, spaceRight)) left = false;else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft)) left = true;\n    return {\n      top,\n      left\n    };\n  }\n\n  positionInfo(pos) {\n    if (this.info) {\n      this.info.style.top = (pos ? pos.top : -1e6) + \"px\";\n\n      if (pos) {\n        this.info.classList.toggle(\"cm-completionInfo-left\", pos.left);\n        this.info.classList.toggle(\"cm-completionInfo-right\", !pos.left);\n      }\n    }\n  }\n\n  createListBox(options, id, range) {\n    const ul = document.createElement(\"ul\");\n    ul.id = id;\n    ul.setAttribute(\"role\", \"listbox\");\n\n    for (let i = range.from; i < range.to; i++) {\n      let {\n        completion,\n        match\n      } = options[i];\n      const li = ul.appendChild(document.createElement(\"li\"));\n      li.id = id + \"-\" + i;\n      li.setAttribute(\"role\", \"option\");\n      let cls = this.optionClass(completion);\n      if (cls) li.className = cls;\n\n      for (let source of this.optionContent) {\n        let node = source(completion, this.view.state, match);\n        if (node) li.appendChild(node);\n      }\n    }\n\n    if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n    if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n    return ul;\n  }\n\n} // We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\n\n\nfunction completionTooltip(stateField) {\n  return view => new CompletionTooltip(view, stateField);\n}\n\nfunction scrollIntoView(container, element) {\n  let parent = container.getBoundingClientRect();\n  let self = element.getBoundingClientRect();\n  if (self.top < parent.top) container.scrollTop -= parent.top - self.top;else if (self.bottom > parent.bottom) container.scrollTop += self.bottom - parent.bottom;\n}\n\nconst MaxOptions = 300; // Used to pick a preferred option when two options with the same\n// label occur in the result.\n\nfunction score(option) {\n  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\n\nfunction sortOptions(active, state) {\n  let options = [],\n      i = 0;\n\n  for (let a of active) if (a.hasResult()) {\n    if (a.result.filter === false) {\n      for (let option of a.result.options) options.push(new Option(option, a, [1e9 - i++]));\n    } else {\n      let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)),\n          match;\n\n      for (let option of a.result.options) if (match = matcher.match(option.label)) {\n        if (option.boost != null) match[0] += option.boost;\n        options.push(new Option(option, a, match));\n      }\n    }\n  }\n\n  options.sort(cmpOption);\n  let result = [],\n      prev = null;\n\n  for (let opt of options.sort(cmpOption)) {\n    if (result.length == MaxOptions) break;\n    if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != opt.completion.type || prev.apply != opt.completion.apply) result.push(opt);else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n    prev = opt.completion;\n  }\n\n  return result;\n}\n\nclass CompletionDialog {\n  constructor(options, attrs, tooltip, timestamp, selected) {\n    this.options = options;\n    this.attrs = attrs;\n    this.tooltip = tooltip;\n    this.timestamp = timestamp;\n    this.selected = selected;\n  }\n\n  setSelected(selected, id) {\n    return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);\n  }\n\n  static build(active, state, id, prev, conf) {\n    let options = sortOptions(active, state);\n    if (!options.length) return null;\n    let selected = 0;\n\n    if (prev && prev.selected) {\n      let selectedValue = prev.options[prev.selected].completion;\n\n      for (let i = 0; i < options.length && !selected; i++) {\n        if (options[i].completion == selectedValue) selected = i;\n      }\n    }\n\n    return new CompletionDialog(options, makeAttrs(id, selected), {\n      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n      create: completionTooltip(completionState),\n      above: conf.aboveCursor\n    }, prev ? prev.timestamp : Date.now(), selected);\n  }\n\n  map(changes) {\n    return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n      pos: changes.mapPos(this.tooltip.pos)\n    }), this.timestamp, this.selected);\n  }\n\n}\n\nclass CompletionState {\n  constructor(active, id, open) {\n    this.active = active;\n    this.id = id;\n    this.open = open;\n  }\n\n  static start() {\n    return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n  }\n\n  update(tr) {\n    let {\n      state\n    } = tr,\n        conf = state.facet(completionConfig);\n    let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n    let active = sources.map(source => {\n      let value = this.active.find(s => s.source == source) || new ActiveSource(source, this.active.some(a => a.state != 0\n      /* Inactive */\n      ) ? 1\n      /* Pending */\n      : 0\n      /* Inactive */\n      );\n      return value.update(tr, conf);\n    });\n    if (active.length == this.active.length && active.every((a, i) => a == this.active[i])) active = this.active;\n    let open = tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open, conf) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;\n    if (!open && active.every(a => a.state != 1\n    /* Pending */\n    ) && active.some(a => a.hasResult())) active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0\n    /* Inactive */\n    ) : a);\n\n    for (let effect of tr.effects) if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n\n    return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n  }\n\n  get tooltip() {\n    return this.open ? this.open.tooltip : null;\n  }\n\n  get attrs() {\n    return this.open ? this.open.attrs : baseAttrs;\n  }\n\n}\n\nfunction sameResults(a, b) {\n  if (a == b) return true;\n\n  for (let iA = 0, iB = 0;;) {\n    while (iA < a.length && !a[iA].hasResult) iA++;\n\n    while (iB < b.length && !b[iB].hasResult) iB++;\n\n    let endA = iA == a.length,\n        endB = iB == b.length;\n    if (endA || endB) return endA == endB;\n    if (a[iA++].result != b[iB++].result) return false;\n  }\n}\n\nconst baseAttrs = {\n  \"aria-autocomplete\": \"list\",\n  \"aria-expanded\": \"false\"\n};\n\nfunction makeAttrs(id, selected) {\n  return {\n    \"aria-autocomplete\": \"list\",\n    \"aria-expanded\": \"true\",\n    \"aria-activedescendant\": id + \"-\" + selected,\n    \"aria-controls\": id\n  };\n}\n\nconst none = [];\n\nfunction cmpOption(a, b) {\n  let dScore = b.match[0] - a.match[0];\n  if (dScore) return dScore;\n  return a.completion.label.localeCompare(b.completion.label);\n}\n\nfunction getUserEvent(tr) {\n  return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\n\nclass ActiveSource {\n  constructor(source, state) {\n    let explicitPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    this.source = source;\n    this.state = state;\n    this.explicitPos = explicitPos;\n  }\n\n  hasResult() {\n    return false;\n  }\n\n  update(tr, conf) {\n    let event = getUserEvent(tr),\n        value = this;\n    if (event) value = value.handleUserEvent(tr, event, conf);else if (tr.docChanged) value = value.handleChange(tr);else if (tr.selection && value.state != 0\n    /* Inactive */\n    ) value = new ActiveSource(value.source, 0\n    /* Inactive */\n    );\n\n    for (let effect of tr.effects) {\n      if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1\n      /* Pending */\n      , effect.value ? cur(tr.state) : -1);else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0\n      /* Inactive */\n      );else if (effect.is(setActiveEffect)) for (let active of effect.value) if (active.source == value.source) value = active;\n    }\n\n    return value;\n  }\n\n  handleUserEvent(tr, type, conf) {\n    return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1\n    /* Pending */\n    );\n  }\n\n  handleChange(tr) {\n    return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0\n    /* Inactive */\n    ) : this.map(tr.changes);\n  }\n\n  map(changes) {\n    return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n  }\n\n}\n\nclass ActiveResult extends ActiveSource {\n  constructor(source, explicitPos, result, from, to, span) {\n    super(source, 2\n    /* Result */\n    , explicitPos);\n    this.result = result;\n    this.from = from;\n    this.to = to;\n    this.span = span;\n  }\n\n  hasResult() {\n    return true;\n  }\n\n  handleUserEvent(tr, type, conf) {\n    let from = tr.changes.mapPos(this.from),\n        to = tr.changes.mapPos(this.to, 1);\n    let pos = cur(tr.state);\n    if ((this.explicitPos > -1 ? pos < from : pos <= from) || pos > to) return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1\n    /* Pending */\n    : 0\n    /* Inactive */\n    );\n    let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);\n    if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to)))) return new ActiveResult(this.source, explicitPos, this.result, from, to, this.span);\n    return new ActiveSource(this.source, 1\n    /* Pending */\n    , explicitPos);\n  }\n\n  handleChange(tr) {\n    return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0\n    /* Inactive */\n    ) : this.map(tr.changes);\n  }\n\n  map(mapping) {\n    return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);\n  }\n\n}\n\nconst startCompletionEffect = /*@__PURE__*/StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/StateEffect.define();\nconst setActiveEffect = /*@__PURE__*/StateEffect.define({\n  map(sources, mapping) {\n    return sources.map(s => s.map(mapping));\n  }\n\n});\nconst setSelectedEffect = /*@__PURE__*/StateEffect.define();\nconst completionState = /*@__PURE__*/StateField.define({\n  create() {\n    return CompletionState.start();\n  },\n\n  update(value, tr) {\n    return value.update(tr);\n  },\n\n  provide: f => [showTooltip.from(f, val => val.tooltip), EditorView.contentAttributes.from(f, state => state.attrs)]\n});\nconst CompletionInteractMargin = 75;\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\n\nfunction moveCompletionSelection(forward) {\n  let by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"option\";\n  return view => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;\n    let step = 1,\n        tooltip;\n    if (by == \"page\" && (tooltip = getTooltip(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n    let selected = cState.open.selected + step * (forward ? 1 : -1),\n        {\n      length\n    } = cState.open.options;\n    if (selected < 0) selected = by == \"page\" ? 0 : length - 1;else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n    view.dispatch({\n      effects: setSelectedEffect.of(selected)\n    });\n    return true;\n  };\n}\n/**\nAccept the current completion.\n*/\n\n\nconst acceptCompletion = view => {\n  let cState = view.state.field(completionState, false);\n  if (view.state.readOnly || !cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin) return false;\n  applyCompletion(view, cState.open.options[cState.open.selected]);\n  return true;\n};\n/**\nExplicitly start autocompletion.\n*/\n\n\nconst startCompletion = view => {\n  let cState = view.state.field(completionState, false);\n  if (!cState) return false;\n  view.dispatch({\n    effects: startCompletionEffect.of(true)\n  });\n  return true;\n};\n/**\nClose the currently active completion.\n*/\n\n\nconst closeCompletion = view => {\n  let cState = view.state.field(completionState, false);\n  if (!cState || !cState.active.some(a => a.state != 0\n  /* Inactive */\n  )) return false;\n  view.dispatch({\n    effects: closeCompletionEffect.of(null)\n  });\n  return true;\n};\n\nclass RunningQuery {\n  constructor(active, context) {\n    this.active = active;\n    this.context = context;\n    this.time = Date.now();\n    this.updates = []; // Note that 'undefined' means 'not done yet', whereas 'null' means\n    // 'query returned null'.\n\n    this.done = undefined;\n  }\n\n}\n\nconst DebounceTime = 50,\n      MaxUpdateCount = 50,\n      MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.debounceUpdate = -1;\n    this.running = [];\n    this.debounceAccept = -1;\n    this.composing = 0\n    /* None */\n    ;\n\n    for (let active of view.state.field(completionState).active) if (active.state == 1\n    /* Pending */\n    ) this.startQuery(active);\n  }\n\n  update(update) {\n    let cState = update.state.field(completionState);\n    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;\n    let doesReset = update.transactions.some(tr => {\n      return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n    });\n\n    for (let i = 0; i < this.running.length; i++) {\n      let query = this.running[i];\n\n      if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {\n        for (let handler of query.context.abortListeners) {\n          try {\n            handler();\n          } catch (e) {\n            logException(this.view.state, e);\n          }\n        }\n\n        query.context.abortListeners = null;\n        this.running.splice(i--, 1);\n      } else {\n        query.updates.push(...update.transactions);\n      }\n    }\n\n    if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n    this.debounceUpdate = cState.active.some(a => a.state == 1\n    /* Pending */\n    && !this.running.some(q => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\n    if (this.composing != 0\n    /* None */\n    ) for (let tr of update.transactions) {\n      if (getUserEvent(tr) == \"input\") this.composing = 2\n      /* Changed */\n      ;else if (this.composing == 2\n      /* Changed */\n      && tr.selection) this.composing = 3\n      /* ChangedAndMoved */\n      ;\n    }\n  }\n\n  startUpdate() {\n    this.debounceUpdate = -1;\n    let {\n      state\n    } = this.view,\n        cState = state.field(completionState);\n\n    for (let active of cState.active) {\n      if (active.state == 1\n      /* Pending */\n      && !this.running.some(r => r.active.source == active.source)) this.startQuery(active);\n    }\n  }\n\n  startQuery(active) {\n    let {\n      state\n    } = this.view,\n        pos = cur(state);\n    let context = new CompletionContext(state, pos, active.explicitPos == pos);\n    let pending = new RunningQuery(active, context);\n    this.running.push(pending);\n    Promise.resolve(active.source(context)).then(result => {\n      if (!pending.context.aborted) {\n        pending.done = result || null;\n        this.scheduleAccept();\n      }\n    }, err => {\n      this.view.dispatch({\n        effects: closeCompletionEffect.of(null)\n      });\n      logException(this.view.state, err);\n    });\n  }\n\n  scheduleAccept() {\n    if (this.running.every(q => q.done !== undefined)) this.accept();else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\n  } // For each finished query in this.running, try to create a result\n  // or, if appropriate, restart the query.\n\n\n  accept() {\n    var _a;\n\n    if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n    this.debounceAccept = -1;\n    let updated = [];\n    let conf = this.view.state.facet(completionConfig);\n\n    for (let i = 0; i < this.running.length; i++) {\n      let query = this.running[i];\n      if (query.done === undefined) continue;\n      this.running.splice(i--, 1);\n\n      if (query.done) {\n        let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span && query.done.filter !== false ? ensureAnchor(query.done.span, true) : null); // Replay the transactions that happened since the start of\n        // the request and see if that preserves the result\n\n        for (let tr of query.updates) active = active.update(tr, conf);\n\n        if (active.hasResult()) {\n          updated.push(active);\n          continue;\n        }\n      }\n\n      let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);\n\n      if (current && current.state == 1\n      /* Pending */\n      ) {\n        if (query.done == null) {\n          // Explicitly failed. Should clear the pending status if it\n          // hasn't been re-set in the meantime.\n          let active = new ActiveSource(query.active.source, 0\n          /* Inactive */\n          );\n\n          for (let tr of query.updates) active = active.update(tr, conf);\n\n          if (active.state != 1\n          /* Pending */\n          ) updated.push(active);\n        } else {\n          // Cleared by subsequent transactions. Restart.\n          this.startQuery(current);\n        }\n      }\n    }\n\n    if (updated.length) this.view.dispatch({\n      effects: setActiveEffect.of(updated)\n    });\n  }\n\n}, {\n  eventHandlers: {\n    compositionstart() {\n      this.composing = 1\n      /* Started */\n      ;\n    },\n\n    compositionend() {\n      if (this.composing == 3\n      /* ChangedAndMoved */\n      ) {\n        // Safari fires compositionend events synchronously, possibly\n        // from inside an update, so dispatch asynchronously to avoid reentrancy\n        setTimeout(() => this.view.dispatch({\n          effects: startCompletionEffect.of(false)\n        }), 20);\n      }\n\n      this.composing = 0\n      /* None */\n      ;\n    }\n\n  }\n});\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-tooltip.cm-tooltip-autocomplete\": {\n    \"& > ul\": {\n      fontFamily: \"monospace\",\n      whiteSpace: \"nowrap\",\n      overflow: \"hidden auto\",\n      maxWidth_fallback: \"700px\",\n      maxWidth: \"min(700px, 95vw)\",\n      minWidth: \"250px\",\n      maxHeight: \"10em\",\n      listStyle: \"none\",\n      margin: 0,\n      padding: 0,\n      \"& > li\": {\n        overflowX: \"hidden\",\n        textOverflow: \"ellipsis\",\n        cursor: \"pointer\",\n        padding: \"1px 3px\",\n        lineHeight: 1.2\n      }\n    }\n  },\n  \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#17c\",\n    color: \"white\"\n  },\n  \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#347\",\n    color: \"white\"\n  },\n  \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n    content: '\"¬∑¬∑¬∑\"',\n    opacity: 0.5,\n    display: \"block\",\n    textAlign: \"center\"\n  },\n  \".cm-tooltip.cm-completionInfo\": {\n    position: \"absolute\",\n    padding: \"3px 9px\",\n    width: \"max-content\",\n    maxWidth: \"300px\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left\": {\n    right: \"100%\"\n  },\n  \".cm-completionInfo.cm-completionInfo-right\": {\n    left: \"100%\"\n  },\n  \"&light .cm-snippetField\": {\n    backgroundColor: \"#00000022\"\n  },\n  \"&dark .cm-snippetField\": {\n    backgroundColor: \"#ffffff22\"\n  },\n  \".cm-snippetFieldPosition\": {\n    verticalAlign: \"text-top\",\n    width: 0,\n    height: \"1.15em\",\n    margin: \"0 -0.7px -.7em\",\n    borderLeft: \"1.4px dotted #888\"\n  },\n  \".cm-completionMatchedText\": {\n    textDecoration: \"underline\"\n  },\n  \".cm-completionDetail\": {\n    marginLeft: \"0.5em\",\n    fontStyle: \"italic\"\n  },\n  \".cm-completionIcon\": {\n    fontSize: \"90%\",\n    width: \".8em\",\n    display: \"inline-block\",\n    textAlign: \"center\",\n    paddingRight: \".6em\",\n    opacity: \"0.6\"\n  },\n  \".cm-completionIcon-function, .cm-completionIcon-method\": {\n    \"&:after\": {\n      content: \"'∆í'\"\n    }\n  },\n  \".cm-completionIcon-class\": {\n    \"&:after\": {\n      content: \"'‚óã'\"\n    }\n  },\n  \".cm-completionIcon-interface\": {\n    \"&:after\": {\n      content: \"'‚óå'\"\n    }\n  },\n  \".cm-completionIcon-variable\": {\n    \"&:after\": {\n      content: \"'ùë•'\"\n    }\n  },\n  \".cm-completionIcon-constant\": {\n    \"&:after\": {\n      content: \"'ùê∂'\"\n    }\n  },\n  \".cm-completionIcon-type\": {\n    \"&:after\": {\n      content: \"'ùë°'\"\n    }\n  },\n  \".cm-completionIcon-enum\": {\n    \"&:after\": {\n      content: \"'‚à™'\"\n    }\n  },\n  \".cm-completionIcon-property\": {\n    \"&:after\": {\n      content: \"'‚ñ°'\"\n    }\n  },\n  \".cm-completionIcon-keyword\": {\n    \"&:after\": {\n      content: \"'üîë\\uFE0E'\"\n    } // Disable emoji rendering\n\n  },\n  \".cm-completionIcon-namespace\": {\n    \"&:after\": {\n      content: \"'‚ñ¢'\"\n    }\n  },\n  \".cm-completionIcon-text\": {\n    \"&:after\": {\n      content: \"'abc'\",\n      fontSize: \"50%\",\n      verticalAlign: \"middle\"\n    }\n  }\n});\n\nclass FieldPos {\n  constructor(field, line, from, to) {\n    this.field = field;\n    this.line = line;\n    this.from = from;\n    this.to = to;\n  }\n\n}\n\nclass FieldRange {\n  constructor(field, from, to) {\n    this.field = field;\n    this.from = from;\n    this.to = to;\n  }\n\n  map(changes) {\n    return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));\n  }\n\n}\n\nclass Snippet {\n  constructor(lines, fieldPositions) {\n    this.lines = lines;\n    this.fieldPositions = fieldPositions;\n  }\n\n  instantiate(state, pos) {\n    let text = [],\n        lineStart = [pos];\n    let lineObj = state.doc.lineAt(pos),\n        baseIndent = /^\\s*/.exec(lineObj.text)[0];\n\n    for (let line of this.lines) {\n      if (text.length) {\n        let indent = baseIndent,\n            tabs = /^\\t*/.exec(line)[0].length;\n\n        for (let i = 0; i < tabs; i++) indent += state.facet(indentUnit);\n\n        lineStart.push(pos + indent.length - tabs);\n        line = indent + line.slice(tabs);\n      }\n\n      text.push(line);\n      pos += line.length + 1;\n    }\n\n    let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n    return {\n      text,\n      ranges\n    };\n  }\n\n  static parse(template) {\n    let fields = [];\n    let lines = [],\n        positions = [],\n        m;\n\n    for (let line of template.split(/\\r\\n?|\\n/)) {\n      while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n        let seq = m[1] ? +m[1] : null,\n            name = m[2] || m[3] || \"\",\n            found = -1;\n\n        for (let i = 0; i < fields.length; i++) {\n          if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;\n        }\n\n        if (found < 0) {\n          let i = 0;\n\n          while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq)) i++;\n\n          fields.splice(i, 0, {\n            seq,\n            name\n          });\n          found = i;\n\n          for (let pos of positions) if (pos.field >= found) pos.field++;\n        }\n\n        positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n        line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n      }\n\n      lines.push(line);\n    }\n\n    return new Snippet(lines, positions);\n  }\n\n}\n\nlet fieldMarker = /*@__PURE__*/Decoration.widget({\n  widget: /*@__PURE__*/new class extends WidgetType {\n    toDOM() {\n      let span = document.createElement(\"span\");\n      span.className = \"cm-snippetFieldPosition\";\n      return span;\n    }\n\n    ignoreEvent() {\n      return false;\n    }\n\n  }()\n});\nlet fieldRange = /*@__PURE__*/Decoration.mark({\n  class: \"cm-snippetField\"\n});\n\nclass ActiveSnippet {\n  constructor(ranges, active) {\n    this.ranges = ranges;\n    this.active = active;\n    this.deco = Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n  }\n\n  map(changes) {\n    return new ActiveSnippet(this.ranges.map(r => r.map(changes)), this.active);\n  }\n\n  selectionInsideField(sel) {\n    return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n  }\n\n}\n\nconst setActive = /*@__PURE__*/StateEffect.define({\n  map(value, changes) {\n    return value && value.map(changes);\n  }\n\n});\nconst moveToField = /*@__PURE__*/StateEffect.define();\nconst snippetState = /*@__PURE__*/StateField.define({\n  create() {\n    return null;\n  },\n\n  update(value, tr) {\n    for (let effect of tr.effects) {\n      if (effect.is(setActive)) return effect.value;\n      if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n    }\n\n    if (value && tr.docChanged) value = value.map(tr.changes);\n    if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n    return value;\n  },\n\n  provide: f => EditorView.decorations.from(f, val => val ? val.deco : Decoration.none)\n});\n\nfunction fieldSelection(ranges, field) {\n  return EditorSelection.create(ranges.filter(r => r.field == field).map(r => EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can apply it.\nSnippets are written using syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n*/\n\n\nfunction snippet(template) {\n  let snippet = Snippet.parse(template);\n  return (editor, _completion, from, to) => {\n    let {\n      text,\n      ranges\n    } = snippet.instantiate(editor.state, from);\n    let spec = {\n      changes: {\n        from,\n        to,\n        insert: Text.of(text)\n      }\n    };\n    if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n\n    if (ranges.length > 1) {\n      let active = new ActiveSnippet(ranges, 0);\n      let effects = spec.effects = [setActive.of(active)];\n      if (editor.state.field(snippetState, false) === undefined) effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\n    }\n\n    editor.dispatch(editor.state.update(spec));\n  };\n}\n\nfunction moveField(dir) {\n  return _ref => {\n    let {\n      state,\n      dispatch\n    } = _ref;\n    let active = state.field(snippetState, false);\n    if (!active || dir < 0 && active.active == 0) return false;\n    let next = active.active + dir,\n        last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n    dispatch(state.update({\n      selection: fieldSelection(active.ranges, next),\n      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n    }));\n    return true;\n  };\n}\n/**\nA command that clears the active snippet, if any.\n*/\n\n\nconst clearSnippet = _ref2 => {\n  let {\n    state,\n    dispatch\n  } = _ref2;\n  let active = state.field(snippetState, false);\n  if (!active) return false;\n  dispatch(state.update({\n    effects: setActive.of(null)\n  }));\n  return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\n\n\nconst nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\n\nconst prevSnippetField = /*@__PURE__*/moveField(-1);\nconst defaultSnippetKeymap = [{\n  key: \"Tab\",\n  run: nextSnippetField,\n  shift: prevSnippetField\n}, {\n  key: \"Escape\",\n  run: clearSnippet\n}];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\n\nconst snippetKeymap = /*@__PURE__*/Facet.define({\n  combine(maps) {\n    return maps.length ? maps[0] : defaultSnippetKeymap;\n  }\n\n});\nconst addSnippetKeymap = /*@__PURE__*/Prec.highest( /*@__PURE__*/keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\n\nfunction snippetCompletion(template, completion) {\n  return Object.assign(Object.assign({}, completion), {\n    apply: snippet(template)\n  });\n}\n\nconst snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({\n  mousedown(event, view) {\n    let active = view.state.field(snippetState, false),\n        pos;\n    if (!active || (pos = view.posAtCoords({\n      x: event.clientX,\n      y: event.clientY\n    })) == null) return false;\n    let match = active.ranges.find(r => r.from <= pos && r.to >= pos);\n    if (!match || match.field == active.active) return false;\n    view.dispatch({\n      selection: fieldSelection(active.ranges, match.field),\n      effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)\n    });\n    return true;\n  }\n\n});\n\nfunction wordRE(wordChars) {\n  let escaped = wordChars.replace(/[\\\\[.+*?(){|^$]/g, \"\\\\$&\");\n\n  try {\n    return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n  } catch (_a) {\n    return new RegExp(`[\\w${escaped}]`, \"g\");\n  }\n}\n\nfunction mapRE(re, f) {\n  return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\n\nconst wordCaches = /*@__PURE__*/Object.create(null);\n\nfunction wordCache(wordChars) {\n  return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap());\n}\n\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n  for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {\n    let {\n      value\n    } = lines,\n        m;\n    wordRE.lastIndex = 0;\n\n    while (m = wordRE.exec(value)) {\n      if (!seen[m[0]] && pos + m.index != ignoreAt) {\n        result.push({\n          type: \"text\",\n          label: m[0]\n        });\n        seen[m[0]] = true;\n        if (result.length >= 2000\n        /* MaxList */\n        ) return;\n      }\n    }\n\n    pos += value.length + 1;\n  }\n}\n\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n  let big = doc.length >= 1000\n  /* MinCacheLen */\n  ;\n  let cached = big && cache.get(doc);\n  if (cached) return cached;\n  let result = [],\n      seen = Object.create(null);\n\n  if (doc.children) {\n    let pos = 0;\n\n    for (let ch of doc.children) {\n      if (ch.length >= 1000\n      /* MinCacheLen */\n      ) {\n        for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {\n          if (!seen[c.label]) {\n            seen[c.label] = true;\n            result.push(c);\n          }\n        }\n      } else {\n        storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n      }\n\n      pos += ch.length + 1;\n    }\n  } else {\n    storeWords(doc, wordRE, result, seen, ignoreAt);\n  }\n\n  if (big && result.length < 2000\n  /* MaxList */\n  ) cache.set(doc, result);\n  return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\n\n\nconst completeAnyWord = context => {\n  let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n  let re = wordRE(wordChars);\n  let token = context.matchBefore(mapRE(re, s => s + \"$\"));\n  if (!token && !context.explicit) return null;\n  let from = token ? token.from : context.pos;\n  let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000\n  /* Range */\n  , from);\n  return {\n    from,\n    options,\n    span: mapRE(re, s => \"^\" + s)\n  };\n};\n/**\nReturns an extension that enables autocompletion.\n*/\n\n\nfunction autocompletion() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\n\n\nconst completionKeymap = [{\n  key: \"Ctrl-Space\",\n  run: startCompletion\n}, {\n  key: \"Escape\",\n  run: closeCompletion\n}, {\n  key: \"ArrowDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true)\n}, {\n  key: \"ArrowUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false)\n}, {\n  key: \"PageDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true, \"page\")\n}, {\n  key: \"PageUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false, \"page\")\n}, {\n  key: \"Enter\",\n  run: acceptCompletion\n}];\nconst completionKeymapExt = /*@__PURE__*/Prec.highest( /*@__PURE__*/keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\n\nfunction completionStatus(state) {\n  let cState = state.field(completionState, false);\n  return cState && cState.active.some(a => a.state == 1\n  /* Pending */\n  ) ? \"pending\" : cState && cState.active.some(a => a.state != 0\n  /* Inactive */\n  ) ? \"active\" : null;\n}\n/**\nReturns the available completions as an array.\n*/\n\n\nfunction currentCompletions(state) {\n  var _a;\n\n  let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open ? open.options.map(o => o.completion) : [];\n}\n/**\nReturn the currently selected completion, if any.\n*/\n\n\nfunction selectedCompletion(state) {\n  var _a;\n\n  let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open ? open.options[open.selected].completion : null;\n}\n\nexport { CompletionContext, acceptCompletion, autocompletion, clearSnippet, closeCompletion, completeAnyWord, completeFromList, completionKeymap, completionStatus, currentCompletions, ifIn, ifNotIn, moveCompletionSelection, nextSnippetField, pickedCompletion, prevSnippetField, selectedCompletion, snippet, snippetCompletion, snippetKeymap, startCompletion };","map":null,"metadata":{},"sourceType":"module"}