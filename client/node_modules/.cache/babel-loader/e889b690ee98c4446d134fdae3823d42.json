{"ast":null,"code":"import { ViewPlugin, PluginField, EditorView } from '@codemirror/view';\nimport { Facet } from '@codemirror/state';\nconst panelConfig = /*@__PURE__*/Facet.define({\n  combine(configs) {\n    let topContainer, bottomContainer;\n\n    for (let c of configs) {\n      topContainer = topContainer || c.topContainer;\n      bottomContainer = bottomContainer || c.bottomContainer;\n    }\n\n    return {\n      topContainer,\n      bottomContainer\n    };\n  }\n\n});\n/**\nConfigures the panel-managing extension.\n*/\n\nfunction panels(config) {\n  return config ? [panelConfig.of(config)] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/\n\n\nfunction getPanel(view, panel) {\n  let plugin = view.plugin(panelPlugin);\n  let index = plugin ? plugin.specs.indexOf(panel) : -1;\n  return index > -1 ? plugin.panels[index] : null;\n}\n\nconst panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.input = view.state.facet(showPanel);\n    this.specs = this.input.filter(s => s);\n    this.panels = this.specs.map(spec => spec(view));\n    let conf = view.state.facet(panelConfig);\n    this.top = new PanelGroup(view, true, conf.topContainer);\n    this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n    this.top.sync(this.panels.filter(p => p.top));\n    this.bottom.sync(this.panels.filter(p => !p.top));\n\n    for (let p of this.panels) {\n      p.dom.classList.add(\"cm-panel\");\n      if (p.mount) p.mount();\n    }\n  }\n\n  update(update) {\n    let conf = update.state.facet(panelConfig);\n\n    if (this.top.container != conf.topContainer) {\n      this.top.sync([]);\n      this.top = new PanelGroup(update.view, true, conf.topContainer);\n    }\n\n    if (this.bottom.container != conf.bottomContainer) {\n      this.bottom.sync([]);\n      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n    }\n\n    this.top.syncClasses();\n    this.bottom.syncClasses();\n    let input = update.state.facet(showPanel);\n\n    if (input != this.input) {\n      let specs = input.filter(x => x);\n      let panels = [],\n          top = [],\n          bottom = [],\n          mount = [];\n\n      for (let spec of specs) {\n        let known = this.specs.indexOf(spec),\n            panel;\n\n        if (known < 0) {\n          panel = spec(update.view);\n          mount.push(panel);\n        } else {\n          panel = this.panels[known];\n          if (panel.update) panel.update(update);\n        }\n\n        panels.push(panel);\n        (panel.top ? top : bottom).push(panel);\n      }\n\n      this.specs = specs;\n      this.panels = panels;\n      this.top.sync(top);\n      this.bottom.sync(bottom);\n\n      for (let p of mount) {\n        p.dom.classList.add(\"cm-panel\");\n        if (p.mount) p.mount();\n      }\n    } else {\n      for (let p of this.panels) if (p.update) p.update(update);\n    }\n  }\n\n  destroy() {\n    this.top.sync([]);\n    this.bottom.sync([]);\n  }\n\n}, {\n  provide: /*@__PURE__*/PluginField.scrollMargins.from(value => ({\n    top: value.top.scrollMargin(),\n    bottom: value.bottom.scrollMargin()\n  }))\n});\n\nclass PanelGroup {\n  constructor(view, top, container) {\n    this.view = view;\n    this.top = top;\n    this.container = container;\n    this.dom = undefined;\n    this.classes = \"\";\n    this.panels = [];\n    this.syncClasses();\n  }\n\n  sync(panels) {\n    for (let p of this.panels) if (p.destroy && panels.indexOf(p) < 0) p.destroy();\n\n    this.panels = panels;\n    this.syncDOM();\n  }\n\n  syncDOM() {\n    if (this.panels.length == 0) {\n      if (this.dom) {\n        this.dom.remove();\n        this.dom = undefined;\n      }\n\n      return;\n    }\n\n    if (!this.dom) {\n      this.dom = document.createElement(\"div\");\n      this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n      this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n      let parent = this.container || this.view.dom;\n      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n    }\n\n    let curDOM = this.dom.firstChild;\n\n    for (let panel of this.panels) {\n      if (panel.dom.parentNode == this.dom) {\n        while (curDOM != panel.dom) curDOM = rm(curDOM);\n\n        curDOM = curDOM.nextSibling;\n      } else {\n        this.dom.insertBefore(panel.dom, curDOM);\n      }\n    }\n\n    while (curDOM) curDOM = rm(curDOM);\n  }\n\n  scrollMargin() {\n    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n  }\n\n  syncClasses() {\n    if (!this.container || this.classes == this.view.themeClasses) return;\n\n    for (let cls of this.classes.split(\" \")) if (cls) this.container.classList.remove(cls);\n\n    for (let cls of (this.classes = this.view.themeClasses).split(\" \")) if (cls) this.container.classList.add(cls);\n  }\n\n}\n\nfunction rm(node) {\n  let next = node.nextSibling;\n  node.remove();\n  return next;\n}\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-panels\": {\n    boxSizing: \"border-box\",\n    position: \"sticky\",\n    left: 0,\n    right: 0\n  },\n  \"&light .cm-panels\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"black\"\n  },\n  \"&light .cm-panels-top\": {\n    borderBottom: \"1px solid #ddd\"\n  },\n  \"&light .cm-panels-bottom\": {\n    borderTop: \"1px solid #ddd\"\n  },\n  \"&dark .cm-panels\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  }\n});\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/\n\nconst showPanel = /*@__PURE__*/Facet.define({\n  enables: [panelPlugin, baseTheme]\n});\nexport { getPanel, panels, showPanel };","map":null,"metadata":{},"sourceType":"module"}