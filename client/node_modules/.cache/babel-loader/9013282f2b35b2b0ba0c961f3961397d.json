{"ast":null,"code":"import { EditorSelection } from '@codemirror/state';\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\n\nconst toggleComment = target => {\n  let config = getConfig(target.state);\n  return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;\n};\n\nfunction command(f, option) {\n  return _ref => {\n    let {\n      state,\n      dispatch\n    } = _ref;\n    let tr = f(option, state.selection.ranges, state);\n    if (!tr) return false;\n    dispatch(state.update(tr));\n    return true;\n  };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\n\n\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0\n/* Toggle */\n);\n/**\nComment the current selection using line comments.\n*/\n\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1\n/* Comment */\n);\n/**\nUncomment the current selection using line comments.\n*/\n\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2\n/* Uncomment */\n);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\n\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0\n/* Toggle */\n);\n/**\nComment the current selection using block comments.\n*/\n\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1\n/* Comment */\n);\n/**\nUncomment the current selection using block comments.\n*/\n\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2\n/* Uncomment */\n);\n/**\nDefault key bindings for this package.\n\n - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#comment.toggleComment).\n - Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#comment.toggleBlockComment).\n*/\n\nconst commentKeymap = [{\n  key: \"Mod-/\",\n  run: toggleComment\n}, {\n  key: \"Alt-A\",\n  run: toggleBlockComment\n}];\n\nfunction getConfig(state) {\n  let pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : state.selection.main.head;\n  let data = state.languageDataAt(\"commentTokens\", pos);\n  return data.length ? data[0] : {};\n}\n\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\n\nfunction findBlockComment(state, _ref2, from, to) {\n  let {\n    open,\n    close\n  } = _ref2;\n  let textBefore = state.sliceDoc(from - SearchMargin, from);\n  let textAfter = state.sliceDoc(to, to + SearchMargin);\n  let spaceBefore = /\\s*$/.exec(textBefore)[0].length,\n      spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n  let beforeOff = textBefore.length - spaceBefore;\n\n  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n    return {\n      open: {\n        pos: from - spaceBefore,\n        margin: spaceBefore && 1\n      },\n      close: {\n        pos: to + spaceAfter,\n        margin: spaceAfter && 1\n      }\n    };\n  }\n\n  let startText, endText;\n\n  if (to - from <= 2 * SearchMargin) {\n    startText = endText = state.sliceDoc(from, to);\n  } else {\n    startText = state.sliceDoc(from, from + SearchMargin);\n    endText = state.sliceDoc(to - SearchMargin, to);\n  }\n\n  let startSpace = /^\\s*/.exec(startText)[0].length,\n      endSpace = /\\s*$/.exec(endText)[0].length;\n  let endOff = endText.length - endSpace - close.length;\n\n  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n    return {\n      open: {\n        pos: from + startSpace + open.length,\n        margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n      },\n      close: {\n        pos: to - endSpace - close.length,\n        margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n      }\n    };\n  }\n\n  return null;\n} // Performs toggle, comment and uncomment of block comments in\n// languages that support them.\n\n\nfunction changeBlockComment(option, ranges, state) {\n  let tokens = ranges.map(r => getConfig(state, r.from).block);\n  if (!tokens.every(c => c)) return null;\n  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n\n  if (option != 2\n  /* Uncomment */\n  && !comments.every(c => c)) {\n    let index = 0;\n    return state.changeByRange(range => {\n      let {\n        open,\n        close\n      } = tokens[index++];\n      if (comments[index]) return {\n        range\n      };\n      let shift = open.length + 1;\n      return {\n        changes: [{\n          from: range.from,\n          insert: open + \" \"\n        }, {\n          from: range.to,\n          insert: \" \" + close\n        }],\n        range: EditorSelection.range(range.anchor + shift, range.head + shift)\n      };\n    });\n  } else if (option != 1\n  /* Comment */\n  && comments.some(c => c)) {\n    let changes = [];\n\n    for (let i = 0, comment; i < comments.length; i++) if (comment = comments[i]) {\n      let token = tokens[i],\n          {\n        open,\n        close\n      } = comment;\n      changes.push({\n        from: open.pos - token.open.length,\n        to: open.pos + open.margin\n      }, {\n        from: close.pos - close.margin,\n        to: close.pos + token.close.length\n      });\n    }\n\n    return {\n      changes\n    };\n  }\n\n  return null;\n} // Performs toggle, comment and uncomment of line comments.\n\n\nfunction changeLineComment(option, ranges, state) {\n  let lines = [];\n  let prevLine = -1;\n\n  for (let {\n    from,\n    to\n  } of ranges) {\n    let startI = lines.length,\n        minIndent = 1e9;\n\n    for (let pos = from; pos <= to;) {\n      let line = state.doc.lineAt(pos);\n\n      if (line.from > prevLine && (from == to || to > line.from)) {\n        prevLine = line.from;\n        let token = getConfig(state, pos).line;\n        if (!token) continue;\n        let indent = /^\\s*/.exec(line.text)[0].length;\n        let empty = indent == line.length;\n        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n        if (indent < line.text.length && indent < minIndent) minIndent = indent;\n        lines.push({\n          line,\n          comment,\n          token,\n          indent,\n          empty,\n          single: false\n        });\n      }\n\n      pos = line.to + 1;\n    }\n\n    if (minIndent < 1e9) for (let i = startI; i < lines.length; i++) if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n    if (lines.length == startI + 1) lines[startI].single = true;\n  }\n\n  if (option != 2\n  /* Uncomment */\n  && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n    let changes = [];\n\n    for (let {\n      line,\n      token,\n      indent,\n      empty,\n      single\n    } of lines) if (single || !empty) changes.push({\n      from: line.from + indent,\n      insert: token + \" \"\n    });\n\n    let changeSet = state.changes(changes);\n    return {\n      changes: changeSet,\n      selection: state.selection.map(changeSet, 1)\n    };\n  } else if (option != 1\n  /* Comment */\n  && lines.some(l => l.comment >= 0)) {\n    let changes = [];\n\n    for (let {\n      line,\n      comment,\n      token\n    } of lines) if (comment >= 0) {\n      let from = line.from + comment,\n          to = from + token.length;\n      if (line.text[to - line.from] == \" \") to++;\n      changes.push({\n        from,\n        to\n      });\n    }\n\n    return {\n      changes\n    };\n  }\n\n  return null;\n}\n\nexport { blockComment, blockUncomment, commentKeymap, lineComment, lineUncomment, toggleBlockComment, toggleComment, toggleLineComment };","map":null,"metadata":{},"sourceType":"module"}