{"ast":null,"code":"import { parser } from '@lezer/javascript';\nimport { LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\n\nconst snippets = [/*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n  label: \"function\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"of loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n  label: \"try\",\n  detail: \"block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n  label: \"class\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"named\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"default\",\n  type: \"keyword\"\n})];\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\n\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      IfStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|else\\b)/\n      }),\n      TryStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|catch\\b|finally\\b)/\n      }),\n      LabeledStatement: flatIndent,\n      SwitchBody: context => {\n        let after = context.textAfter,\n            closed = /^\\s*\\}/.test(after),\n            isCase = /^\\s*(case|default)\\b/.test(after);\n        return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n      },\n      Block: /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      ArrowFunction: cx => cx.baseIndent + cx.unit,\n      \"TemplateString BlockComment\": () => -1,\n      \"Statement Property\": /*@__PURE__*/continuedIndent({\n        except: /^{/\n      }),\n\n      JSXElement(context) {\n        let closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n\n      JSXEscape(context) {\n        let closed = /\\s*\\}/.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n\n      \"JSXOpenTag JSXSelfClosingTag\"(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression\": foldInside,\n\n      BlockComment(tree) {\n        return {\n          from: tree.from + 2,\n          to: tree.to - 2\n        };\n      }\n\n    }), /*@__PURE__*/styleTags({\n      \"get set async static\": tags.modifier,\n      \"for while do if else switch try catch finally return throw break continue default case\": tags.controlKeyword,\n      \"in of await yield void typeof delete instanceof\": tags.operatorKeyword,\n      \"let var const function class extends\": tags.definitionKeyword,\n      \"import export from\": tags.moduleKeyword,\n      \"with debugger as new\": tags.keyword,\n      TemplateString: /*@__PURE__*/tags.special(tags.string),\n      Super: tags.atom,\n      BooleanLiteral: tags.bool,\n      this: tags.self,\n      null: tags.null,\n      Star: tags.modifier,\n      VariableName: tags.variableName,\n      \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": /*@__PURE__*/tags.function(tags.variableName),\n      VariableDefinition: /*@__PURE__*/tags.definition(tags.variableName),\n      Label: tags.labelName,\n      PropertyName: tags.propertyName,\n      PrivatePropertyName: /*@__PURE__*/tags.special(tags.propertyName),\n      \"CallExpression/MemberExpression/PropertyName\": /*@__PURE__*/tags.function(tags.propertyName),\n      \"FunctionDeclaration/VariableDefinition\": /*@__PURE__*/tags.function( /*@__PURE__*/tags.definition(tags.variableName)),\n      \"ClassDeclaration/VariableDefinition\": /*@__PURE__*/tags.definition(tags.className),\n      PropertyDefinition: /*@__PURE__*/tags.definition(tags.propertyName),\n      PrivatePropertyDefinition: /*@__PURE__*/tags.definition( /*@__PURE__*/tags.special(tags.propertyName)),\n      UpdateOp: tags.updateOperator,\n      LineComment: tags.lineComment,\n      BlockComment: tags.blockComment,\n      Number: tags.number,\n      String: tags.string,\n      ArithOp: tags.arithmeticOperator,\n      LogicOp: tags.logicOperator,\n      BitOp: tags.bitwiseOperator,\n      CompareOp: tags.compareOperator,\n      RegExp: tags.regexp,\n      Equals: tags.definitionOperator,\n      \"Arrow : Spread\": tags.punctuation,\n      \"( )\": tags.paren,\n      \"[ ]\": tags.squareBracket,\n      \"{ }\": tags.brace,\n      \".\": tags.derefOperator,\n      \", ;\": tags.separator,\n      TypeName: tags.typeName,\n      TypeDefinition: /*@__PURE__*/tags.definition(tags.typeName),\n      \"type enum interface implements namespace module declare\": tags.definitionKeyword,\n      \"abstract global Privacy readonly override\": tags.modifier,\n      \"is keyof unique infer\": tags.operatorKeyword,\n      JSXAttributeValue: tags.attributeValue,\n      JSXText: tags.content,\n      \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": tags.angleBracket,\n      \"JSXIdentifier JSXNameSpacedName\": tags.tagName,\n      \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": tags.attributeName\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"]\n    },\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n    wordChars: \"$\"\n  }\n});\n/**\nA language provider for TypeScript.\n*/\n\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"ts\"\n});\n/**\nLanguage provider for JSX.\n*/\n\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx\"\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\n\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx ts\"\n});\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\ncompletion.\n*/\n\nfunction javascript() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;\n  return new LanguageSupport(lang, javascriptLanguage.data.of({\n    autocomplete: ifNotIn([\"LineComment\", \"BlockComment\", \"String\"], completeFromList(snippets))\n  }));\n}\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The [eslint4b](https://github.com/mysticatea/eslint4b)\nand\n[eslint4b-prebuilt](https://github.com/marijnh/eslint4b-prebuilt/)\npackages may help with that.\n*/\n\n\nfunction esLint(eslint, config) {\n  if (!config) {\n    config = {\n      parserOptions: {\n        ecmaVersion: 2019,\n        sourceType: \"module\"\n      },\n      env: {\n        browser: true,\n        node: true,\n        es6: true,\n        es2015: true,\n        es2017: true,\n        es2020: true\n      },\n      rules: {}\n    };\n    eslint.getRules().forEach((desc, name) => {\n      if (desc.meta.docs.recommended) config.rules[name] = 2;\n    });\n  }\n\n  return view => {\n    let {\n      state\n    } = view,\n        found = [];\n\n    for (let {\n      from,\n      to\n    } of javascriptLanguage.findRegions(state)) {\n      let fromLine = state.doc.lineAt(from),\n          offset = {\n        line: fromLine.number - 1,\n        col: from - fromLine.from,\n        pos: from\n      };\n\n      for (let d of eslint.verify(state.sliceDoc(from, to), config)) found.push(translateDiagnostic(d, state.doc, offset));\n    }\n\n    return found;\n  };\n}\n\nfunction mapPos(line, col, doc, offset) {\n  return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\n\nfunction translateDiagnostic(input, doc, offset) {\n  let start = mapPos(input.line, input.column, doc, offset);\n  let result = {\n    from: start,\n    to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n    message: input.message,\n    source: input.ruleId ? \"jshint:\" + input.ruleId : \"jshint\",\n    severity: input.severity == 1 ? \"warning\" : \"error\"\n  };\n\n  if (input.fix) {\n    let {\n      range,\n      text\n    } = input.fix,\n        from = range[0] + offset.pos - start,\n        to = range[1] + offset.pos - start;\n    result.actions = [{\n      name: \"fix\",\n\n      apply(view, start) {\n        view.dispatch({\n          changes: {\n            from: start + from,\n            to: start + to,\n            insert: text\n          },\n          scrollIntoView: true\n        });\n      }\n\n    }];\n  }\n\n  return result;\n}\n\nexport { esLint, javascript, javascriptLanguage, jsxLanguage, snippets, tsxLanguage, typescriptLanguage };","map":null,"metadata":{},"sourceType":"module"}