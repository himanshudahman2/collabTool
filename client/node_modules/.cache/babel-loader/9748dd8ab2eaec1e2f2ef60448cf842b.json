{"ast":null,"code":"var emitter = require('../emitter');\n\nvar util = require('../util'); // Queries are live requests to the database for particular sets of fields.\n//\n// The server actively tells the client when there's new data that matches\n// a set of conditions.\n\n\nmodule.exports = Query;\n\nfunction Query(action, connection, id, collection, query, options, callback) {\n  emitter.EventEmitter.call(this); // 'qf' or 'qs'\n\n  this.action = action;\n  this.connection = connection;\n  this.id = id;\n  this.collection = collection; // The query itself. For mongo, this should look something like {\"data.x\":5}\n\n  this.query = query; // A list of resulting documents. These are actual documents, complete with\n  // data and all the rest. It is possible to pass in an initial results set,\n  // so that a query can be serialized and then re-established\n\n  this.results = null;\n\n  if (options && options.results) {\n    this.results = options.results;\n    delete options.results;\n  }\n\n  this.extra = undefined; // Options to pass through with the query\n\n  this.options = options;\n  this.callback = callback;\n  this.ready = false;\n  this.sent = false;\n}\n\nemitter.mixin(Query);\n\nQuery.prototype.hasPending = function () {\n  return !this.ready;\n}; // Helper for subscribe & fetch, since they share the same message format.\n//\n// This function actually issues the query.\n\n\nQuery.prototype.send = function () {\n  if (!this.connection.canSend) return;\n  var message = {\n    a: this.action,\n    id: this.id,\n    c: this.collection,\n    q: this.query\n  };\n\n  if (this.options) {\n    message.o = this.options;\n  }\n\n  if (this.results) {\n    // Collect the version of all the documents in the current result set so we\n    // don't need to be sent their snapshots again.\n    var results = [];\n\n    for (var i = 0; i < this.results.length; i++) {\n      var doc = this.results[i];\n      results.push([doc.id, doc.version]);\n    }\n\n    message.r = results;\n  }\n\n  this.connection.send(message);\n  this.sent = true;\n}; // Destroy the query object. Any subsequent messages for the query will be\n// ignored by the connection.\n\n\nQuery.prototype.destroy = function (callback) {\n  if (this.connection.canSend && this.action === 'qs') {\n    this.connection.send({\n      a: 'qu',\n      id: this.id\n    });\n  }\n\n  this.connection._destroyQuery(this); // There is a callback for consistency, but we don't actually wait for the\n  // server's unsubscribe message currently\n\n\n  if (callback) util.nextTick(callback);\n};\n\nQuery.prototype._onConnectionStateChanged = function () {\n  if (this.connection.canSend && !this.sent) {\n    this.send();\n  } else {\n    this.sent = false;\n  }\n};\n\nQuery.prototype._handleFetch = function (err, data, extra) {\n  // Once a fetch query gets its data, it is destroyed.\n  this.connection._destroyQuery(this);\n\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleSubscribe = function (err, data, extra) {\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleResponse = function (err, data, extra) {\n  var callback = this.callback;\n  this.callback = null;\n  if (err) return this._finishResponse(err, callback);\n  if (!data) return this._finishResponse(null, callback);\n  var query = this;\n  var wait = 1;\n\n  var finish = function (err) {\n    if (err) return query._finishResponse(err, callback);\n    if (--wait) return;\n\n    query._finishResponse(null, callback);\n  };\n\n  if (Array.isArray(data)) {\n    wait += data.length;\n    this.results = this._ingestSnapshots(data, finish);\n    this.extra = extra;\n  } else {\n    for (var id in data) {\n      wait++;\n      var snapshot = data[id];\n      var doc = this.connection.get(snapshot.c || this.collection, id);\n      doc.ingestSnapshot(snapshot, finish);\n    }\n  }\n\n  finish();\n};\n\nQuery.prototype._ingestSnapshots = function (snapshots, finish) {\n  var results = [];\n\n  for (var i = 0; i < snapshots.length; i++) {\n    var snapshot = snapshots[i];\n    var doc = this.connection.get(snapshot.c || this.collection, snapshot.d);\n    doc.ingestSnapshot(snapshot, finish);\n    results.push(doc);\n  }\n\n  return results;\n};\n\nQuery.prototype._finishResponse = function (err, callback) {\n  this.emit('ready');\n  this.ready = true;\n\n  if (err) {\n    this.connection._destroyQuery(this);\n\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n\n  if (callback) callback(null, this.results, this.extra);\n};\n\nQuery.prototype._handleError = function (err) {\n  this.emit('error', err);\n};\n\nQuery.prototype._handleDiff = function (diff) {\n  // We need to go through the list twice. First, we'll ingest all the new\n  // documents. After that we'll emit events and actually update our list.\n  // This avoids race conditions around setting documents to be subscribed &\n  // unsubscribing documents in event callbacks.\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n    if (d.type === 'insert') d.values = this._ingestSnapshots(d.values);\n  }\n\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n\n    switch (d.type) {\n      case 'insert':\n        var newDocs = d.values;\n        Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));\n        this.emit('insert', newDocs, d.index);\n        break;\n\n      case 'remove':\n        var howMany = d.howMany || 1;\n        var removed = this.results.splice(d.index, howMany);\n        this.emit('remove', removed, d.index);\n        break;\n\n      case 'move':\n        var howMany = d.howMany || 1;\n        var docs = this.results.splice(d.from, howMany);\n        Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));\n        this.emit('move', docs, d.from, d.to);\n        break;\n    }\n  }\n\n  this.emit('changed', this.results);\n};\n\nQuery.prototype._handleExtra = function (extra) {\n  this.extra = extra;\n  this.emit('extra', extra);\n};","map":null,"metadata":{},"sourceType":"script"}