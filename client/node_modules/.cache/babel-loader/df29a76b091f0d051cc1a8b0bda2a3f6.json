{"ast":null,"code":"import { StateEffect, StateField, Facet, combineConfig } from '@codemirror/state';\nimport { Decoration, EditorView, WidgetType, ViewPlugin } from '@codemirror/view';\nimport { foldable, language } from '@codemirror/language';\nimport { gutter, GutterMarker } from '@codemirror/gutter';\nimport { RangeSet, RangeSetBuilder } from '@codemirror/rangeset';\n\nfunction mapRange(range, mapping) {\n  let from = mapping.mapPos(range.from, 1),\n      to = mapping.mapPos(range.to, -1);\n  return from >= to ? undefined : {\n    from,\n    to\n  };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#fold.foldGutter) create the transactions.)\n*/\n\n\nconst foldEffect = /*@__PURE__*/StateEffect.define({\n  map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/\n\nconst unfoldEffect = /*@__PURE__*/StateEffect.define({\n  map: mapRange\n});\n\nfunction selectedLines(view) {\n  let lines = [];\n\n  for (let {\n    head\n  } of view.state.selection.ranges) {\n    if (lines.some(l => l.from <= head && l.to >= head)) continue;\n    lines.push(view.lineBlockAt(head));\n  }\n\n  return lines;\n}\n\nconst foldState = /*@__PURE__*/StateField.define({\n  create() {\n    return Decoration.none;\n  },\n\n  update(folded, tr) {\n    folded = folded.map(tr.changes);\n\n    for (let e of tr.effects) {\n      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) folded = folded.update({\n        add: [foldWidget.range(e.value.from, e.value.to)]\n      });else if (e.is(unfoldEffect)) folded = folded.update({\n        filter: (from, to) => e.value.from != from || e.value.to != to,\n        filterFrom: e.value.from,\n        filterTo: e.value.to\n      });\n    } // Clear folded ranges that cover the selection head\n\n\n    if (tr.selection) {\n      let onSelection = false,\n          {\n        head\n      } = tr.selection.main;\n      folded.between(head, head, (a, b) => {\n        if (a < head && b > head) onSelection = true;\n      });\n      if (onSelection) folded = folded.update({\n        filterFrom: head,\n        filterTo: head,\n        filter: (a, b) => b <= head || a >= head\n      });\n    }\n\n    return folded;\n  },\n\n  provide: f => EditorView.decorations.from(f)\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) containing the folded ranges\nin the given state.\n*/\n\nfunction foldedRanges(state) {\n  return state.field(foldState, false) || RangeSet.empty;\n}\n\nfunction foldInside(state, from, to) {\n  var _a;\n\n  let found = null;\n  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n    if (!found || found.from > from) found = {\n      from,\n      to\n    };\n  });\n  return found;\n}\n\nfunction foldExists(folded, from, to) {\n  let found = false;\n  folded.between(from, from, (a, b) => {\n    if (a == from && b == to) found = true;\n  });\n  return found;\n}\n\nfunction maybeEnable(state, other) {\n  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/\n\n\nconst foldCode = view => {\n  for (let line of selectedLines(view)) {\n    let range = foldable(view.state, line.from, line.to);\n\n    if (range) {\n      view.dispatch({\n        effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])\n      });\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/\n\n\nconst unfoldCode = view => {\n  if (!view.state.field(foldState, false)) return false;\n  let effects = [];\n\n  for (let line of selectedLines(view)) {\n    let folded = foldInside(view.state, line.from, line.to);\n    if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n  }\n\n  if (effects.length) view.dispatch({\n    effects\n  });\n  return effects.length > 0;\n};\n\nfunction announceFold(view, range) {\n  let fold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let lineFrom = view.state.doc.lineAt(range.from).number,\n      lineTo = view.state.doc.lineAt(range.to).number;\n  return EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges.\n*/\n\n\nconst foldAll = view => {\n  let {\n    state\n  } = view,\n      effects = [];\n\n  for (let pos = 0; pos < state.doc.length;) {\n    let line = view.lineBlockAt(pos),\n        range = foldable(state, line.from, line.to);\n    if (range) effects.push(foldEffect.of(range));\n    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n  }\n\n  if (effects.length) view.dispatch({\n    effects: maybeEnable(view.state, effects)\n  });\n  return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/\n\n\nconst unfoldAll = view => {\n  let field = view.state.field(foldState, false);\n  if (!field || !field.size) return false;\n  let effects = [];\n  field.between(0, view.state.doc.length, (from, to) => {\n    effects.push(unfoldEffect.of({\n      from,\n      to\n    }));\n  });\n  view.dispatch({\n    effects\n  });\n  return true;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#fold.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#fold.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#fold.unfoldAll).\n*/\n\n\nconst foldKeymap = [{\n  key: \"Ctrl-Shift-[\",\n  mac: \"Cmd-Alt-[\",\n  run: foldCode\n}, {\n  key: \"Ctrl-Shift-]\",\n  mac: \"Cmd-Alt-]\",\n  run: unfoldCode\n}, {\n  key: \"Ctrl-Alt-[\",\n  run: foldAll\n}, {\n  key: \"Ctrl-Alt-]\",\n  run: unfoldAll\n}];\nconst defaultConfig = {\n  placeholderDOM: null,\n  placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/Facet.define({\n  combine(values) {\n    return combineConfig(values, defaultConfig);\n  }\n\n});\n/**\nCreate an extension that configures code folding.\n*/\n\nfunction codeFolding(config) {\n  let result = [foldState, baseTheme];\n  if (config) result.push(foldConfig.of(config));\n  return result;\n}\n\nconst foldWidget = /*@__PURE__*/Decoration.replace({\n  widget: /*@__PURE__*/new class extends WidgetType {\n    toDOM(view) {\n      let {\n        state\n      } = view,\n          conf = state.facet(foldConfig);\n\n      let onclick = event => {\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = foldInside(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n          effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n      };\n\n      if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick);\n      let element = document.createElement(\"span\");\n      element.textContent = conf.placeholderText;\n      element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n      element.title = state.phrase(\"unfold\");\n      element.className = \"cm-foldPlaceholder\";\n      element.onclick = onclick;\n      return element;\n    }\n\n  }()\n});\nconst foldGutterDefaults = {\n  openText: \"⌄\",\n  closedText: \"›\",\n  markerDOM: null,\n  domEventHandlers: {}\n};\n\nclass FoldMarker extends GutterMarker {\n  constructor(config, open) {\n    super();\n    this.config = config;\n    this.open = open;\n  }\n\n  eq(other) {\n    return this.config == other.config && this.open == other.open;\n  }\n\n  toDOM(view) {\n    if (this.config.markerDOM) return this.config.markerDOM(this.open);\n    let span = document.createElement(\"span\");\n    span.textContent = this.open ? this.config.openText : this.config.closedText;\n    span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n    return span;\n  }\n\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/\n\n\nfunction foldGutter() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n  let canFold = new FoldMarker(fullConfig, true),\n      canUnfold = new FoldMarker(fullConfig, false);\n  let markers = ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.from = view.viewport.from;\n      this.markers = this.buildMarkers(view);\n    }\n\n    update(update) {\n      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false)) this.markers = this.buildMarkers(update.view);\n    }\n\n    buildMarkers(view) {\n      let builder = new RangeSetBuilder();\n\n      for (let line of view.viewportLineBlocks) {\n        let mark = foldInside(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n        if (mark) builder.add(line.from, line.from, mark);\n      }\n\n      return builder.finish();\n    }\n\n  });\n  let {\n    domEventHandlers\n  } = fullConfig;\n  return [markers, gutter({\n    class: \"cm-foldGutter\",\n\n    markers(view) {\n      var _a;\n\n      return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty;\n    },\n\n    initialSpacer() {\n      return new FoldMarker(fullConfig, false);\n    },\n\n    domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {\n      click: (view, line, event) => {\n        if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n        let folded = foldInside(view.state, line.from, line.to);\n\n        if (folded) {\n          view.dispatch({\n            effects: unfoldEffect.of(folded)\n          });\n          return true;\n        }\n\n        let range = foldable(view.state, line.from, line.to);\n\n        if (range) {\n          view.dispatch({\n            effects: foldEffect.of(range)\n          });\n          return true;\n        }\n\n        return false;\n      }\n    })\n  }), codeFolding()];\n}\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-foldPlaceholder\": {\n    backgroundColor: \"#eee\",\n    border: \"1px solid #ddd\",\n    color: \"#888\",\n    borderRadius: \".2em\",\n    margin: \"0 1px\",\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  },\n  \".cm-foldGutter span\": {\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  }\n});\nexport { codeFolding, foldAll, foldCode, foldEffect, foldGutter, foldKeymap, foldedRanges, unfoldAll, unfoldCode, unfoldEffect };","map":null,"metadata":{},"sourceType":"module"}