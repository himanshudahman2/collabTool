{"ast":null,"code":"import { NodeProp, NodeType } from '@lezer/common';\nimport { StyleModule } from 'style-mod';\nimport { EditorView, ViewPlugin, Decoration } from '@codemirror/view';\nimport { Facet, Prec } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport { RangeSetBuilder } from '@codemirror/rangeset';\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](https://codemirror.net/6/docs/ref/#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlight style](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](https://codemirror.net/6/docs/ref/#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](https://codemirror.net/6/docs/ref/#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\n\nclass Tag {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The set of tags that match this tag, starting with this one\n  itself, sorted in order of decreasing specificity. @internal\n  */\n  set,\n  /**\n  The base unmodified tag that this one is based on, if it's\n  modified @internal\n  */\n  base,\n  /**\n  The modifiers applied to this.base @internal\n  */\n  modified) {\n    this.set = set;\n    this.base = base;\n    this.modified = modified;\n    /**\n    @internal\n    */\n\n    this.id = nextTagID++;\n  }\n  /**\n  Define a new tag. If `parent` is given, the tag is treated as a\n  sub-tag of that parent, and [highlight\n  styles](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle) that don't mention this tag\n  will try to fall back to the parent tag (or grandparent tag,\n  etc).\n  */\n\n\n  static define(parent) {\n    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n    let tag = new Tag([], null, []);\n    tag.set.push(tag);\n    if (parent) for (let t of parent.set) tag.set.push(t);\n    return tag;\n  }\n  /**\n  Define a tag _modifier_, which is a function that, given a tag,\n  will return a tag that is a subtag of the original. Applying the\n  same modifier to a twice tag will return the same value (`m1(t1)\n  == m1(t1)`) and applying multiple modifiers will, regardless or\n  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n  \n  When multiple modifiers are applied to a given base tag, each\n  smaller set of modifiers is registered as a parent, so that for\n  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n  `m1(m3(t1)`, and so on.\n  */\n\n\n  static defineModifier() {\n    let mod = new Modifier();\n    return tag => {\n      if (tag.modified.indexOf(mod) > -1) return tag;\n      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n    };\n  }\n\n}\n\nlet nextModifierID = 0;\n\nclass Modifier {\n  constructor() {\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n\n  static get(base, mods) {\n    if (!mods.length) return base;\n    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n    if (exists) return exists;\n    let set = [],\n        tag = new Tag(set, base, mods);\n\n    for (let m of mods) m.instances.push(tag);\n\n    let configs = permute(mods);\n\n    for (let parent of base.set) for (let config of configs) set.push(Modifier.get(parent, config));\n\n    return tag;\n  }\n\n}\n\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every((x, i) => x == b[i]);\n}\n\nfunction permute(array) {\n  let result = [array];\n\n  for (let i = 0; i < array.length; i++) {\n    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1)))) result.push(a);\n  }\n\n  return result;\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia\n[`LRParser.configure`](https://lezer.codemirror.net/docs/ref#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](https://codemirror.net/6/docs/ref/#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node\nname](https://lezer.codemirror.net/docs/ref#common.NodeType.name),\nor multiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelâ€”wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/\n\n\nfunction styleTags(spec) {\n  let byName = Object.create(null);\n\n  for (let prop in spec) {\n    let tags = spec[prop];\n    if (!Array.isArray(tags)) tags = [tags];\n\n    for (let part of prop.split(\" \")) if (part) {\n      let pieces = [],\n          mode = 2\n      /* Normal */\n      ,\n          rest = part;\n\n      for (let pos = 0;;) {\n        if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n          mode = 1\n          /* Inherit */\n          ;\n          break;\n        }\n\n        let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n        if (!m) throw new RangeError(\"Invalid path: \" + part);\n        pieces.push(m[0] == \"*\" ? null : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n        pos += m[0].length;\n        if (pos == part.length) break;\n        let next = part[pos++];\n\n        if (pos == part.length && next == \"!\") {\n          mode = 0\n          /* Opaque */\n          ;\n          break;\n        }\n\n        if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n        rest = part.slice(pos);\n      }\n\n      let last = pieces.length - 1,\n          inner = pieces[last];\n      if (!inner) throw new RangeError(\"Invalid path: \" + part);\n      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n      byName[inner] = rule.sort(byName[inner]);\n    }\n  }\n\n  return ruleNodeProp.add(byName);\n}\n\nconst ruleNodeProp = /*@__PURE__*/new NodeProp();\nconst highlightStyle = /*@__PURE__*/Facet.define({\n  combine(stylings) {\n    return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;\n  }\n\n});\nconst fallbackHighlightStyle = /*@__PURE__*/Facet.define({\n  combine(values) {\n    return values.length ? values[0].match : null;\n  }\n\n});\n\nfunction getHighlightStyle(state) {\n  return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle);\n}\n\nclass Rule {\n  constructor(tags, mode, context, next) {\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n\n  sort(other) {\n    if (!other || other.depth < this.depth) {\n      this.next = other;\n      return this;\n    }\n\n    other.next = this.sort(other.next);\n    return other;\n  }\n\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n\n}\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://codemirror.net/6/docs/ref/#highlight.Tag).\n*/\n\n\nclass HighlightStyle {\n  constructor(spec, options) {\n    this.map = Object.create(null);\n    let modSpec;\n\n    function def(spec) {\n      let cls = StyleModule.newName();\n      (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n      return cls;\n    }\n\n    this.all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : null;\n\n    for (let style of spec) {\n      let cls = (style.class || def(Object.assign({}, style, {\n        tag: null\n      }))) + (this.all ? \" \" + this.all : \"\");\n      let tags = style.tag;\n      if (!Array.isArray(tags)) this.map[tags.id] = cls;else for (let tag of tags) this.map[tag.id] = cls;\n    }\n\n    this.module = modSpec ? new StyleModule(modSpec) : null;\n    this.scope = options.scope || null;\n    this.match = this.match.bind(this);\n    let ext = [treeHighlighter];\n    if (this.module) ext.push(EditorView.styleModule.of(this.module));\n    this.extension = ext.concat(highlightStyle.of(this));\n    this.fallback = ext.concat(fallbackHighlightStyle.of(this));\n  }\n  /**\n  Returns the CSS class associated with the given tag, if any.\n  This method is bound to the instance by the constructor.\n  */\n\n\n  match(tag, scope) {\n    if (this.scope && scope != this.scope) return null;\n\n    for (let t of tag.set) {\n      let match = this.map[t.id];\n\n      if (match !== undefined) {\n        if (t != tag) this.map[tag.id] = match;\n        return match;\n      }\n    }\n\n    return this.map[tag.id] = this.all;\n  }\n  /**\n  Combines an array of highlight styles into a single match\n  function that returns all of the classes assigned by the styles\n  for a given tag.\n  */\n\n\n  static combinedMatch(styles) {\n    if (styles.length == 1) return styles[0].match;\n    let cache = styles.some(s => s.scope) ? undefined : Object.create(null);\n    return (tag, scope) => {\n      let cached = cache && cache[tag.id];\n      if (cached !== undefined) return cached;\n      let result = null;\n\n      for (let style of styles) {\n        let value = style.match(tag, scope);\n        if (value) result = result ? result + \" \" + value : value;\n      }\n\n      if (cache) cache[tag.id] = result;\n      return result;\n    };\n  }\n  /**\n  Create a highlighter style that associates the given styles to\n  the given tags. The spec must be objects that hold a style tag\n  or array of tags in their `tag` property, and either a single\n  `class` property providing a static CSS class (for highlighters\n  like [`classHighlightStyle`](https://codemirror.net/6/docs/ref/#highlight.classHighlightStyle)\n  that rely on external styling), or a\n  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n  set of CSS properties (which define the styling for those tags).\n  \n  The CSS rules created for a highlighter will be emitted in the\n  order of the spec's properties. That means that for elements that\n  have multiple tags associated with them, styles defined further\n  down in the list will have a higher CSS precedence than styles\n  defined earlier.\n  */\n\n\n  static define(specs, options) {\n    return new HighlightStyle(specs, options || {});\n  }\n  /**\n  Returns the CSS classes (if any) that the highlight styles\n  active in the given state would assign to the given a style\n  [tag](https://codemirror.net/6/docs/ref/#highlight.Tag) and (optional) language\n  [scope](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle^define^options.scope).\n  */\n\n\n  static get(state, tag, scope) {\n    let style = getHighlightStyle(state);\n    return style && style(tag, scope || NodeType.none);\n  }\n\n}\n/**\nRun the tree highlighter over the given tree.\n*/\n\n\nfunction highlightTree(tree,\n/**\nGet the CSS classes used to style a given [tag](https://codemirror.net/6/docs/ref/#highlight.Tag),\nor `null` if it isn't styled. (You'll often want to pass a\nhighlight style's [`match`](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle.match)\nmethod here.)\n*/\ngetStyle,\n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle) {\n  let from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : tree.length;\n  highlightTreeRange(tree, from, to, getStyle, putStyle);\n}\n\nclass TreeHighlighter {\n  constructor(view) {\n    this.markCache = Object.create(null);\n    this.tree = syntaxTree(view.state);\n    this.decorations = this.buildDeco(view, getHighlightStyle(view.state));\n  }\n\n  update(update) {\n    let tree = syntaxTree(update.state),\n        style = getHighlightStyle(update.state);\n    let styleChange = style != update.startState.facet(highlightStyle);\n\n    if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {\n      this.decorations = this.decorations.map(update.changes);\n    } else if (tree != this.tree || update.viewportChanged || styleChange) {\n      this.tree = tree;\n      this.decorations = this.buildDeco(update.view, style);\n    }\n  }\n\n  buildDeco(view, match) {\n    if (!match || !this.tree.length) return Decoration.none;\n    let builder = new RangeSetBuilder();\n\n    for (let {\n      from,\n      to\n    } of view.visibleRanges) {\n      highlightTreeRange(this.tree, from, to, match, (from, to, style) => {\n        builder.add(from, to, this.markCache[style] || (this.markCache[style] = Decoration.mark({\n          class: style\n        })));\n      });\n    }\n\n    return builder.finish();\n  }\n\n} // This extension installs a highlighter that highlights based on the\n// syntax tree and highlight style.\n\n\nconst treeHighlighter = /*@__PURE__*/Prec.high( /*@__PURE__*/ViewPlugin.fromClass(TreeHighlighter, {\n  decorations: v => v.decorations\n}));\nconst nodeStack = [\"\"];\n\nclass HighlightBuilder {\n  constructor(at, style, span) {\n    this.at = at;\n    this.style = style;\n    this.span = span;\n    this.class = \"\";\n  }\n\n  startSpan(at, cls) {\n    if (cls != this.class) {\n      this.flush(at);\n      if (at > this.at) this.at = at;\n      this.class = cls;\n    }\n  }\n\n  flush(to) {\n    if (to > this.at && this.class) this.span(this.at, to, this.class);\n  }\n\n  highlightRange(cursor, from, to, inheritedClass, depth, scope) {\n    let {\n      type,\n      from: start,\n      to: end\n    } = cursor;\n    if (start >= to || end <= from) return;\n    nodeStack[depth] = type.name;\n    if (type.isTop) scope = type;\n    let cls = inheritedClass;\n    let rule = type.prop(ruleNodeProp),\n        opaque = false;\n\n    while (rule) {\n      if (!rule.context || matchContext(rule.context, nodeStack, depth)) {\n        for (let tag of rule.tags) {\n          let st = this.style(tag, scope);\n\n          if (st) {\n            if (cls) cls += \" \";\n            cls += st;\n            if (rule.mode == 1\n            /* Inherit */\n            ) inheritedClass += (inheritedClass ? \" \" : \"\") + st;else if (rule.mode == 0\n            /* Opaque */\n            ) opaque = true;\n          }\n        }\n\n        break;\n      }\n\n      rule = rule.next;\n    }\n\n    this.startSpan(cursor.from, cls);\n    if (opaque) return;\n    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n\n    if (mounted && mounted.overlay) {\n      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n      let hasChild = cursor.firstChild();\n\n      for (let i = 0, pos = start;; i++) {\n        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n        let nextPos = next ? next.from + start : end;\n        let rangeFrom = Math.max(from, pos),\n            rangeTo = Math.min(to, nextPos);\n\n        if (rangeFrom < rangeTo && hasChild) {\n          while (cursor.from < rangeTo) {\n            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, depth + 1, scope);\n            this.startSpan(Math.min(to, cursor.to), cls);\n            if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n          }\n        }\n\n        if (!next || nextPos > to) break;\n        pos = next.to + start;\n\n        if (pos > from) {\n          this.highlightRange(inner.cursor, Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, depth, mounted.tree.type);\n          this.startSpan(pos, cls);\n        }\n      }\n\n      if (hasChild) cursor.parent();\n    } else if (cursor.firstChild()) {\n      do {\n        if (cursor.to <= from) continue;\n        if (cursor.from >= to) break;\n        this.highlightRange(cursor, from, to, inheritedClass, depth + 1, scope);\n        this.startSpan(Math.min(to, cursor.to), cls);\n      } while (cursor.nextSibling());\n\n      cursor.parent();\n    }\n  }\n\n}\n\nfunction highlightTreeRange(tree, from, to, style, span) {\n  let builder = new HighlightBuilder(from, style, span);\n  builder.highlightRange(tree.cursor(), from, to, \"\", 0, tree.type);\n  builder.flush(to);\n}\n\nfunction matchContext(context, stack, depth) {\n  if (context.length > depth - 1) return false;\n\n  for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {\n    let check = context[i];\n    if (check && check != stack[d]) return false;\n  }\n\n  return true;\n}\n\nconst t = Tag.define;\nconst comment = /*@__PURE__*/t(),\n      name = /*@__PURE__*/t(),\n      typeName = /*@__PURE__*/t(name),\n      propertyName = /*@__PURE__*/t(name),\n      literal = /*@__PURE__*/t(),\n      string = /*@__PURE__*/t(literal),\n      number = /*@__PURE__*/t(literal),\n      content = /*@__PURE__*/t(),\n      heading = /*@__PURE__*/t(content),\n      keyword = /*@__PURE__*/t(),\n      operator = /*@__PURE__*/t(),\n      punctuation = /*@__PURE__*/t(),\n      bracket = /*@__PURE__*/t(punctuation),\n      meta = /*@__PURE__*/t();\n/**\nThe default set of highlighting [tags](https://codemirror.net/6/docs/ref/#highlight.Tag^define) used\nby regular language packages and themes.\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](https://codemirror.net/6/docs/ref/#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementâ€”if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\n\nconst tags = {\n  /**\n  A comment.\n  */\n  comment,\n\n  /**\n  A line [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).\n  */\n  lineComment: /*@__PURE__*/t(comment),\n\n  /**\n  A block [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).\n  */\n  blockComment: /*@__PURE__*/t(comment),\n\n  /**\n  A documentation [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).\n  */\n  docComment: /*@__PURE__*/t(comment),\n\n  /**\n  Any kind of identifier.\n  */\n  name,\n\n  /**\n  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a variable.\n  */\n  variableName: /*@__PURE__*/t(name),\n\n  /**\n  A type [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n  */\n  typeName: typeName,\n\n  /**\n  A tag name (subtag of [`typeName`](https://codemirror.net/6/docs/ref/#highlight.tags.typeName)).\n  */\n  tagName: /*@__PURE__*/t(typeName),\n\n  /**\n  A property or field [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n  */\n  propertyName: propertyName,\n\n  /**\n  An attribute name (subtag of [`propertyName`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)).\n  */\n  attributeName: /*@__PURE__*/t(propertyName),\n\n  /**\n  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a class.\n  */\n  className: /*@__PURE__*/t(name),\n\n  /**\n  A label [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n  */\n  labelName: /*@__PURE__*/t(name),\n\n  /**\n  A namespace [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n  */\n  namespace: /*@__PURE__*/t(name),\n\n  /**\n  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a macro.\n  */\n  macroName: /*@__PURE__*/t(name),\n\n  /**\n  A literal value.\n  */\n  literal,\n\n  /**\n  A string [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  string,\n\n  /**\n  A documentation [string](https://codemirror.net/6/docs/ref/#highlight.tags.string).\n  */\n  docString: /*@__PURE__*/t(string),\n\n  /**\n  A character literal (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).\n  */\n  character: /*@__PURE__*/t(string),\n\n  /**\n  An attribute value (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).\n  */\n  attributeValue: /*@__PURE__*/t(string),\n\n  /**\n  A number [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  number,\n\n  /**\n  An integer [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.\n  */\n  integer: /*@__PURE__*/t(number),\n\n  /**\n  A floating-point [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.\n  */\n  float: /*@__PURE__*/t(number),\n\n  /**\n  A boolean [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  bool: /*@__PURE__*/t(literal),\n\n  /**\n  Regular expression [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  regexp: /*@__PURE__*/t(literal),\n\n  /**\n  An escape [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal), for example a\n  backslash escape in a string.\n  */\n  escape: /*@__PURE__*/t(literal),\n\n  /**\n  A color [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  color: /*@__PURE__*/t(literal),\n\n  /**\n  A URL [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n  */\n  url: /*@__PURE__*/t(literal),\n\n  /**\n  A language keyword.\n  */\n  keyword,\n\n  /**\n  The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for the self or this\n  object.\n  */\n  self: /*@__PURE__*/t(keyword),\n\n  /**\n  The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for null.\n  */\n  null: /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) denoting some atomic value.\n  */\n  atom: /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that represents a unit.\n  */\n  unit: /*@__PURE__*/t(keyword),\n\n  /**\n  A modifier [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).\n  */\n  modifier: /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that acts as an operator.\n  */\n  operatorKeyword: /*@__PURE__*/t(keyword),\n\n  /**\n  A control-flow related [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).\n  */\n  controlKeyword: /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that defines something.\n  */\n  definitionKeyword: /*@__PURE__*/t(keyword),\n\n  /**\n  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) related to defining or\n  interfacing with modules.\n  */\n  moduleKeyword: /*@__PURE__*/t(keyword),\n\n  /**\n  An operator.\n  */\n  operator,\n\n  /**\n  An [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.\n  */\n  derefOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Arithmetic-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  arithmeticOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Logical [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  logicOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Bit [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  bitwiseOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Comparison [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  compareOperator: /*@__PURE__*/t(operator),\n\n  /**\n  [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that updates its operand.\n  */\n  updateOperator: /*@__PURE__*/t(operator),\n\n  /**\n  [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.\n  */\n  definitionOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Type-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  typeOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Control-flow [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n  */\n  controlOperator: /*@__PURE__*/t(operator),\n\n  /**\n  Program or markup punctuation.\n  */\n  punctuation,\n\n  /**\n  [Punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation) that separates\n  things.\n  */\n  separator: /*@__PURE__*/t(punctuation),\n\n  /**\n  Bracket-style [punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation).\n  */\n  bracket,\n\n  /**\n  Angle [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `<` and `>`\n  tokens).\n  */\n  angleBracket: /*@__PURE__*/t(bracket),\n\n  /**\n  Square [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `[` and `]`\n  tokens).\n  */\n  squareBracket: /*@__PURE__*/t(bracket),\n\n  /**\n  Parentheses (usually `(` and `)` tokens). Subtag of\n  [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).\n  */\n  paren: /*@__PURE__*/t(bracket),\n\n  /**\n  Braces (usually `{` and `}` tokens). Subtag of\n  [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).\n  */\n  brace: /*@__PURE__*/t(bracket),\n\n  /**\n  Content, for example plain text in XML or markup documents.\n  */\n  content,\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a heading.\n  */\n  heading,\n\n  /**\n  A level 1 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading1: /*@__PURE__*/t(heading),\n\n  /**\n  A level 2 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading2: /*@__PURE__*/t(heading),\n\n  /**\n  A level 3 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading3: /*@__PURE__*/t(heading),\n\n  /**\n  A level 4 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading4: /*@__PURE__*/t(heading),\n\n  /**\n  A level 5 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading5: /*@__PURE__*/t(heading),\n\n  /**\n  A level 6 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n  */\n  heading6: /*@__PURE__*/t(heading),\n\n  /**\n  A prose separator (such as a horizontal rule).\n  */\n  contentSeparator: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a list.\n  */\n  list: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a quote.\n  */\n  quote: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is emphasized.\n  */\n  emphasis: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled strong.\n  */\n  strong: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is part of a link.\n  */\n  link: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled as code or\n  monospace.\n  */\n  monospace: /*@__PURE__*/t(content),\n\n  /**\n  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that has a strike-through\n  style.\n  */\n  strikethrough: /*@__PURE__*/t(content),\n\n  /**\n  Inserted text in a change-tracking format.\n  */\n  inserted: /*@__PURE__*/t(),\n\n  /**\n  Deleted text.\n  */\n  deleted: /*@__PURE__*/t(),\n\n  /**\n  Changed text.\n  */\n  changed: /*@__PURE__*/t(),\n\n  /**\n  An invalid or unsyntactic element.\n  */\n  invalid: /*@__PURE__*/t(),\n\n  /**\n  Metadata or meta-instruction.\n  */\n  meta,\n\n  /**\n  [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that applies to the entire\n  document.\n  */\n  documentMeta: /*@__PURE__*/t(meta),\n\n  /**\n  [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that annotates or adds\n  attributes to a given syntactic element.\n  */\n  annotation: /*@__PURE__*/t(meta),\n\n  /**\n  Processing instruction or preprocessor directive. Subtag of\n  [meta](https://codemirror.net/6/docs/ref/#highlight.tags.meta).\n  */\n  processingInstruction: /*@__PURE__*/t(meta),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that a\n  given element is being defined. Expected to be used with the\n  various [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) tags.\n  */\n  definition: /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that\n  something is constant. Mostly expected to be used with\n  [variable names](https://codemirror.net/6/docs/ref/#highlight.tags.variableName).\n  */\n  constant: /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) used to indicate that\n  a [variable](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) or [property\n  name](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName) is being called or defined\n  as a function.\n  */\n  function: /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that can be applied to\n  [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) to indicate that they belong to\n  the language's standard environment.\n  */\n  standard: /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates a given\n  [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) is local to some scope.\n  */\n  local: /*@__PURE__*/Tag.defineModifier(),\n\n  /**\n  A generic variant [modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that\n  can be used to tag language-specific alternative variants of\n  some common tag. It is recommended for themes to define special\n  forms of at least the [string](https://codemirror.net/6/docs/ref/#highlight.tags.string) and\n  [variable name](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) tags, since those\n  come up a lot.\n  */\n  special: /*@__PURE__*/Tag.defineModifier()\n};\n/**\nA default highlight style (works well with light themes).\n*/\n\nconst defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([{\n  tag: tags.link,\n  textDecoration: \"underline\"\n}, {\n  tag: tags.heading,\n  textDecoration: \"underline\",\n  fontWeight: \"bold\"\n}, {\n  tag: tags.emphasis,\n  fontStyle: \"italic\"\n}, {\n  tag: tags.strong,\n  fontWeight: \"bold\"\n}, {\n  tag: tags.strikethrough,\n  textDecoration: \"line-through\"\n}, {\n  tag: tags.keyword,\n  color: \"#708\"\n}, {\n  tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],\n  color: \"#219\"\n}, {\n  tag: [tags.literal, tags.inserted],\n  color: \"#164\"\n}, {\n  tag: [tags.string, tags.deleted],\n  color: \"#a11\"\n}, {\n  tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],\n  color: \"#e40\"\n}, {\n  tag: /*@__PURE__*/tags.definition(tags.variableName),\n  color: \"#00f\"\n}, {\n  tag: /*@__PURE__*/tags.local(tags.variableName),\n  color: \"#30a\"\n}, {\n  tag: [tags.typeName, tags.namespace],\n  color: \"#085\"\n}, {\n  tag: tags.className,\n  color: \"#167\"\n}, {\n  tag: [/*@__PURE__*/tags.special(tags.variableName), tags.macroName],\n  color: \"#256\"\n}, {\n  tag: /*@__PURE__*/tags.definition(tags.propertyName),\n  color: \"#00c\"\n}, {\n  tag: tags.comment,\n  color: \"#940\"\n}, {\n  tag: tags.meta,\n  color: \"#7a757a\"\n}, {\n  tag: tags.invalid,\n  color: \"#f00\"\n}]);\n/**\nThis is a highlight style that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThese tags are mapped to their name prefixed with `\"cmt-\"` (for\nexample `\"cmt-comment\"`):\n\n* [`link`](https://codemirror.net/6/docs/ref/#highlight.tags.link)\n* [`heading`](https://codemirror.net/6/docs/ref/#highlight.tags.heading)\n* [`emphasis`](https://codemirror.net/6/docs/ref/#highlight.tags.emphasis)\n* [`strong`](https://codemirror.net/6/docs/ref/#highlight.tags.strong)\n* [`keyword`](https://codemirror.net/6/docs/ref/#highlight.tags.keyword)\n* [`atom`](https://codemirror.net/6/docs/ref/#highlight.tags.atom) [`bool`](https://codemirror.net/6/docs/ref/#highlight.tags.bool)\n* [`url`](https://codemirror.net/6/docs/ref/#highlight.tags.url)\n* [`labelName`](https://codemirror.net/6/docs/ref/#highlight.tags.labelName)\n* [`inserted`](https://codemirror.net/6/docs/ref/#highlight.tags.inserted)\n* [`deleted`](https://codemirror.net/6/docs/ref/#highlight.tags.deleted)\n* [`literal`](https://codemirror.net/6/docs/ref/#highlight.tags.literal)\n* [`string`](https://codemirror.net/6/docs/ref/#highlight.tags.string)\n* [`number`](https://codemirror.net/6/docs/ref/#highlight.tags.number)\n* [`variableName`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n* [`typeName`](https://codemirror.net/6/docs/ref/#highlight.tags.typeName)\n* [`namespace`](https://codemirror.net/6/docs/ref/#highlight.tags.namespace)\n* [`className`](https://codemirror.net/6/docs/ref/#highlight.tags.className)\n* [`macroName`](https://codemirror.net/6/docs/ref/#highlight.tags.macroName)\n* [`propertyName`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)\n* [`operator`](https://codemirror.net/6/docs/ref/#highlight.tags.operator)\n* [`comment`](https://codemirror.net/6/docs/ref/#highlight.tags.comment)\n* [`meta`](https://codemirror.net/6/docs/ref/#highlight.tags.meta)\n* [`punctuation`](https://codemirror.net/6/docs/ref/#highlight.tags.puncutation)\n* [`invalid`](https://codemirror.net/6/docs/ref/#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](https://codemirror.net/6/docs/ref/#highlight.tags.regexp),\n  [`escape`](https://codemirror.net/6/docs/ref/#highlight.tags.escape), and\n  [`special`](https://codemirror.net/6/docs/ref/#highlight.tags.special)[`(string)`](https://codemirror.net/6/docs/ref/#highlight.tags.string)\n  are mapped to `\"cmt-string2\"`\n* [`special`](https://codemirror.net/6/docs/ref/#highlight.tags.special)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n  to `\"cmt-variableName2\"`\n* [`local`](https://codemirror.net/6/docs/ref/#highlight.tags.local)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n  to `\"cmt-variableName cmt-local\"`\n* [`definition`](https://codemirror.net/6/docs/ref/#highlight.tags.definition)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n  to `\"cmt-variableName cmt-definition\"`\n* [`definition`](https://codemirror.net/6/docs/ref/#highlight.tags.definition)[`(propertyName)`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)\n  to `\"cmt-propertyName cmt-definition\"`\n*/\n\nconst classHighlightStyle = /*@__PURE__*/HighlightStyle.define([{\n  tag: tags.link,\n  class: \"cmt-link\"\n}, {\n  tag: tags.heading,\n  class: \"cmt-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"cmt-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"cmt-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"cmt-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"cmt-atom\"\n}, {\n  tag: tags.bool,\n  class: \"cmt-bool\"\n}, {\n  tag: tags.url,\n  class: \"cmt-url\"\n}, {\n  tag: tags.labelName,\n  class: \"cmt-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"cmt-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"cmt-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"cmt-literal\"\n}, {\n  tag: tags.string,\n  class: \"cmt-string\"\n}, {\n  tag: tags.number,\n  class: \"cmt-number\"\n}, {\n  tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],\n  class: \"cmt-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"cmt-variableName\"\n}, {\n  tag: /*@__PURE__*/tags.local(tags.variableName),\n  class: \"cmt-variableName cmt-local\"\n}, {\n  tag: /*@__PURE__*/tags.definition(tags.variableName),\n  class: \"cmt-variableName cmt-definition\"\n}, {\n  tag: /*@__PURE__*/tags.special(tags.variableName),\n  class: \"cmt-variableName2\"\n}, {\n  tag: /*@__PURE__*/tags.definition(tags.propertyName),\n  class: \"cmt-propertyName cmt-definition\"\n}, {\n  tag: tags.typeName,\n  class: \"cmt-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"cmt-namespace\"\n}, {\n  tag: tags.className,\n  class: \"cmt-className\"\n}, {\n  tag: tags.macroName,\n  class: \"cmt-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"cmt-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"cmt-operator\"\n}, {\n  tag: tags.comment,\n  class: \"cmt-comment\"\n}, {\n  tag: tags.meta,\n  class: \"cmt-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"cmt-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"cmt-punctuation\"\n}]);\nexport { HighlightStyle, Tag, classHighlightStyle, defaultHighlightStyle, highlightTree, styleTags, tags };","map":null,"metadata":{},"sourceType":"module"}