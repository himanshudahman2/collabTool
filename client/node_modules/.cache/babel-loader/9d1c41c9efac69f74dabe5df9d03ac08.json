{"ast":null,"code":"import { EditorView, ViewPlugin, BlockType, PluginField, Direction } from '@codemirror/view';\nimport { RangeSet, RangeValue } from '@codemirror/rangeset';\nimport { MapMode, Facet, combineConfig } from '@codemirror/state';\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/\n\nclass GutterMarker extends RangeValue {\n  /**\n  @internal\n  */\n  compare(other) {\n    return this == other || this.constructor == other.constructor && this.eq(other);\n  }\n  /**\n  Compare this marker to another marker of the same type.\n  */\n\n\n  eq(other) {\n    return false;\n  }\n  /**\n  Called if the marker has a `toDOM` method and its representation\n  was removed from a gutter.\n  */\n\n\n  destroy(dom) {}\n\n}\n\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/\n\nconst gutterLineClass = /*@__PURE__*/Facet.define();\nconst defaults = {\n  class: \"\",\n  renderEmptyElements: false,\n  elementStyle: \"\",\n  markers: () => RangeSet.empty,\n  lineMarker: () => null,\n  lineMarkerChange: null,\n  initialSpacer: null,\n  updateSpacer: null,\n  domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/\n\nfunction gutter(config) {\n  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-gutters\": {\n    display: \"flex\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    left: 0,\n    zIndex: 200\n  },\n  \"&light .cm-gutters\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"#999\",\n    borderRight: \"1px solid #ddd\"\n  },\n  \"&dark .cm-gutters\": {\n    backgroundColor: \"#333338\",\n    color: \"#ccc\"\n  },\n  \".cm-gutter\": {\n    display: \"flex !important\",\n    flexDirection: \"column\",\n    flexShrink: 0,\n    boxSizing: \"border-box\",\n    minHeight: \"100%\",\n    overflow: \"hidden\"\n  },\n  \".cm-gutterElement\": {\n    boxSizing: \"border-box\"\n  },\n  \".cm-lineNumbers .cm-gutterElement\": {\n    padding: \"0 3px 0 5px\",\n    minWidth: \"20px\",\n    textAlign: \"right\",\n    whiteSpace: \"nowrap\"\n  },\n  \"&light .cm-activeLineGutter\": {\n    backgroundColor: \"#e2f2ff\"\n  },\n  \"&dark .cm-activeLineGutter\": {\n    backgroundColor: \"#222227\"\n  }\n});\nconst unfixGutters = /*@__PURE__*/Facet.define({\n  combine: values => values.some(x => x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/\n\nfunction gutters(config) {\n  let result = [gutterView, baseTheme];\n  if (config && config.fixed === false) result.push(unfixGutters.of(true));\n  return result;\n}\n\nconst gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.prevViewport = view.viewport;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutters\";\n    this.dom.setAttribute(\"aria-hidden\", \"true\");\n    this.dom.style.minHeight = this.view.contentHeight + \"px\";\n    this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n\n    for (let gutter of this.gutters) this.dom.appendChild(gutter.dom);\n\n    this.fixed = !view.state.facet(unfixGutters);\n\n    if (this.fixed) {\n      // FIXME IE11 fallback, which doesn't support position: sticky,\n      // by using position: relative + event handlers that realign the\n      // gutter (or just force fixed=false on IE11?)\n      this.dom.style.position = \"sticky\";\n    }\n\n    this.syncGutters(false);\n    view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n  }\n\n  update(update) {\n    if (this.updateGutters(update)) {\n      // Detach during sync when the viewport changed significantly\n      // (such as during scrolling), since for large updates that is\n      // faster.\n      let vpA = this.prevViewport,\n          vpB = update.view.viewport;\n      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n    }\n\n    if (update.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + \"px\";\n\n    if (this.view.state.facet(unfixGutters) != !this.fixed) {\n      this.fixed = !this.fixed;\n      this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n    }\n\n    this.prevViewport = update.view.viewport;\n  }\n\n  syncGutters(detach) {\n    let after = this.dom.nextSibling;\n    if (detach) this.dom.remove();\n    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n    let classSet = [];\n    let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n\n    for (let line of this.view.viewportLineBlocks) {\n      let text;\n\n      if (Array.isArray(line.type)) {\n        for (let b of line.type) if (b.type == BlockType.Text) {\n          text = b;\n          break;\n        }\n      } else {\n        text = line.type == BlockType.Text ? line : undefined;\n      }\n\n      if (!text) continue;\n      if (classSet.length) classSet = [];\n      advanceCursor(lineClasses, classSet, line.from);\n\n      for (let cx of contexts) cx.line(this.view, text, classSet);\n    }\n\n    for (let cx of contexts) cx.finish();\n\n    if (detach) this.view.scrollDOM.insertBefore(this.dom, after);\n  }\n\n  updateGutters(update) {\n    let prev = update.startState.facet(activeGutters),\n        cur = update.state.facet(activeGutters);\n    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n\n    if (prev == cur) {\n      for (let gutter of this.gutters) if (gutter.update(update)) change = true;\n    } else {\n      change = true;\n      let gutters = [];\n\n      for (let conf of cur) {\n        let known = prev.indexOf(conf);\n\n        if (known < 0) {\n          gutters.push(new SingleGutterView(this.view, conf));\n        } else {\n          this.gutters[known].update(update);\n          gutters.push(this.gutters[known]);\n        }\n      }\n\n      for (let g of this.gutters) {\n        g.dom.remove();\n        if (gutters.indexOf(g) < 0) g.destroy();\n      }\n\n      for (let g of gutters) this.dom.appendChild(g.dom);\n\n      this.gutters = gutters;\n    }\n\n    return change;\n  }\n\n  destroy() {\n    for (let view of this.gutters) view.destroy();\n\n    this.dom.remove();\n  }\n\n}, {\n  provide: /*@__PURE__*/PluginField.scrollMargins.from(value => {\n    if (value.gutters.length == 0 || !value.fixed) return null;\n    return value.view.textDirection == Direction.LTR ? {\n      left: value.dom.offsetWidth\n    } : {\n      right: value.dom.offsetWidth\n    };\n  })\n});\n\nfunction asArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\n\nfunction advanceCursor(cursor, collect, pos) {\n  while (cursor.value && cursor.from <= pos) {\n    if (cursor.from == pos) collect.push(cursor.value);\n    cursor.next();\n  }\n}\n\nclass UpdateContext {\n  constructor(gutter, viewport, height) {\n    this.gutter = gutter;\n    this.height = height;\n    this.localMarkers = [];\n    this.i = 0;\n    this.cursor = RangeSet.iter(gutter.markers, viewport.from);\n  }\n\n  line(view, line, extraMarkers) {\n    if (this.localMarkers.length) this.localMarkers = [];\n    advanceCursor(this.cursor, this.localMarkers, line.from);\n    let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;\n    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n    if (forLine) localMarkers.unshift(forLine);\n    let gutter = this.gutter;\n    if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n    let above = line.top - this.height;\n\n    if (this.i == gutter.elements.length) {\n      let newElt = new GutterElement(view, line.height, above, localMarkers);\n      gutter.elements.push(newElt);\n      gutter.dom.appendChild(newElt.dom);\n    } else {\n      gutter.elements[this.i].update(view, line.height, above, localMarkers);\n    }\n\n    this.height = line.bottom;\n    this.i++;\n  }\n\n  finish() {\n    let gutter = this.gutter;\n\n    while (gutter.elements.length > this.i) {\n      let last = gutter.elements.pop();\n      gutter.dom.removeChild(last.dom);\n      last.destroy();\n    }\n  }\n\n}\n\nclass SingleGutterView {\n  constructor(view, config) {\n    this.view = view;\n    this.config = config;\n    this.elements = [];\n    this.spacer = null;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n\n    for (let prop in config.domEventHandlers) {\n      this.dom.addEventListener(prop, event => {\n        let line = view.lineBlockAtHeight(event.clientY - view.documentTop);\n        if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n      });\n    }\n\n    this.markers = asArray(config.markers(view));\n\n    if (config.initialSpacer) {\n      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\n      this.dom.appendChild(this.spacer.dom);\n      this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n    }\n  }\n\n  update(update) {\n    let prevMarkers = this.markers;\n    this.markers = asArray(this.config.markers(update.view));\n\n    if (this.spacer && this.config.updateSpacer) {\n      let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n      if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [updated]);\n    }\n\n    let vp = update.view.viewport;\n    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n  }\n\n  destroy() {\n    for (let elt of this.elements) elt.destroy();\n  }\n\n}\n\nclass GutterElement {\n  constructor(view, height, above, markers) {\n    this.height = -1;\n    this.above = 0;\n    this.markers = [];\n    this.dom = document.createElement(\"div\");\n    this.update(view, height, above, markers);\n  }\n\n  update(view, height, above, markers) {\n    if (this.height != height) this.dom.style.height = (this.height = height) + \"px\";\n    if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n    if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n  }\n\n  setMarkers(view, markers) {\n    let cls = \"cm-gutterElement\",\n        domPos = this.dom.firstChild;\n\n    for (let iNew = 0, iOld = 0;;) {\n      let skipTo = iOld,\n          marker = iNew < markers.length ? markers[iNew++] : null,\n          matched = false;\n\n      if (marker) {\n        let c = marker.elementClass;\n        if (c) cls += \" \" + c;\n\n        for (let i = iOld; i < this.markers.length; i++) if (this.markers[i].compare(marker)) {\n          skipTo = i;\n          matched = true;\n          break;\n        }\n      } else {\n        skipTo = this.markers.length;\n      }\n\n      while (iOld < skipTo) {\n        let next = this.markers[iOld++];\n\n        if (next.toDOM) {\n          next.destroy(domPos);\n          let after = domPos.nextSibling;\n          domPos.remove();\n          domPos = after;\n        }\n      }\n\n      if (!marker) break;\n\n      if (marker.toDOM) {\n        if (matched) domPos = domPos.nextSibling;else this.dom.insertBefore(marker.toDOM(view), domPos);\n      }\n\n      if (matched) iOld++;\n    }\n\n    this.dom.className = cls;\n    this.markers = markers;\n  }\n\n  destroy() {\n    this.setMarkers(null, []); // First argument not used unless creating markers\n  }\n\n}\n\nfunction sameMarkers(a, b) {\n  if (a.length != b.length) return false;\n\n  for (let i = 0; i < a.length; i++) if (!a[i].compare(b[i])) return false;\n\n  return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/\n\n\nconst lineNumberMarkers = /*@__PURE__*/Facet.define();\nconst lineNumberConfig = /*@__PURE__*/Facet.define({\n  combine(values) {\n    return combineConfig(values, {\n      formatNumber: String,\n      domEventHandlers: {}\n    }, {\n      domEventHandlers(a, b) {\n        let result = Object.assign({}, a);\n\n        for (let event in b) {\n          let exists = result[event],\n              add = b[event];\n          result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n        }\n\n        return result;\n      }\n\n    });\n  }\n\n});\n\nclass NumberMarker extends GutterMarker {\n  constructor(number) {\n    super();\n    this.number = number;\n  }\n\n  eq(other) {\n    return this.number == other.number;\n  }\n\n  toDOM() {\n    return document.createTextNode(this.number);\n  }\n\n}\n\nfunction formatNumber(view, number) {\n  return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\n\nconst lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({\n  class: \"cm-lineNumbers\",\n  renderEmptyElements: false,\n\n  markers(view) {\n    return view.state.facet(lineNumberMarkers);\n  },\n\n  lineMarker(view, line, others) {\n    if (others.some(m => m.toDOM)) return null;\n    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n  },\n\n  lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n\n  initialSpacer(view) {\n    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n  },\n\n  updateSpacer(spacer, update) {\n    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n    return max == spacer.number ? spacer : new NumberMarker(max);\n  },\n\n  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n}));\n/**\nCreate a line number gutter extension.\n*/\n\nfunction lineNumbers() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [lineNumberConfig.of(config), gutters(), lineNumberGutter];\n}\n\nfunction maxLineNumber(lines) {\n  let last = 9;\n\n  while (last < lines) last = last * 10 + 9;\n\n  return last;\n}\n\nconst activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {\n  constructor() {\n    super(...arguments);\n    this.elementClass = \"cm-activeLineGutter\";\n  }\n\n}();\nconst activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([\"selection\"], state => {\n  let marks = [],\n      last = -1;\n\n  for (let range of state.selection.ranges) if (range.empty) {\n    let linePos = state.doc.lineAt(range.head).from;\n\n    if (linePos > last) {\n      last = linePos;\n      marks.push(activeLineGutterMarker.range(linePos));\n    }\n  }\n\n  return RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/\n\nfunction highlightActiveLineGutter() {\n  return activeLineGutterHighlighter;\n}\n\nexport { GutterMarker, gutter, gutterLineClass, gutters, highlightActiveLineGutter, lineNumberMarkers, lineNumbers };","map":null,"metadata":{},"sourceType":"module"}