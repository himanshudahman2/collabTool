{"ast":null,"code":"import { EditorSelection, CharCategory } from '@codemirror/state';\nimport { Text, findClusterBreak, countColumn } from '@codemirror/text';\nimport { Direction, EditorView, PluginField } from '@codemirror/view';\nimport { matchBrackets } from '@codemirror/matchbrackets';\nimport { IndentContext, getIndentation, indentString, indentUnit, getIndentUnit, syntaxTree } from '@codemirror/language';\nimport { NodeProp } from '@lezer/common';\n\nfunction updateSel(sel, by) {\n  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\n\nfunction setSel(state, selection) {\n  return state.update({\n    selection,\n    scrollIntoView: true,\n    userEvent: \"select\"\n  });\n}\n\nfunction moveSel(_ref, how) {\n  let {\n    state,\n    dispatch\n  } = _ref;\n  let selection = updateSel(state.selection, how);\n  if (selection.eq(state.selection)) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n\nfunction rangeEnd(range, forward) {\n  return EditorSelection.cursor(forward ? range.to : range.from);\n}\n\nfunction cursorByChar(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\n\n\nconst cursorCharLeft = view => cursorByChar(view, view.textDirection != Direction.LTR);\n/**\nMove the selection one character to the right.\n*/\n\n\nconst cursorCharRight = view => cursorByChar(view, view.textDirection == Direction.LTR);\n/**\nMove the selection one character forward.\n*/\n\n\nconst cursorCharForward = view => cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/\n\n\nconst cursorCharBackward = view => cursorByChar(view, false);\n\nfunction cursorByGroup(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\n\n\nconst cursorGroupLeft = view => cursorByGroup(view, view.textDirection != Direction.LTR);\n/**\nMove the selection one group to the right.\n*/\n\n\nconst cursorGroupRight = view => cursorByGroup(view, view.textDirection == Direction.LTR);\n/**\nMove the selection one group forward.\n*/\n\n\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/\n\n\nconst cursorGroupBackward = view => cursorByGroup(view, false);\n\nfunction moveBySubword(view, range, forward) {\n  let categorize = view.state.charCategorizer(range.from);\n  return view.moveByChar(range, forward, start => {\n    let cat = CharCategory.Space,\n        pos = range.from;\n    let done = false,\n        sawUpper = false,\n        sawLower = false;\n\n    let step = next => {\n      if (done) return false;\n      pos += forward ? next.length : -next.length;\n      let nextCat = categorize(next),\n          ahead;\n      if (cat == CharCategory.Space) cat = nextCat;\n      if (cat != nextCat) return false;\n\n      if (cat == CharCategory.Word) {\n        if (next.toLowerCase() == next) {\n          if (!forward && sawUpper) return false;\n          sawLower = true;\n        } else if (sawLower) {\n          if (forward) return false;\n          done = true;\n        } else {\n          if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n          sawUpper = true;\n        }\n      }\n\n      return true;\n    };\n\n    step(start);\n    return step;\n  });\n}\n\nfunction cursorBySubword(view, forward) {\n  return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\n\n\nconst cursorSubwordForward = view => cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/\n\n\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\n\nfunction interestingNode(state, node, bracketProp) {\n  if (node.type.prop(bracketProp)) return true;\n  let len = node.to - node.from;\n  return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\n\nfunction moveBySyntax(state, start, forward) {\n  let pos = syntaxTree(state).resolveInner(start.head);\n  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy; // Scan forward through child nodes to see if there's an interesting\n  // node ahead.\n\n  for (let at = start.head;;) {\n    let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n    if (!next) break;\n    if (interestingNode(state, next, bracketProp)) pos = next;else at = forward ? next.to : next.from;\n  }\n\n  let bracket = pos.type.prop(bracketProp),\n      match,\n      newPos;\n  if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;else newPos = forward ? pos.to : pos.from;\n  return EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\n\n\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection != Direction.LTR));\n/**\nMove the cursor over the next syntactic element to the right.\n*/\n\n\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection == Direction.LTR));\n\nfunction cursorByLine(view, forward) {\n  return moveSel(view, range => {\n    if (!range.empty) return rangeEnd(range, forward);\n    let moved = view.moveVertically(range, forward);\n    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n  });\n}\n/**\nMove the selection one line up.\n*/\n\n\nconst cursorLineUp = view => cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/\n\n\nconst cursorLineDown = view => cursorByLine(view, true);\n\nfunction cursorByPage(view, forward) {\n  let {\n    state\n  } = view,\n      selection = updateSel(state.selection, range => {\n    return range.empty ? view.moveVertically(range, forward, view.dom.clientHeight) : rangeEnd(range, forward);\n  });\n  if (selection.eq(state.selection)) return false;\n  let startPos = view.coordsAtPos(state.selection.main.head);\n  let scrollRect = view.scrollDOM.getBoundingClientRect();\n  view.dispatch(setSel(state, selection), {\n    effects: startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom ? EditorView.scrollIntoView(selection.main.head, {\n      y: \"start\",\n      yMargin: startPos.top - scrollRect.top\n    }) : undefined\n  });\n  return true;\n}\n/**\nMove the selection one page up.\n*/\n\n\nconst cursorPageUp = view => cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/\n\n\nconst cursorPageDown = view => cursorByPage(view, true);\n\nfunction moveByLineBoundary(view, start, forward) {\n  let line = view.lineBlockAt(start.head),\n      moved = view.moveToLineBoundary(start, forward);\n  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n\n  if (!forward && moved.head == line.from && line.length) {\n    let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n    if (space && start.head != line.from + space) moved = EditorSelection.cursor(line.from + space);\n  }\n\n  return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\n\n\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\n\n\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection to the start of the line.\n*/\n\n\nconst cursorLineStart = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/\n\n\nconst cursorLineEnd = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\n\nfunction toMatchingBracket(state, dispatch, extend) {\n  let found = false,\n      selection = updateSel(state.selection, range => {\n    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);\n    if (!matching || !matching.end) return range;\n    found = true;\n    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);\n  });\n  if (!found) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\n\n\nconst cursorMatchingBracket = _ref2 => {\n  let {\n    state,\n    dispatch\n  } = _ref2;\n  return toMatchingBracket(state, dispatch, false);\n};\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\n\n\nconst selectMatchingBracket = _ref3 => {\n  let {\n    state,\n    dispatch\n  } = _ref3;\n  return toMatchingBracket(state, dispatch, true);\n};\n\nfunction extendSel(view, how) {\n  let selection = updateSel(view.state.selection, range => {\n    let head = how(range);\n    return EditorSelection.range(range.anchor, head.head, head.goalColumn);\n  });\n  if (selection.eq(view.state.selection)) return false;\n  view.dispatch(setSel(view.state, selection));\n  return true;\n}\n\nfunction selectByChar(view, forward) {\n  return extendSel(view, range => view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\n\n\nconst selectCharLeft = view => selectByChar(view, view.textDirection != Direction.LTR);\n/**\nMove the selection head one character to the right.\n*/\n\n\nconst selectCharRight = view => selectByChar(view, view.textDirection == Direction.LTR);\n/**\nMove the selection head one character forward.\n*/\n\n\nconst selectCharForward = view => selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/\n\n\nconst selectCharBackward = view => selectByChar(view, false);\n\nfunction selectByGroup(view, forward) {\n  return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\n\n\nconst selectGroupLeft = view => selectByGroup(view, view.textDirection != Direction.LTR);\n/**\nMove the selection head one group to the right.\n*/\n\n\nconst selectGroupRight = view => selectByGroup(view, view.textDirection == Direction.LTR);\n/**\nMove the selection head one group forward.\n*/\n\n\nconst selectGroupForward = view => selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/\n\n\nconst selectGroupBackward = view => selectByGroup(view, false);\n\nfunction selectBySubword(view, forward) {\n  return extendSel(view, range => moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\n\n\nconst selectSubwordForward = view => selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/\n\n\nconst selectSubwordBackward = view => selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/\n\n\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection != Direction.LTR));\n/**\nMove the selection head over the next syntactic element to the right.\n*/\n\n\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection == Direction.LTR));\n\nfunction selectByLine(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/\n\n\nconst selectLineUp = view => selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/\n\n\nconst selectLineDown = view => selectByLine(view, true);\n\nfunction selectByPage(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward, view.dom.clientHeight));\n}\n/**\nMove the selection head one page up.\n*/\n\n\nconst selectPageUp = view => selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/\n\n\nconst selectPageDown = view => selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/\n\n\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/\n\n\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection head to the start of the line.\n*/\n\n\nconst selectLineStart = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/\n\n\nconst selectLineEnd = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/\n\n\nconst cursorDocStart = _ref4 => {\n  let {\n    state,\n    dispatch\n  } = _ref4;\n  dispatch(setSel(state, {\n    anchor: 0\n  }));\n  return true;\n};\n/**\nMove the selection to the end of the document.\n*/\n\n\nconst cursorDocEnd = _ref5 => {\n  let {\n    state,\n    dispatch\n  } = _ref5;\n  dispatch(setSel(state, {\n    anchor: state.doc.length\n  }));\n  return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\n\n\nconst selectDocStart = _ref6 => {\n  let {\n    state,\n    dispatch\n  } = _ref6;\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: 0\n  }));\n  return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\n\n\nconst selectDocEnd = _ref7 => {\n  let {\n    state,\n    dispatch\n  } = _ref7;\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: state.doc.length\n  }));\n  return true;\n};\n/**\nSelect the entire document.\n*/\n\n\nconst selectAll = _ref8 => {\n  let {\n    state,\n    dispatch\n  } = _ref8;\n  dispatch(state.update({\n    selection: {\n      anchor: 0,\n      head: state.doc.length\n    },\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\n\n\nconst selectLine = _ref9 => {\n  let {\n    state,\n    dispatch\n  } = _ref9;\n  let ranges = selectedLineBlocks(state).map(_ref10 => {\n    let {\n      from,\n      to\n    } = _ref10;\n    return EditorSelection.range(from, Math.min(to + 1, state.doc.length));\n  });\n  dispatch(state.update({\n    selection: EditorSelection.create(ranges),\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\n\n\nconst selectParentSyntax = _ref11 => {\n  let {\n    state,\n    dispatch\n  } = _ref11;\n  let selection = updateSel(state.selection, range => {\n    var _a;\n\n    let context = syntaxTree(state).resolveInner(range.head, 1);\n\n    while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent))) context = context.parent;\n\n    return EditorSelection.range(context.to, context.from);\n  });\n  dispatch(setSel(state, selection));\n  return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\n\n\nconst simplifySelection = _ref12 => {\n  let {\n    state,\n    dispatch\n  } = _ref12;\n  let cur = state.selection,\n      selection = null;\n  if (cur.ranges.length > 1) selection = EditorSelection.create([cur.main]);else if (!cur.main.empty) selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);\n  if (!selection) return false;\n  dispatch(setSel(state, selection));\n  return true;\n};\n\nfunction deleteBy(_ref13, by) {\n  let {\n    state,\n    dispatch\n  } = _ref13;\n  if (state.readOnly) return false;\n  let event = \"delete.selection\";\n  let changes = state.changeByRange(range => {\n    let {\n      from,\n      to\n    } = range;\n\n    if (from == to) {\n      let towards = by(from);\n      if (towards < from) event = \"delete.backward\";else if (towards > from) event = \"delete.forward\";\n      from = Math.min(from, towards);\n      to = Math.max(to, towards);\n    }\n\n    return from == to ? {\n      range\n    } : {\n      changes: {\n        from,\n        to\n      },\n      range: EditorSelection.cursor(from)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: event\n  }));\n  return true;\n}\n\nfunction skipAtomic(target, pos, forward) {\n  if (target instanceof EditorView) for (let ranges of target.pluginField(PluginField.atomicRanges)) ranges.between(pos, pos, (from, to) => {\n    if (from < pos && to > pos) pos = forward ? to : from;\n  });\n  return pos;\n}\n\nconst deleteByChar = (target, forward) => deleteBy(target, pos => {\n  let {\n    state\n  } = target,\n      line = state.doc.lineAt(pos),\n      before,\n      targetPos;\n\n  if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n    if (before[before.length - 1] == \"\\t\") return pos - 1;\n    let col = countColumn(before, state.tabSize),\n        drop = col % getIndentUnit(state) || getIndentUnit(state);\n\n    for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++) pos--;\n\n    targetPos = pos;\n  } else {\n    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;\n    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n  }\n\n  return skipAtomic(target, targetPos, forward);\n});\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/\n\n\nconst deleteCharBackward = view => deleteByChar(view, false);\n/**\nDelete the selection or the character after the cursor.\n*/\n\n\nconst deleteCharForward = view => deleteByChar(view, true);\n\nconst deleteByGroup = (target, forward) => deleteBy(target, start => {\n  let pos = start,\n      {\n    state\n  } = target,\n      line = state.doc.lineAt(pos);\n  let categorize = state.charCategorizer(pos);\n\n  for (let cat = null;;) {\n    if (pos == (forward ? line.to : line.from)) {\n      if (pos == start && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n      break;\n    }\n\n    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;\n    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n    let nextCat = categorize(nextChar);\n    if (cat != null && nextCat != cat) break;\n    if (nextChar != \" \" || pos != start) cat = nextCat;\n    pos = next;\n  }\n\n  return skipAtomic(target, pos, forward);\n});\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\n\n\nconst deleteGroupBackward = target => deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/\n\n\nconst deleteGroupForward = target => deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\n\n\nconst deleteToLineEnd = view => deleteBy(view, pos => {\n  let lineEnd = view.lineBlockAt(pos).to;\n  return skipAtomic(view, pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1), true);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\n\n\nconst deleteToLineStart = view => deleteBy(view, pos => {\n  let lineStart = view.lineBlockAt(pos).from;\n  return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);\n});\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\n\n\nconst deleteTrailingWhitespace = _ref14 => {\n  let {\n    state,\n    dispatch\n  } = _ref14;\n  if (state.readOnly) return false;\n  let changes = [];\n\n  for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n    iter.next();\n\n    if (iter.lineBreak || iter.done) {\n      let trailing = prev.search(/\\s+$/);\n      if (trailing > -1) changes.push({\n        from: pos - (prev.length - trailing),\n        to: pos\n      });\n      if (iter.done) break;\n      prev = \"\";\n    } else {\n      prev = iter.value;\n    }\n\n    pos += iter.value.length;\n  }\n\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes,\n    userEvent: \"delete\"\n  }));\n  return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\n\n\nconst splitLine = _ref15 => {\n  let {\n    state,\n    dispatch\n  } = _ref15;\n  if (state.readOnly) return false;\n  let changes = state.changeByRange(range => {\n    return {\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: Text.of([\"\", \"\"])\n      },\n      range: EditorSelection.cursor(range.from)\n    };\n  });\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\n\n\nconst transposeChars = _ref16 => {\n  let {\n    state,\n    dispatch\n  } = _ref16;\n  if (state.readOnly) return false;\n  let changes = state.changeByRange(range => {\n    if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n      range\n    };\n    let pos = range.from,\n        line = state.doc.lineAt(pos);\n    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;\n    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;\n    return {\n      changes: {\n        from,\n        to,\n        insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n      },\n      range: EditorSelection.cursor(to)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"move.character\"\n  }));\n  return true;\n};\n\nfunction selectedLineBlocks(state) {\n  let blocks = [],\n      upto = -1;\n\n  for (let range of state.selection.ranges) {\n    let startLine = state.doc.lineAt(range.from),\n        endLine = state.doc.lineAt(range.to);\n    if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n\n    if (upto >= startLine.number) {\n      let prev = blocks[blocks.length - 1];\n      prev.to = endLine.to;\n      prev.ranges.push(range);\n    } else {\n      blocks.push({\n        from: startLine.from,\n        to: endLine.to,\n        ranges: [range]\n      });\n    }\n\n    upto = endLine.number + 1;\n  }\n\n  return blocks;\n}\n\nfunction moveLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  let changes = [],\n      ranges = [];\n\n  for (let block of selectedLineBlocks(state)) {\n    if (forward ? block.to == state.doc.length : block.from == 0) continue;\n    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n    let size = nextLine.length + 1;\n\n    if (forward) {\n      changes.push({\n        from: block.to,\n        to: nextLine.to\n      }, {\n        from: block.from,\n        insert: nextLine.text + state.lineBreak\n      });\n\n      for (let r of block.ranges) ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n    } else {\n      changes.push({\n        from: nextLine.from,\n        to: block.from\n      }, {\n        from: block.to,\n        insert: state.lineBreak + nextLine.text\n      });\n\n      for (let r of block.ranges) ranges.push(EditorSelection.range(r.anchor - size, r.head - size));\n    }\n  }\n\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true,\n    selection: EditorSelection.create(ranges, state.selection.mainIndex),\n    userEvent: \"move.line\"\n  }));\n  return true;\n}\n/**\nMove the selected lines up one line.\n*/\n\n\nconst moveLineUp = _ref17 => {\n  let {\n    state,\n    dispatch\n  } = _ref17;\n  return moveLine(state, dispatch, false);\n};\n/**\nMove the selected lines down one line.\n*/\n\n\nconst moveLineDown = _ref18 => {\n  let {\n    state,\n    dispatch\n  } = _ref18;\n  return moveLine(state, dispatch, true);\n};\n\nfunction copyLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  let changes = [];\n\n  for (let block of selectedLineBlocks(state)) {\n    if (forward) changes.push({\n      from: block.from,\n      insert: state.doc.slice(block.from, block.to) + state.lineBreak\n    });else changes.push({\n      from: block.to,\n      insert: state.lineBreak + state.doc.slice(block.from, block.to)\n    });\n  }\n\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true,\n    userEvent: \"input.copyline\"\n  }));\n  return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\n\n\nconst copyLineUp = _ref19 => {\n  let {\n    state,\n    dispatch\n  } = _ref19;\n  return copyLine(state, dispatch, false);\n};\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\n\n\nconst copyLineDown = _ref20 => {\n  let {\n    state,\n    dispatch\n  } = _ref20;\n  return copyLine(state, dispatch, true);\n};\n/**\nDelete selected lines.\n*/\n\n\nconst deleteLine = view => {\n  if (view.state.readOnly) return false;\n  let {\n    state\n  } = view,\n      changes = state.changes(selectedLineBlocks(state).map(_ref21 => {\n    let {\n      from,\n      to\n    } = _ref21;\n    if (from > 0) from--;else if (to < state.doc.length) to++;\n    return {\n      from,\n      to\n    };\n  }));\n  let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\n  view.dispatch({\n    changes,\n    selection,\n    scrollIntoView: true,\n    userEvent: \"delete.line\"\n  });\n  return true;\n};\n/**\nReplace the selection with a newline.\n*/\n\n\nconst insertNewline = _ref22 => {\n  let {\n    state,\n    dispatch\n  } = _ref22;\n  dispatch(state.update(state.replaceSelection(state.lineBreak), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n\nfunction isBetweenBrackets(state, pos) {\n  if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n    from: pos,\n    to: pos\n  };\n  let context = syntaxTree(state).resolveInner(pos);\n  let before = context.childBefore(pos),\n      after = context.childAfter(pos),\n      closedBy;\n  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from) return {\n    from: before.to,\n    to: after.from\n  };\n  return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\n\n\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\n\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\n\nfunction newlineAndIndent(atEof) {\n  return _ref23 => {\n    let {\n      state,\n      dispatch\n    } = _ref23;\n    if (state.readOnly) return false;\n    let changes = state.changeByRange(range => {\n      let {\n        from,\n        to\n      } = range,\n          line = state.doc.lineAt(from);\n      let explode = !atEof && from == to && isBetweenBrackets(state, from);\n      if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n      let cx = new IndentContext(state, {\n        simulateBreak: from,\n        simulateDoubleBreak: !!explode\n      });\n      let indent = getIndentation(cx, from);\n      if (indent == null) indent = /^\\s*/.exec(state.doc.lineAt(from).text)[0].length;\n\n      while (to < line.to && /\\s/.test(line.text[to - line.from])) to++;\n\n      if (explode) ({\n        from,\n        to\n      } = explode);else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n      let insert = [\"\", indentString(state, indent)];\n      if (explode) insert.push(indentString(state, cx.lineIndent(line.from, -1)));\n      return {\n        changes: {\n          from,\n          to,\n          insert: Text.of(insert)\n        },\n        range: EditorSelection.cursor(from + 1 + insert[1].length)\n      };\n    });\n    dispatch(state.update(changes, {\n      scrollIntoView: true,\n      userEvent: \"input\"\n    }));\n    return true;\n  };\n}\n\nfunction changeBySelectedLine(state, f) {\n  let atLine = -1;\n  return state.changeByRange(range => {\n    let changes = [];\n\n    for (let pos = range.from; pos <= range.to;) {\n      let line = state.doc.lineAt(pos);\n\n      if (line.number > atLine && (range.empty || range.to > line.from)) {\n        f(line, changes, range);\n        atLine = line.number;\n      }\n\n      pos = line.to + 1;\n    }\n\n    let changeSet = state.changes(changes);\n    return {\n      changes,\n      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n    };\n  });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\n\n\nconst indentSelection = _ref24 => {\n  let {\n    state,\n    dispatch\n  } = _ref24;\n  if (state.readOnly) return false;\n  let updated = Object.create(null);\n  let context = new IndentContext(state, {\n    overrideIndentation: start => {\n      let found = updated[start];\n      return found == null ? -1 : found;\n    }\n  });\n  let changes = changeBySelectedLine(state, (line, changes, range) => {\n    let indent = getIndentation(context, line.from);\n    if (indent == null) return;\n    if (!/\\S/.test(line.text)) indent = 0;\n    let cur = /^\\s*/.exec(line.text)[0];\n    let norm = indentString(state, indent);\n\n    if (cur != norm || range.from < line.from + cur.length) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  });\n  if (!changes.changes.empty) dispatch(state.update(changes, {\n    userEvent: \"indent\"\n  }));\n  return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\n\n\nconst indentMore = _ref25 => {\n  let {\n    state,\n    dispatch\n  } = _ref25;\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    changes.push({\n      from: line.from,\n      insert: state.facet(indentUnit)\n    });\n  }), {\n    userEvent: \"input.indent\"\n  }));\n  return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\n\n\nconst indentLess = _ref26 => {\n  let {\n    state,\n    dispatch\n  } = _ref26;\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    let space = /^\\s*/.exec(line.text)[0];\n    if (!space) return;\n    let col = countColumn(space, state.tabSize),\n        keep = 0;\n    let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));\n\n    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) keep++;\n\n    changes.push({\n      from: line.from + keep,\n      to: line.from + space.length,\n      insert: insert.slice(keep)\n    });\n  }), {\n    userEvent: \"delete.dedent\"\n  }));\n  return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\n\n\nconst insertTab = _ref27 => {\n  let {\n    state,\n    dispatch\n  } = _ref27;\n  if (state.selection.ranges.some(r => !r.empty)) return indentMore({\n    state,\n    dispatch\n  });\n  dispatch(state.update(state.replaceSelection(\"\\t\"), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\n\n\nconst emacsStyleKeymap = [{\n  key: \"Ctrl-b\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Ctrl-f\",\n  run: cursorCharRight,\n  shift: selectCharRight\n}, {\n  key: \"Ctrl-p\",\n  run: cursorLineUp,\n  shift: selectLineUp\n}, {\n  key: \"Ctrl-n\",\n  run: cursorLineDown,\n  shift: selectLineDown\n}, {\n  key: \"Ctrl-a\",\n  run: cursorLineStart,\n  shift: selectLineStart\n}, {\n  key: \"Ctrl-e\",\n  run: cursorLineEnd,\n  shift: selectLineEnd\n}, {\n  key: \"Ctrl-d\",\n  run: deleteCharForward\n}, {\n  key: \"Ctrl-h\",\n  run: deleteCharBackward\n}, {\n  key: \"Ctrl-k\",\n  run: deleteToLineEnd\n}, {\n  key: \"Ctrl-Alt-h\",\n  run: deleteGroupBackward\n}, {\n  key: \"Ctrl-o\",\n  run: splitLine\n}, {\n  key: \"Ctrl-t\",\n  run: transposeChars\n}, {\n  key: \"Ctrl-v\",\n  run: cursorPageDown\n}];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).\n - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).\n*/\n\nconst standardKeymap = /*@__PURE__*/[{\n  key: \"ArrowLeft\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowLeft\",\n  mac: \"Alt-ArrowLeft\",\n  run: cursorGroupLeft,\n  shift: selectGroupLeft\n}, {\n  mac: \"Cmd-ArrowLeft\",\n  run: cursorLineBoundaryBackward,\n  shift: selectLineBoundaryBackward\n}, {\n  key: \"ArrowRight\",\n  run: cursorCharRight,\n  shift: selectCharRight,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowRight\",\n  mac: \"Alt-ArrowRight\",\n  run: cursorGroupRight,\n  shift: selectGroupRight\n}, {\n  mac: \"Cmd-ArrowRight\",\n  run: cursorLineBoundaryForward,\n  shift: selectLineBoundaryForward\n}, {\n  key: \"ArrowUp\",\n  run: cursorLineUp,\n  shift: selectLineUp,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowUp\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  mac: \"Ctrl-ArrowUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"ArrowDown\",\n  run: cursorLineDown,\n  shift: selectLineDown,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowDown\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  mac: \"Ctrl-ArrowDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"PageUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"PageDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"Home\",\n  run: cursorLineBoundaryBackward,\n  shift: selectLineBoundaryBackward\n}, {\n  key: \"Mod-Home\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  key: \"End\",\n  run: cursorLineBoundaryForward,\n  shift: selectLineBoundaryForward\n}, {\n  key: \"Mod-End\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  key: \"Enter\",\n  run: insertNewlineAndIndent\n}, {\n  key: \"Mod-a\",\n  run: selectAll\n}, {\n  key: \"Backspace\",\n  run: deleteCharBackward,\n  shift: deleteCharBackward\n}, {\n  key: \"Delete\",\n  run: deleteCharForward\n}, {\n  key: \"Mod-Backspace\",\n  mac: \"Alt-Backspace\",\n  run: deleteGroupBackward\n}, {\n  key: \"Mod-Delete\",\n  mac: \"Alt-Delete\",\n  run: deleteGroupForward\n}, {\n  mac: \"Mod-Backspace\",\n  run: deleteToLineStart\n}, {\n  mac: \"Mod-Delete\",\n  run: deleteToLineEnd\n}].concat( /*@__PURE__*/emacsStyleKeymap.map(b => ({\n  mac: b.key,\n  run: b.run,\n  shift: b.shift\n})));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Comd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n*/\n\nconst defaultKeymap = /*@__PURE__*/[{\n  key: \"Alt-ArrowLeft\",\n  mac: \"Ctrl-ArrowLeft\",\n  run: cursorSyntaxLeft,\n  shift: selectSyntaxLeft\n}, {\n  key: \"Alt-ArrowRight\",\n  mac: \"Ctrl-ArrowRight\",\n  run: cursorSyntaxRight,\n  shift: selectSyntaxRight\n}, {\n  key: \"Alt-ArrowUp\",\n  run: moveLineUp\n}, {\n  key: \"Shift-Alt-ArrowUp\",\n  run: copyLineUp\n}, {\n  key: \"Alt-ArrowDown\",\n  run: moveLineDown\n}, {\n  key: \"Shift-Alt-ArrowDown\",\n  run: copyLineDown\n}, {\n  key: \"Escape\",\n  run: simplifySelection\n}, {\n  key: \"Mod-Enter\",\n  run: insertBlankLine\n}, {\n  key: \"Alt-l\",\n  mac: \"Ctrl-l\",\n  run: selectLine\n}, {\n  key: \"Mod-i\",\n  run: selectParentSyntax,\n  preventDefault: true\n}, {\n  key: \"Mod-[\",\n  run: indentLess\n}, {\n  key: \"Mod-]\",\n  run: indentMore\n}, {\n  key: \"Mod-Alt-\\\\\",\n  run: indentSelection\n}, {\n  key: \"Shift-Mod-k\",\n  run: deleteLine\n}, {\n  key: \"Shift-Mod-\\\\\",\n  run: cursorMatchingBracket\n}].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\n\nconst indentWithTab = {\n  key: \"Tab\",\n  run: indentMore,\n  shift: indentLess\n};\nexport { copyLineDown, copyLineUp, cursorCharBackward, cursorCharForward, cursorCharLeft, cursorCharRight, cursorDocEnd, cursorDocStart, cursorGroupBackward, cursorGroupForward, cursorGroupLeft, cursorGroupRight, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorLineDown, cursorLineEnd, cursorLineStart, cursorLineUp, cursorMatchingBracket, cursorPageDown, cursorPageUp, cursorSubwordBackward, cursorSubwordForward, cursorSyntaxLeft, cursorSyntaxRight, defaultKeymap, deleteCharBackward, deleteCharForward, deleteGroupBackward, deleteGroupForward, deleteLine, deleteToLineEnd, deleteToLineStart, deleteTrailingWhitespace, emacsStyleKeymap, indentLess, indentMore, indentSelection, indentWithTab, insertBlankLine, insertNewline, insertNewlineAndIndent, insertTab, moveLineDown, moveLineUp, selectAll, selectCharBackward, selectCharForward, selectCharLeft, selectCharRight, selectDocEnd, selectDocStart, selectGroupBackward, selectGroupForward, selectGroupLeft, selectGroupRight, selectLine, selectLineBoundaryBackward, selectLineBoundaryForward, selectLineDown, selectLineEnd, selectLineStart, selectLineUp, selectMatchingBracket, selectPageDown, selectPageUp, selectParentSyntax, selectSubwordBackward, selectSubwordForward, selectSyntaxLeft, selectSyntaxRight, simplifySelection, splitLine, standardKeymap, transposeChars };","map":null,"metadata":{},"sourceType":"module"}