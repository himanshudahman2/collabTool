{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar fast_diff_1 = __importDefault(require(\"fast-diff\"));\n\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\n\nvar lodash_isequal_1 = __importDefault(require(\"lodash.isequal\"));\n\nvar AttributeMap_1 = __importDefault(require(\"./AttributeMap\"));\n\nvar Op_1 = __importDefault(require(\"./Op\"));\n\nvar NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\n\nvar Delta =\n/** @class */\nfunction () {\n  function Delta(ops) {\n    // Assume we are given a well formed ops\n    if (Array.isArray(ops)) {\n      this.ops = ops;\n    } else if (ops != null && Array.isArray(ops.ops)) {\n      this.ops = ops.ops;\n    } else {\n      this.ops = [];\n    }\n  }\n\n  Delta.prototype.insert = function (arg, attributes) {\n    var newOp = {};\n\n    if (typeof arg === 'string' && arg.length === 0) {\n      return this;\n    }\n\n    newOp.insert = arg;\n\n    if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n      newOp.attributes = attributes;\n    }\n\n    return this.push(newOp);\n  };\n\n  Delta.prototype.delete = function (length) {\n    if (length <= 0) {\n      return this;\n    }\n\n    return this.push({\n      delete: length\n    });\n  };\n\n  Delta.prototype.retain = function (length, attributes) {\n    if (length <= 0) {\n      return this;\n    }\n\n    var newOp = {\n      retain: length\n    };\n\n    if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n      newOp.attributes = attributes;\n    }\n\n    return this.push(newOp);\n  };\n\n  Delta.prototype.push = function (newOp) {\n    var index = this.ops.length;\n    var lastOp = this.ops[index - 1];\n    newOp = lodash_clonedeep_1.default(newOp);\n\n    if (typeof lastOp === 'object') {\n      if (typeof newOp.delete === 'number' && typeof lastOp.delete === 'number') {\n        this.ops[index - 1] = {\n          delete: lastOp.delete + newOp.delete\n        };\n        return this;\n      } // Since it does not matter if we insert before or after deleting at the same index,\n      // always prefer to insert first\n\n\n      if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n        index -= 1;\n        lastOp = this.ops[index - 1];\n\n        if (typeof lastOp !== 'object') {\n          this.ops.unshift(newOp);\n          return this;\n        }\n      }\n\n      if (lodash_isequal_1.default(newOp.attributes, lastOp.attributes)) {\n        if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {\n          this.ops[index - 1] = {\n            insert: lastOp.insert + newOp.insert\n          };\n\n          if (typeof newOp.attributes === 'object') {\n            this.ops[index - 1].attributes = newOp.attributes;\n          }\n\n          return this;\n        } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {\n          this.ops[index - 1] = {\n            retain: lastOp.retain + newOp.retain\n          };\n\n          if (typeof newOp.attributes === 'object') {\n            this.ops[index - 1].attributes = newOp.attributes;\n          }\n\n          return this;\n        }\n      }\n    }\n\n    if (index === this.ops.length) {\n      this.ops.push(newOp);\n    } else {\n      this.ops.splice(index, 0, newOp);\n    }\n\n    return this;\n  };\n\n  Delta.prototype.chop = function () {\n    var lastOp = this.ops[this.ops.length - 1];\n\n    if (lastOp && lastOp.retain && !lastOp.attributes) {\n      this.ops.pop();\n    }\n\n    return this;\n  };\n\n  Delta.prototype.filter = function (predicate) {\n    return this.ops.filter(predicate);\n  };\n\n  Delta.prototype.forEach = function (predicate) {\n    this.ops.forEach(predicate);\n  };\n\n  Delta.prototype.map = function (predicate) {\n    return this.ops.map(predicate);\n  };\n\n  Delta.prototype.partition = function (predicate) {\n    var passed = [];\n    var failed = [];\n    this.forEach(function (op) {\n      var target = predicate(op) ? passed : failed;\n      target.push(op);\n    });\n    return [passed, failed];\n  };\n\n  Delta.prototype.reduce = function (predicate, initialValue) {\n    return this.ops.reduce(predicate, initialValue);\n  };\n\n  Delta.prototype.changeLength = function () {\n    return this.reduce(function (length, elem) {\n      if (elem.insert) {\n        return length + Op_1.default.length(elem);\n      } else if (elem.delete) {\n        return length - elem.delete;\n      }\n\n      return length;\n    }, 0);\n  };\n\n  Delta.prototype.length = function () {\n    return this.reduce(function (length, elem) {\n      return length + Op_1.default.length(elem);\n    }, 0);\n  };\n\n  Delta.prototype.slice = function (start, end) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (end === void 0) {\n      end = Infinity;\n    }\n\n    var ops = [];\n    var iter = Op_1.default.iterator(this.ops);\n    var index = 0;\n\n    while (index < end && iter.hasNext()) {\n      var nextOp = void 0;\n\n      if (index < start) {\n        nextOp = iter.next(start - index);\n      } else {\n        nextOp = iter.next(end - index);\n        ops.push(nextOp);\n      }\n\n      index += Op_1.default.length(nextOp);\n    }\n\n    return new Delta(ops);\n  };\n\n  Delta.prototype.compose = function (other) {\n    var thisIter = Op_1.default.iterator(this.ops);\n    var otherIter = Op_1.default.iterator(other.ops);\n    var ops = [];\n    var firstOther = otherIter.peek();\n\n    if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {\n      var firstLeft = firstOther.retain;\n\n      while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {\n        firstLeft -= thisIter.peekLength();\n        ops.push(thisIter.next());\n      }\n\n      if (firstOther.retain - firstLeft > 0) {\n        otherIter.next(firstOther.retain - firstLeft);\n      }\n    }\n\n    var delta = new Delta(ops);\n\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n      if (otherIter.peekType() === 'insert') {\n        delta.push(otherIter.next());\n      } else if (thisIter.peekType() === 'delete') {\n        delta.push(thisIter.next());\n      } else {\n        var length_1 = Math.min(thisIter.peekLength(), otherIter.peekLength());\n        var thisOp = thisIter.next(length_1);\n        var otherOp = otherIter.next(length_1);\n\n        if (typeof otherOp.retain === 'number') {\n          var newOp = {};\n\n          if (typeof thisOp.retain === 'number') {\n            newOp.retain = length_1;\n          } else {\n            newOp.insert = thisOp.insert;\n          } // Preserve null when composing with a retain, otherwise remove it for inserts\n\n\n          var attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n\n          if (attributes) {\n            newOp.attributes = attributes;\n          }\n\n          delta.push(newOp); // Optimization if rest of other is just retain\n\n          if (!otherIter.hasNext() && lodash_isequal_1.default(delta.ops[delta.ops.length - 1], newOp)) {\n            var rest = new Delta(thisIter.rest());\n            return delta.concat(rest).chop();\n          } // Other op should be delete, we could be an insert or retain\n          // Insert + delete cancels out\n\n        } else if (typeof otherOp.delete === 'number' && typeof thisOp.retain === 'number') {\n          delta.push(otherOp);\n        }\n      }\n    }\n\n    return delta.chop();\n  };\n\n  Delta.prototype.concat = function (other) {\n    var delta = new Delta(this.ops.slice());\n\n    if (other.ops.length > 0) {\n      delta.push(other.ops[0]);\n      delta.ops = delta.ops.concat(other.ops.slice(1));\n    }\n\n    return delta;\n  };\n\n  Delta.prototype.diff = function (other, cursor) {\n    if (this.ops === other.ops) {\n      return new Delta();\n    }\n\n    var strings = [this, other].map(function (delta) {\n      return delta.map(function (op) {\n        if (op.insert != null) {\n          return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n        }\n\n        var prep = delta === other ? 'on' : 'with';\n        throw new Error('diff() called ' + prep + ' non-document');\n      }).join('');\n    });\n    var retDelta = new Delta();\n    var diffResult = fast_diff_1.default(strings[0], strings[1], cursor);\n    var thisIter = Op_1.default.iterator(this.ops);\n    var otherIter = Op_1.default.iterator(other.ops);\n    diffResult.forEach(function (component) {\n      var length = component[1].length;\n\n      while (length > 0) {\n        var opLength = 0;\n\n        switch (component[0]) {\n          case fast_diff_1.default.INSERT:\n            opLength = Math.min(otherIter.peekLength(), length);\n            retDelta.push(otherIter.next(opLength));\n            break;\n\n          case fast_diff_1.default.DELETE:\n            opLength = Math.min(length, thisIter.peekLength());\n            thisIter.next(opLength);\n            retDelta.delete(opLength);\n            break;\n\n          case fast_diff_1.default.EQUAL:\n            opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n            var thisOp = thisIter.next(opLength);\n            var otherOp = otherIter.next(opLength);\n\n            if (lodash_isequal_1.default(thisOp.insert, otherOp.insert)) {\n              retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));\n            } else {\n              retDelta.push(otherOp).delete(opLength);\n            }\n\n            break;\n        }\n\n        length -= opLength;\n      }\n    });\n    return retDelta.chop();\n  };\n\n  Delta.prototype.eachLine = function (predicate, newline) {\n    if (newline === void 0) {\n      newline = '\\n';\n    }\n\n    var iter = Op_1.default.iterator(this.ops);\n    var line = new Delta();\n    var i = 0;\n\n    while (iter.hasNext()) {\n      if (iter.peekType() !== 'insert') {\n        return;\n      }\n\n      var thisOp = iter.peek();\n      var start = Op_1.default.length(thisOp) - iter.peekLength();\n      var index = typeof thisOp.insert === 'string' ? thisOp.insert.indexOf(newline, start) - start : -1;\n\n      if (index < 0) {\n        line.push(iter.next());\n      } else if (index > 0) {\n        line.push(iter.next(index));\n      } else {\n        if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n          return;\n        }\n\n        i += 1;\n        line = new Delta();\n      }\n    }\n\n    if (line.length() > 0) {\n      predicate(line, {}, i);\n    }\n  };\n\n  Delta.prototype.invert = function (base) {\n    var inverted = new Delta();\n    this.reduce(function (baseIndex, op) {\n      if (op.insert) {\n        inverted.delete(Op_1.default.length(op));\n      } else if (op.retain && op.attributes == null) {\n        inverted.retain(op.retain);\n        return baseIndex + op.retain;\n      } else if (op.delete || op.retain && op.attributes) {\n        var length_2 = op.delete || op.retain;\n        var slice = base.slice(baseIndex, baseIndex + length_2);\n        slice.forEach(function (baseOp) {\n          if (op.delete) {\n            inverted.push(baseOp);\n          } else if (op.retain && op.attributes) {\n            inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n          }\n        });\n        return baseIndex + length_2;\n      }\n\n      return baseIndex;\n    }, 0);\n    return inverted.chop();\n  };\n\n  Delta.prototype.transform = function (arg, priority) {\n    if (priority === void 0) {\n      priority = false;\n    }\n\n    priority = !!priority;\n\n    if (typeof arg === 'number') {\n      return this.transformPosition(arg, priority);\n    }\n\n    var other = arg;\n    var thisIter = Op_1.default.iterator(this.ops);\n    var otherIter = Op_1.default.iterator(other.ops);\n    var delta = new Delta();\n\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n      if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {\n        delta.retain(Op_1.default.length(thisIter.next()));\n      } else if (otherIter.peekType() === 'insert') {\n        delta.push(otherIter.next());\n      } else {\n        var length_3 = Math.min(thisIter.peekLength(), otherIter.peekLength());\n        var thisOp = thisIter.next(length_3);\n        var otherOp = otherIter.next(length_3);\n\n        if (thisOp.delete) {\n          // Our delete either makes their delete redundant or removes their retain\n          continue;\n        } else if (otherOp.delete) {\n          delta.push(otherOp);\n        } else {\n          // We retain either their retain or insert\n          delta.retain(length_3, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));\n        }\n      }\n    }\n\n    return delta.chop();\n  };\n\n  Delta.prototype.transformPosition = function (index, priority) {\n    if (priority === void 0) {\n      priority = false;\n    }\n\n    priority = !!priority;\n    var thisIter = Op_1.default.iterator(this.ops);\n    var offset = 0;\n\n    while (thisIter.hasNext() && offset <= index) {\n      var length_4 = thisIter.peekLength();\n      var nextType = thisIter.peekType();\n      thisIter.next();\n\n      if (nextType === 'delete') {\n        index -= Math.min(length_4, index - offset);\n        continue;\n      } else if (nextType === 'insert' && (offset < index || !priority)) {\n        index += length_4;\n      }\n\n      offset += length_4;\n    }\n\n    return index;\n  };\n\n  Delta.Op = Op_1.default;\n  Delta.AttributeMap = AttributeMap_1.default;\n  return Delta;\n}();\n\nmodule.exports = Delta;","map":null,"metadata":{},"sourceType":"script"}