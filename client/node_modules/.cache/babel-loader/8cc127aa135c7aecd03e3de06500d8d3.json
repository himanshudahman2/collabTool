{"ast":null,"code":"// This contains the master OT functions for the database. They look like\n// ot-types style operational transform functions, but they're a bit different.\n// These functions understand versions and can deal with out of bound create &\n// delete operations.\nvar types = require('./types');\n\nvar ShareDBError = require('./error');\n\nvar util = require('./util');\n\nvar ERROR_CODE = ShareDBError.CODES; // Returns an error string on failure. Rockin' it C style.\n\nexports.checkOp = function (op) {\n  if (op == null || typeof op !== 'object') {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Op must be an object');\n  }\n\n  if (op.create != null) {\n    if (typeof op.create !== 'object') {\n      return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Create data must be an object');\n    }\n\n    var typeName = op.create.type;\n\n    if (typeof typeName !== 'string') {\n      return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Missing create type');\n    }\n\n    var type = types.map[typeName];\n\n    if (type == null || typeof type !== 'object') {\n      return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n    }\n  } else if (op.del != null) {\n    if (op.del !== true) return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'del value must be true');\n  } else if (!('op' in op)) {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Missing op, create, or del');\n  }\n\n  if (op.src != null && typeof op.src !== 'string') {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'src must be a string');\n  }\n\n  if (op.seq != null && typeof op.seq !== 'number') {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'seq must be a number');\n  }\n\n  if (op.src == null && op.seq != null || op.src != null && op.seq == null) {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'Both src and seq must be set together');\n  }\n\n  if (op.m != null && typeof op.m !== 'object') {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, 'op.m must be an object or null');\n  }\n}; // Takes in a string (type name or URI) and returns the normalized name (uri)\n\n\nexports.normalizeType = function (typeName) {\n  return types.map[typeName] && types.map[typeName].uri;\n}; // This is the super apply function that takes in snapshot data (including the\n// type) and edits it in-place. Returns an error or null for success.\n\n\nexports.apply = function (snapshot, op) {\n  if (typeof snapshot !== 'object') {\n    return new ShareDBError(ERROR_CODE.ERR_APPLY_SNAPSHOT_NOT_PROVIDED, 'Missing snapshot');\n  }\n\n  if (snapshot.v != null && op.v != null && snapshot.v !== op.v) {\n    return new ShareDBError(ERROR_CODE.ERR_APPLY_OP_VERSION_DOES_NOT_MATCH_SNAPSHOT, 'Version mismatch');\n  } // Create operation\n\n\n  if (op.create) {\n    if (snapshot.type) return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, 'Document already exists'); // The document doesn't exist, although it might have once existed\n\n    var create = op.create;\n    var type = types.map[create.type];\n    if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n\n    try {\n      snapshot.data = type.create(create.data);\n      snapshot.type = type.uri;\n      snapshot.v++;\n    } catch (err) {\n      return err;\n    } // Delete operation\n\n  } else if (op.del) {\n    snapshot.data = undefined;\n    snapshot.type = null;\n    snapshot.v++; // Edit operation\n  } else if ('op' in op) {\n    var err = applyOpEdit(snapshot, op.op);\n    if (err) return err;\n    snapshot.v++; // No-op, and we don't have to do anything\n  } else {\n    snapshot.v++;\n  }\n};\n\nfunction applyOpEdit(snapshot, edit) {\n  if (!snapshot.type) return new ShareDBError(ERROR_CODE.ERR_DOC_DOES_NOT_EXIST, 'Document does not exist');\n  if (edit === undefined) return new ShareDBError(ERROR_CODE.ERR_OT_OP_NOT_PROVIDED, 'Missing op');\n  var type = types.map[snapshot.type];\n  if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n\n  try {\n    snapshot.data = type.apply(snapshot.data, edit);\n  } catch (err) {\n    return new ShareDBError(ERROR_CODE.ERR_OT_OP_NOT_APPLIED, err.message);\n  }\n}\n\nexports.transform = function (type, op, appliedOp) {\n  // There are 16 cases this function needs to deal with - which are all the\n  // combinations of create/delete/op/noop from both op and appliedOp\n  if (op.v != null && op.v !== appliedOp.v) {\n    return new ShareDBError(ERROR_CODE.ERR_OP_VERSION_MISMATCH_DURING_TRANSFORM, 'Version mismatch');\n  }\n\n  if (appliedOp.del) {\n    if (op.create || 'op' in op) {\n      return new ShareDBError(ERROR_CODE.ERR_DOC_WAS_DELETED, 'Document was deleted');\n    }\n  } else if (appliedOp.create && ('op' in op || op.create || op.del) || 'op' in appliedOp && op.create) {\n    // If appliedOp.create is not true, appliedOp contains an op - which\n    // also means the document exists remotely.\n    return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, 'Document was created remotely');\n  } else if ('op' in appliedOp && 'op' in op) {\n    // If we reach here, they both have a .op property.\n    if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_DOES_NOT_EXIST, 'Document does not exist');\n\n    if (typeof type === 'string') {\n      type = types.map[type];\n      if (!type) return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, 'Unknown type');\n    }\n\n    try {\n      op.op = type.transform(op.op, appliedOp.op, 'left');\n    } catch (err) {\n      return err;\n    }\n  }\n\n  if (op.v != null) op.v++;\n};\n/**\n * Apply an array of ops to the provided snapshot.\n *\n * @param snapshot - a Snapshot object which will be mutated by the provided ops\n * @param ops - an array of ops to apply to the snapshot\n * @param options - options (currently for internal use only)\n * @return an error object if applicable\n */\n\n\nexports.applyOps = function (snapshot, ops, options) {\n  options = options || {};\n\n  for (var index = 0; index < ops.length; index++) {\n    var op = ops[index];\n\n    if (options._normalizeLegacyJson0Ops) {\n      try {\n        normalizeLegacyJson0Ops(snapshot, op);\n      } catch (error) {\n        return new ShareDBError(ERROR_CODE.ERR_OT_LEGACY_JSON0_OP_CANNOT_BE_NORMALIZED, 'Cannot normalize legacy json0 op');\n      }\n    }\n\n    snapshot.v = op.v;\n    var error = exports.apply(snapshot, op);\n    if (error) return error;\n  }\n};\n\nexports.transformPresence = function (presence, op, isOwnOp) {\n  var opError = this.checkOp(op);\n  if (opError) return opError;\n  var type = presence.t;\n\n  if (typeof type === 'string') {\n    type = types.map[type];\n  }\n\n  if (!type) return {\n    code: ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED,\n    message: 'Unknown type'\n  };\n\n  if (!util.supportsPresence(type)) {\n    return {\n      code: ERROR_CODE.ERR_TYPE_DOES_NOT_SUPPORT_PRESENCE,\n      message: 'Type does not support presence'\n    };\n  }\n\n  if (op.create || op.del) {\n    presence.p = null;\n    presence.v++;\n    return;\n  }\n\n  try {\n    presence.p = presence.p === null ? null : type.transformPresence(presence.p, op.op, isOwnOp);\n  } catch (error) {\n    return {\n      code: ERROR_CODE.ERR_PRESENCE_TRANSFORM_FAILED,\n      message: error.message || error\n    };\n  }\n\n  presence.v++;\n};\n/**\n * json0 had a breaking change in https://github.com/ottypes/json0/pull/40\n * The change added stricter type checking, which breaks fetchSnapshot()\n * when trying to rebuild a snapshot from old, committed ops that didn't\n * have this stricter validation. This method fixes up legacy ops to\n * pass the stricter validation\n */\n\n\nfunction normalizeLegacyJson0Ops(snapshot, json0Op) {\n  if (snapshot.type !== types.defaultType.uri) return;\n  var components = json0Op.op;\n  if (!components) return;\n\n  for (var i = 0; i < components.length; i++) {\n    var component = components[i];\n    if (typeof component.lm === 'string') component.lm = +component.lm;\n    var path = component.p;\n    var element = snapshot.data;\n\n    for (var j = 0; j < path.length; j++) {\n      var key = path[j]; // https://github.com/ottypes/json0/blob/73db17e86adc5d801951d1a69453b01382e66c7d/lib/json0.js#L21\n\n      if (Object.prototype.toString.call(element) == '[object Array]') path[j] = +key; // https://github.com/ottypes/json0/blob/73db17e86adc5d801951d1a69453b01382e66c7d/lib/json0.js#L32\n      else if (element.constructor === Object) path[j] = key.toString();\n      element = element[key];\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}