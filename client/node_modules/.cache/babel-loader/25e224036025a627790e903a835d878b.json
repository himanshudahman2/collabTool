{"ast":null,"code":"// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node (1024).\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\n\nclass Range {\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n\n} /// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\n\n\nclass NodeProp {\n  /// Create a new node prop type.\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.id = nextPropID++;\n    this.perNode = !!config.perNode;\n\n    this.deserialize = config.deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    });\n  } /// This is meant to be used with\n  /// [`NodeSet.extend`](#common.NodeSet.extend) or\n  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n  /// prop values for each node type in the set. Takes a [match\n  /// object](#common.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n\n\n  add(match) {\n    if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n    if (typeof match != \"function\") match = NodeType.match(match);\n    return type => {\n      let result = match(type);\n      return result === undefined ? null : [this, result];\n    };\n  }\n\n} /// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\n\n\nNodeProp.closedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n}); /// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\n\nNodeProp.openedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n}); /// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\n\nNodeProp.group = new NodeProp({\n  deserialize: str => str.split(\" \")\n}); /// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\n\nNodeProp.contextHash = new NodeProp({\n  perNode: true\n}); /// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\n\nNodeProp.lookAhead = new NodeProp({\n  perNode: true\n}); /// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages.\n\nNodeProp.mounted = new NodeProp({\n  perNode: true\n}); /// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\n\nclass MountedTree {\n  constructor( /// The inner tree.\n  tree, /// If this is null, this tree replaces the entire node (it will\n  /// be included in the regular iteration instead of its host\n  /// node). If not, only the given ranges are considered to be\n  /// covered by this tree. This is used for trees that are mixed in\n  /// a way that isn't strictly hierarchical. Such mounted trees are\n  /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n  /// and [`enter`](#common.SyntaxNode.enter).\n  overlay, /// The parser used to create this subtree.\n  parser) {\n    this.tree = tree;\n    this.overlay = overlay;\n    this.parser = parser;\n  }\n\n}\n\nconst noProps = Object.create(null); /// Each node in a syntax tree has a node type associated with it.\n\nclass NodeType {\n  /// @internal\n  constructor( /// The name of the node type. Not necessarily unique, but if the\n  /// grammar was written properly, different node types with the\n  /// same name within a node set should play the same semantic\n  /// role.\n  name, /// @internal\n  props, /// The id of this node in its set. Corresponds to the term ids\n  /// used in the parser.\n  id) {\n    let flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    this.name = name;\n    this.props = props;\n    this.id = id;\n    this.flags = flags;\n  }\n\n  static define(spec) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n    let flags = (spec.top ? 1\n    /* Top */\n    : 0) | (spec.skipped ? 2\n    /* Skipped */\n    : 0) | (spec.error ? 4\n    /* Error */\n    : 0) | (spec.name == null ? 8\n    /* Anonymous */\n    : 0);\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type);\n\n      if (src) {\n        if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n        props[src[0].id] = src[1];\n      }\n    }\n    return type;\n  } /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n\n\n  prop(prop) {\n    return this.props[prop.id];\n  } /// True when this is the top node of a grammar.\n\n\n  get isTop() {\n    return (this.flags & 1\n    /* Top */\n    ) > 0;\n  } /// True when this node is produced by a skip rule.\n\n\n  get isSkipped() {\n    return (this.flags & 2\n    /* Skipped */\n    ) > 0;\n  } /// Indicates whether this is an error node.\n\n\n  get isError() {\n    return (this.flags & 4\n    /* Error */\n    ) > 0;\n  } /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n\n\n  get isAnonymous() {\n    return (this.flags & 8\n    /* Anonymous */\n    ) > 0;\n  } /// Returns true when this node's name or one of its\n  /// [groups](#common.NodeProp^group) matches the given string.\n\n\n  is(name) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true;\n      let group = this.prop(NodeProp.group);\n      return group ? group.indexOf(name) > -1 : false;\n    }\n\n    return this.id == name;\n  } /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#common.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n\n\n  static match(map) {\n    let direct = Object.create(null);\n\n    for (let prop in map) for (let name of prop.split(\" \")) direct[name] = map[prop];\n\n    return node => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups[i]];\n        if (found) return found;\n      }\n    };\n  }\n\n} /// An empty dummy node type to use when no actual type is available.\n\n\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8\n/* Anonymous */\n); /// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\n\nclass NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor( /// The node types in this set, by id.\n  types) {\n    this.types = types;\n\n    for (let i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n  } /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#common.NodeProp.add).\n\n\n  extend() {\n    let newTypes = [];\n\n    for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n      props[_key] = arguments[_key];\n    }\n\n    for (let type of this.types) {\n      let newProps = null;\n\n      for (let source of props) {\n        let add = source(type);\n\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props);\n          newProps[add[0].id] = add[1];\n        }\n      }\n\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n    }\n\n    return new NodeSet(newTypes);\n  }\n\n}\n\nconst CachedNode = new WeakMap(),\n      CachedInnerNode = new WeakMap(); /// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\n\nclass Tree {\n  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n  constructor( /// The type of the top node.\n  type, /// This node's child nodes.\n  children, /// The positions (offsets relative to the start of this tree) of\n  /// the children.\n  positions, /// The total length of this tree\n  length, /// Per-node [node props](#common.NodeProp) to associate with this node.\n  props) {\n    this.type = type;\n    this.children = children;\n    this.positions = positions;\n    this.length = length; /// @internal\n\n    this.props = null;\n\n    if (props && props.length) {\n      this.props = Object.create(null);\n\n      for (let [prop, value] of props) this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n    }\n  } /// @internal\n\n\n  toString() {\n    let mounted = this.prop(NodeProp.mounted);\n    if (mounted && !mounted.overlay) return mounted.tree.toString();\n    let children = \"\";\n\n    for (let ch of this.children) {\n      let str = ch.toString();\n\n      if (str) {\n        if (children) children += \",\";\n        children += str;\n      }\n    }\n\n    return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n  } /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When\n  /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)\n  /// to the given position and side.\n\n\n  cursor(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let scope = pos != null && CachedNode.get(this) || this.topNode;\n    let cursor = new TreeCursor(scope);\n\n    if (pos != null) {\n      cursor.moveTo(pos, side);\n      CachedNode.set(this, cursor._tree);\n    }\n\n    return cursor;\n  } /// Get a [tree cursor](#common.TreeCursor) that, unlike regular\n  /// cursors, doesn't skip through\n  /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't\n  /// automatically enter mounted nodes.\n\n\n  fullCursor() {\n    return new TreeCursor(this.topNode, 1\n    /* Full */\n    );\n  } /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n  /// tree.\n\n\n  get topNode() {\n    return new TreeNode(this, 0, 0, null);\n  } /// Get the [syntax node](#common.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n\n\n  resolve(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n    CachedNode.set(this, node);\n    return node;\n  } /// Like [`resolve`](#common.Tree.resolve), but will enter\n  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n  /// pointing into the innermost overlaid tree at the given position\n  /// (with parent links going through all parent structure, including\n  /// the host trees).\n\n\n  resolveInner(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n    CachedInnerNode.set(this, node);\n    return node;\n  } /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, that node will\n  /// not have its children iterated over (or `leave` called).\n\n\n  iterate(spec) {\n    let {\n      enter,\n      leave,\n      from = 0,\n      to = this.length\n    } = spec;\n\n    for (let c = this.cursor(), get = () => c.node;;) {\n      let mustLeave = false;\n\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {\n        if (c.firstChild()) continue;\n        if (!c.type.isAnonymous) mustLeave = true;\n      }\n\n      for (;;) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to, get);\n        mustLeave = c.type.isAnonymous;\n        if (c.nextSibling()) break;\n        if (!c.parent()) return;\n        mustLeave = true;\n      }\n    }\n  } /// Get the value of the given [node prop](#common.NodeProp) for this\n  /// node. Works with both per-node and per-type props.\n\n\n  prop(prop) {\n    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n  } /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n  /// format that can be passed to the [`Tree`](#common.Tree)\n  /// constructor.\n\n\n  get propValues() {\n    let result = [];\n    if (this.props) for (let id in this.props) result.push([+id, this.props[id]]);\n    return result;\n  } /// Balance the direct children of this tree, producing a copy of\n  /// which may have children grouped into subtrees with type\n  /// [`NodeType.none`](#common.NodeType^none).\n\n\n  balance() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.children.length <= 8\n    /* BranchFactor */\n    ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n  } /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n\n\n  static build(data) {\n    return buildTree(data);\n  }\n\n} /// The empty tree\n\n\nTree.empty = new Tree(NodeType.none, [], [], 0);\n\nclass FlatBufferCursor {\n  constructor(buffer, index) {\n    this.buffer = buffer;\n    this.index = index;\n  }\n\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n\n  get pos() {\n    return this.index;\n  }\n\n  next() {\n    this.index -= 4;\n  }\n\n  fork() {\n    return new FlatBufferCursor(this.buffer, this.index);\n  }\n\n} /// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\n\n\nclass TreeBuffer {\n  /// Create a tree buffer.\n  constructor( /// The buffer's content.\n  buffer, /// The total length of the group of nodes in the buffer.\n  length, /// The node set used in this buffer.\n  set) {\n    this.buffer = buffer;\n    this.length = length;\n    this.set = set;\n  } /// @internal\n\n\n  get type() {\n    return NodeType.none;\n  } /// @internal\n\n\n  toString() {\n    let result = [];\n\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n\n    return result.join(\",\");\n  } /// @internal\n\n\n  childString(index) {\n    let id = this.buffer[index],\n        endIndex = this.buffer[index + 3];\n    let type = this.set.types[id],\n        result = type.name;\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n    index += 4;\n    if (endIndex == index) return result;\n    let children = [];\n\n    while (index < endIndex) {\n      children.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n\n    return result + \"(\" + children.join(\",\") + \")\";\n  } /// @internal\n\n\n  findChild(startIndex, endIndex, dir, pos, side) {\n    let {\n      buffer\n    } = this,\n        pick = -1;\n\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n        pick = i;\n        if (dir > 0) break;\n      }\n    }\n\n    return pick;\n  } /// @internal\n\n\n  slice(startI, endI, from, to) {\n    let b = this.buffer;\n    let copy = new Uint16Array(endI - startI);\n\n    for (let i = startI, j = 0; i < endI;) {\n      copy[j++] = b[i++];\n      copy[j++] = b[i++] - from;\n      copy[j++] = b[i++] - from;\n      copy[j++] = b[i++] - startI;\n    }\n\n    return new TreeBuffer(copy, to - from, this.set);\n  }\n\n}\n\nfunction checkSide(side, pos, from, to) {\n  switch (side) {\n    case -2\n    /* Before */\n    :\n      return from < pos;\n\n    case -1\n    /* AtOrBefore */\n    :\n      return to >= pos && from < pos;\n\n    case 0\n    /* Around */\n    :\n      return from < pos && to > pos;\n\n    case 1\n    /* AtOrAfter */\n    :\n      return from <= pos && to > pos;\n\n    case 2\n    /* After */\n    :\n      return to > pos;\n\n    case 4\n    /* DontCare */\n    :\n      return true;\n  }\n}\n\nfunction enterUnfinishedNodesBefore(node, pos) {\n  let scan = node.childBefore(pos);\n\n  while (scan) {\n    let last = scan.lastChild;\n    if (!last || last.to != scan.to) break;\n\n    if (last.type.isError && last.from == last.to) {\n      node = scan;\n      scan = last.prevSibling;\n    } else {\n      scan = last;\n    }\n  }\n\n  return node;\n}\n\nfunction resolveNode(node, pos, side, overlays) {\n  var _a; // Move up to a node that actually holds the position, if possible\n\n\n  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {\n    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n    if (!parent) return node;\n    node = parent;\n  } // Must go up out of overlays when those do not overlap with pos\n\n\n  if (overlays) for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n    if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n  }\n\n  for (;;) {\n    let inner = node.enter(pos, side, overlays);\n    if (!inner) return node;\n    node = inner;\n  }\n}\n\nclass TreeNode {\n  constructor(node, _from, // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n  index, _parent) {\n    this.node = node;\n    this._from = _from;\n    this.index = index;\n    this._parent = _parent;\n  }\n\n  get type() {\n    return this.node.type;\n  }\n\n  get name() {\n    return this.node.type.name;\n  }\n\n  get from() {\n    return this._from;\n  }\n\n  get to() {\n    return this._from + this.node.length;\n  }\n\n  nextChild(i, dir, pos, side) {\n    let mode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    for (let parent = this;;) {\n      for (let {\n        children,\n        positions\n      } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i],\n            start = positions[i] + parent._from;\n        if (!checkSide(side, pos, start, start + next.length)) continue;\n\n        if (next instanceof TreeBuffer) {\n          if (mode & 2\n          /* NoEnterBuffer */\n          ) continue;\n          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n        } else if (mode & 1\n        /* Full */\n        || !next.type.isAnonymous || hasChild(next)) {\n          let mounted;\n          if (!(mode & 1\n          /* Full */\n          ) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n          let inner = new TreeNode(next, start, i, parent);\n          return mode & 1\n          /* Full */\n          || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n        }\n      }\n\n      if (mode & 1\n      /* Full */\n      || !parent.type.isAnonymous) return null;\n      if (parent.index >= 0) i = parent.index + dir;else i = dir < 0 ? -1 : parent._parent.node.children.length;\n      parent = parent._parent;\n      if (!parent) return null;\n    }\n  }\n\n  get firstChild() {\n    return this.nextChild(0, 1, 0, 4\n    /* DontCare */\n    );\n  }\n\n  get lastChild() {\n    return this.nextChild(this.node.children.length - 1, -1, 0, 4\n    /* DontCare */\n    );\n  }\n\n  childAfter(pos) {\n    return this.nextChild(0, 1, pos, 2\n    /* After */\n    );\n  }\n\n  childBefore(pos) {\n    return this.nextChild(this.node.children.length - 1, -1, pos, -2\n    /* Before */\n    );\n  }\n\n  enter(pos, side) {\n    let overlays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let buffers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let mounted;\n\n    if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {\n      let rPos = pos - this.from;\n\n      for (let {\n        from,\n        to\n      } of mounted.overlay) {\n        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n      }\n    }\n\n    return this.nextChild(0, 1, pos, side, buffers ? 0 : 2\n    /* NoEnterBuffer */\n    );\n  }\n\n  nextSignificantParent() {\n    let val = this;\n\n    while (val.type.isAnonymous && val._parent) val = val._parent;\n\n    return val;\n  }\n\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null;\n  }\n\n  get nextSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4\n    /* DontCare */\n    ) : null;\n  }\n\n  get prevSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4\n    /* DontCare */\n    ) : null;\n  }\n\n  get cursor() {\n    return new TreeCursor(this);\n  }\n\n  get tree() {\n    return this.node;\n  }\n\n  toTree() {\n    return this.node;\n  }\n\n  resolve(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return resolveNode(this, pos, side, false);\n  }\n\n  resolveInner(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return resolveNode(this, pos, side, true);\n  }\n\n  enterUnfinishedNodesBefore(pos) {\n    return enterUnfinishedNodesBefore(this, pos);\n  }\n\n  getChild(type) {\n    let before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n\n  getChildren(type) {\n    let before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return getChildren(this, type, before, after);\n  } /// @internal\n\n\n  toString() {\n    return this.node.toString();\n  }\n\n}\n\nfunction getChildren(node, type, before, after) {\n  let cur = node.cursor,\n      result = [];\n  if (!cur.firstChild()) return result;\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result;\n\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result;\n    if (cur.type.is(type)) result.push(cur.node);\n    if (!cur.nextSibling()) return after == null ? result : [];\n  }\n}\n\nclass BufferContext {\n  constructor(parent, buffer, index, start) {\n    this.parent = parent;\n    this.buffer = buffer;\n    this.index = index;\n    this.start = start;\n  }\n\n}\n\nclass BufferNode {\n  constructor(context, _parent, index) {\n    this.context = context;\n    this._parent = _parent;\n    this.index = index;\n    this.type = context.buffer.set.types[context.buffer.buffer[index]];\n  }\n\n  get name() {\n    return this.type.name;\n  }\n\n  get from() {\n    return this.context.start + this.context.buffer.buffer[this.index + 1];\n  }\n\n  get to() {\n    return this.context.start + this.context.buffer.buffer[this.index + 2];\n  }\n\n  child(dir, pos, side) {\n    let {\n      buffer\n    } = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n\n  get firstChild() {\n    return this.child(1, 0, 4\n    /* DontCare */\n    );\n  }\n\n  get lastChild() {\n    return this.child(-1, 0, 4\n    /* DontCare */\n    );\n  }\n\n  childAfter(pos) {\n    return this.child(1, pos, 2\n    /* After */\n    );\n  }\n\n  childBefore(pos) {\n    return this.child(-1, pos, -2\n    /* Before */\n    );\n  }\n\n  enter(pos, side, overlays) {\n    let buffers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!buffers) return null;\n    let {\n      buffer\n    } = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent();\n  }\n\n  externalSibling(dir) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4\n    /* DontCare */\n    );\n  }\n\n  get nextSibling() {\n    let {\n      buffer\n    } = this.context;\n    let after = buffer.buffer[this.index + 3];\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n    return this.externalSibling(1);\n  }\n\n  get prevSibling() {\n    let {\n      buffer\n    } = this.context;\n    let parentStart = this._parent ? this._parent.index + 4 : 0;\n    if (this.index == parentStart) return this.externalSibling(-1);\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4\n    /* DontCare */\n    ));\n  }\n\n  get cursor() {\n    return new TreeCursor(this);\n  }\n\n  get tree() {\n    return null;\n  }\n\n  toTree() {\n    let children = [],\n        positions = [];\n    let {\n      buffer\n    } = this.context;\n    let startI = this.index + 4,\n        endI = buffer.buffer[this.index + 3];\n\n    if (endI > startI) {\n      let from = buffer.buffer[this.index + 1],\n          to = buffer.buffer[this.index + 2];\n      children.push(buffer.slice(startI, endI, from, to));\n      positions.push(0);\n    }\n\n    return new Tree(this.type, children, positions, this.to - this.from);\n  }\n\n  resolve(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return resolveNode(this, pos, side, false);\n  }\n\n  resolveInner(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return resolveNode(this, pos, side, true);\n  }\n\n  enterUnfinishedNodesBefore(pos) {\n    return enterUnfinishedNodesBefore(this, pos);\n  } /// @internal\n\n\n  toString() {\n    return this.context.buffer.childString(this.index);\n  }\n\n  getChild(type) {\n    let before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n\n  getChildren(type) {\n    let before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return getChildren(this, type, before, after);\n  }\n\n} /// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\n\n\nclass TreeCursor {\n  /// @internal\n  constructor(node) {\n    let mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.mode = mode;\n    this.buffer = null;\n    this.stack = [];\n    this.index = 0;\n    this.bufferNode = null;\n\n    if (node instanceof TreeNode) {\n      this.yieldNode(node);\n    } else {\n      this._tree = node.context.parent;\n      this.buffer = node.context;\n\n      for (let n = node._parent; n; n = n._parent) this.stack.unshift(n.index);\n\n      this.bufferNode = node;\n      this.yieldBuf(node.index);\n    }\n  } /// Shorthand for `.type.name`.\n\n\n  get name() {\n    return this.type.name;\n  }\n\n  yieldNode(node) {\n    if (!node) return false;\n    this._tree = node;\n    this.type = node.type;\n    this.from = node.from;\n    this.to = node.to;\n    return true;\n  }\n\n  yieldBuf(index, type) {\n    this.index = index;\n    let {\n      start,\n      buffer\n    } = this.buffer;\n    this.type = type || buffer.set.types[buffer.buffer[index]];\n    this.from = start + buffer.buffer[index + 1];\n    this.to = start + buffer.buffer[index + 2];\n    return true;\n  }\n\n  yield(node) {\n    if (!node) return false;\n\n    if (node instanceof TreeNode) {\n      this.buffer = null;\n      return this.yieldNode(node);\n    }\n\n    this.buffer = node.context;\n    return this.yieldBuf(node.index, node.type);\n  } /// @internal\n\n\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n  } /// @internal\n\n\n  enterChild(dir, pos, side) {\n    if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));\n    let {\n      buffer\n    } = this.buffer;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n    if (index < 0) return false;\n    this.stack.push(this.index);\n    return this.yieldBuf(index);\n  } /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n\n\n  firstChild() {\n    return this.enterChild(1, 0, 4\n    /* DontCare */\n    );\n  } /// Move the cursor to this node's last child.\n\n\n  lastChild() {\n    return this.enterChild(-1, 0, 4\n    /* DontCare */\n    );\n  } /// Move the cursor to the first child that ends after `pos`.\n\n\n  childAfter(pos) {\n    return this.enterChild(1, pos, 2\n    /* After */\n    );\n  } /// Move to the last child that starts before `pos`.\n\n\n  childBefore(pos) {\n    return this.enterChild(-1, pos, -2\n    /* Before */\n    );\n  } /// Move the cursor to the child around `pos`. If side is -1 the\n  /// child may end at that position, when 1 it may start there. This\n  /// will also enter [overlaid](#common.MountedTree.overlay)\n  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n  /// set to false.\n\n\n  enter(pos, side) {\n    let overlays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let buffers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!this.buffer) return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1\n    /* Full */\n    ), buffers));\n    return buffers ? this.enterChild(1, pos, side) : false;\n  } /// Move to the node's parent node, if this isn't the top node.\n\n\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.mode & 1\n    /* Full */\n    ? this._tree._parent : this._tree.parent);\n    if (this.stack.length) return this.yieldBuf(this.stack.pop());\n    let parent = this.mode & 1\n    /* Full */\n    ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n    this.buffer = null;\n    return this.yieldNode(parent);\n  } /// @internal\n\n\n  sibling(dir) {\n    if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4\n    /* DontCare */\n    , this.mode));\n    let {\n      buffer\n    } = this.buffer,\n        d = this.stack.length - 1;\n\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n      if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4\n      /* DontCare */\n      ));\n    } else {\n      let after = buffer.buffer[this.index + 3];\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n    }\n\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4\n    /* DontCare */\n    , this.mode)) : false;\n  } /// Move to this node's next sibling, if any.\n\n\n  nextSibling() {\n    return this.sibling(1);\n  } /// Move to this node's previous sibling, if any.\n\n\n  prevSibling() {\n    return this.sibling(-1);\n  }\n\n  atLastNode(dir) {\n    let index,\n        parent,\n        {\n      buffer\n    } = this;\n\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false;\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;\n      }\n\n      ({\n        index,\n        parent\n      } = buffer);\n    } else {\n      ({\n        index,\n        _parent: parent\n      } = this._tree);\n    }\n\n    for (; parent; ({\n      index,\n      _parent: parent\n    } = parent)) {\n      if (index > -1) for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i];\n        if (this.mode & 1\n        /* Full */\n        || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n      }\n    }\n\n    return true;\n  }\n\n  move(dir, enter) {\n    if (enter && this.enterChild(dir, 0, 4\n    /* DontCare */\n    )) return true;\n\n    for (;;) {\n      if (this.sibling(dir)) return true;\n      if (this.atLastNode(dir) || !this.parent()) return false;\n    }\n  } /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty or `enter` is false, its next sibling or\n  /// the next sibling of the first parent node that has one.\n\n\n  next() {\n    let enter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.move(1, enter);\n  } /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by its last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n\n\n  prev() {\n    let enter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.move(-1, enter);\n  } /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n\n\n  moveTo(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break; // Then scan down into child nodes as far as possible\n\n\n    while (this.enterChild(1, pos, side)) {}\n\n    return this;\n  } /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n  /// position.\n\n\n  get node() {\n    if (!this.buffer) return this._tree;\n    let cache = this.bufferNode,\n        result = null,\n        depth = 0;\n\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c;\n          result = c;\n          depth = d + 1;\n          break scan;\n        }\n\n        index = this.stack[--d];\n      }\n    }\n\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);\n\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n  } /// Get the [tree](#common.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#common.TreeBuffer).\n\n\n  get tree() {\n    return this.buffer ? null : this._tree.node;\n  }\n\n}\n\nfunction hasChild(tree) {\n  return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\n\nfunction buildTree(data) {\n  var _a;\n\n  let {\n    buffer,\n    nodeSet,\n    maxBufferLength = DefaultBufferLength,\n    reused = [],\n    minRepeatType = nodeSet.types.length\n  } = data;\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n  let types = nodeSet.types;\n  let contextHash = 0,\n      lookAhead = 0;\n\n  function takeNode(parentStart, minPos, children, positions, inRepeat) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    let lookAheadAtStart = lookAhead;\n\n    while (size < 0) {\n      cursor.next();\n\n      if (size == -1\n      /* Reuse */\n      ) {\n        let node = reused[id];\n        children.push(node);\n        positions.push(start - parentStart);\n        return;\n      } else if (size == -3\n      /* ContextChange */\n      ) {\n        // Context change\n        contextHash = id;\n        return;\n      } else if (size == -4\n      /* LookAhead */\n      ) {\n        lookAhead = id;\n        return;\n      } else {\n        throw new RangeError(`Unrecognized record size: ${size}`);\n      }\n    }\n\n    let type = types[id],\n        node,\n        buffer;\n    let startPos = start - parentStart;\n\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip);\n      let endPos = cursor.pos - buffer.size,\n          index = data.length;\n\n      while (cursor.pos > endPos) index = copyToBuffer(buffer.start, data, index);\n\n      node = new TreeBuffer(data, end - buffer.start, nodeSet);\n      startPos = buffer.start - parentStart;\n    } else {\n      // Make it a node\n      let endPos = cursor.pos - size;\n      cursor.next();\n      let localChildren = [],\n          localPositions = [];\n      let localInRepeat = id >= minRepeatType ? id : -1;\n      let lastGroup = 0,\n          lastEnd = end;\n\n      while (cursor.pos > endPos) {\n        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n          if (cursor.end <= lastEnd - maxBufferLength) {\n            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n            lastGroup = localChildren.length;\n            lastEnd = cursor.end;\n          }\n\n          cursor.next();\n        } else {\n          takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n        }\n      }\n\n      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n      localChildren.reverse();\n      localPositions.reverse();\n\n      if (localInRepeat > -1 && lastGroup > 0) {\n        let make = makeBalanced(type);\n        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n      } else {\n        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n      }\n    }\n\n    children.push(node);\n    positions.push(startPos);\n  }\n\n  function makeBalanced(type) {\n    return (children, positions, length) => {\n      let lookAhead = 0,\n          lastI = children.length - 1,\n          last,\n          lookAheadProp;\n\n      if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n        if (!lastI && last.type == type && last.length == length) return last;\n        if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n      }\n\n      return makeTree(type, children, positions, length, lookAhead);\n    };\n  }\n\n  function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n    let localChildren = [],\n        localPositions = [];\n\n    while (children.length > i) {\n      localChildren.push(children.pop());\n      localPositions.push(positions.pop() + base - from);\n    }\n\n    children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n    positions.push(from - base);\n  }\n\n  function makeTree(type, children, positions, length) {\n    let lookAhead = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let props = arguments.length > 5 ? arguments[5] : undefined;\n\n    if (contextHash) {\n      let pair = [NodeProp.contextHash, contextHash];\n      props = props ? [pair].concat(props) : [pair];\n    }\n\n    if (lookAhead > 25) {\n      let pair = [NodeProp.lookAhead, lookAhead];\n      props = props ? [pair].concat(props) : [pair];\n    }\n\n    return new Tree(type, children, positions, length, props);\n  }\n\n  function findBufferSize(maxSize, inRepeat) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork();\n    let size = 0,\n        start = 0,\n        skip = 0,\n        minStart = fork.end - maxBufferLength;\n    let result = {\n      size: 0,\n      start: 0,\n      skip: 0\n    };\n\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      let nodeSize = fork.size; // Pretend nested repeat nodes of the same type don't exist\n\n      if (fork.id == inRepeat && nodeSize >= 0) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size;\n        result.start = start;\n        result.skip = skip;\n        skip += 4;\n        size += 4;\n        fork.next();\n        continue;\n      }\n\n      let startPos = fork.pos - nodeSize;\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n      let nodeStart = fork.start;\n      fork.next();\n\n      while (fork.pos > startPos) {\n        if (fork.size < 0) {\n          if (fork.size == -3\n          /* ContextChange */\n          ) localSkipped += 4;else break scan;\n        } else if (fork.id >= minRepeatType) {\n          localSkipped += 4;\n        }\n\n        fork.next();\n      }\n\n      start = nodeStart;\n      size += nodeSize;\n      skip += localSkipped;\n    }\n\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size;\n      result.start = start;\n      result.skip = skip;\n    }\n\n    return result.size > 4 ? result : undefined;\n  }\n\n  function copyToBuffer(bufferStart, buffer, index) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    cursor.next();\n\n    if (size >= 0 && id < minRepeatType) {\n      let startIndex = index;\n\n      if (size > 4) {\n        let endPos = cursor.pos - (size - 4);\n\n        while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index);\n      }\n\n      buffer[--index] = startIndex;\n      buffer[--index] = end - bufferStart;\n      buffer[--index] = start - bufferStart;\n      buffer[--index] = id;\n    } else if (size == -3\n    /* ContextChange */\n    ) {\n      contextHash = id;\n    } else if (size == -4\n    /* LookAhead */\n    ) {\n      lookAhead = id;\n    }\n\n    return index;\n  }\n\n  let children = [],\n      positions = [];\n\n  while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n\n  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\n\nconst nodeSizeCache = new WeakMap();\n\nfunction nodeSize(balanceType, node) {\n  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n  let size = nodeSizeCache.get(node);\n\n  if (size == null) {\n    size = 1;\n\n    for (let child of node.children) {\n      if (child.type != balanceType || !(child instanceof Tree)) {\n        size = 1;\n        break;\n      }\n\n      size += nodeSize(balanceType, child);\n    }\n\n    nodeSizeCache.set(node, size);\n  }\n\n  return size;\n}\n\nfunction balanceRange( // The type the balanced tree's inner nodes.\nbalanceType, // The direct children and their positions\nchildren, positions, // The index range in children/positions to use\nfrom, to, // The start position of the nodes, relative to their parent.\nstart, // Length of the outer node\nlength, // Function to build the top node of the balanced tree\nmkTop, // Function to build internal nodes for the balanced tree\nmkTree) {\n  let total = 0;\n\n  for (let i = from; i < to; i++) total += nodeSize(balanceType, children[i]);\n\n  let maxChild = Math.ceil(total * 1.5 / 8\n  /* BranchFactor */\n  );\n  let localChildren = [],\n      localPositions = [];\n\n  function divide(children, positions, from, to, offset) {\n    for (let i = from; i < to;) {\n      let groupFrom = i,\n          groupStart = positions[i],\n          groupSize = nodeSize(balanceType, children[i]);\n      i++;\n\n      for (; i < to; i++) {\n        let nextSize = nodeSize(balanceType, children[i]);\n        if (groupSize + nextSize >= maxChild) break;\n        groupSize += nextSize;\n      }\n\n      if (i == groupFrom + 1) {\n        if (groupSize > maxChild) {\n          let only = children[groupFrom]; // Only trees can have a size > 1\n\n          divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n          continue;\n        }\n\n        localChildren.push(children[groupFrom]);\n      } else {\n        let length = positions[i - 1] + children[i - 1].length - groupStart;\n        localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n      }\n\n      localPositions.push(groupStart + offset - start);\n    }\n  }\n\n  divide(children, positions, from, to, 0);\n  return (mkTop || mkTree)(localChildren, localPositions, length);\n} /// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\n\n\nclass TreeFragment {\n  /// Construct a tree fragment.\n  constructor( /// The start of the unchanged range pointed to by this fragment.\n  /// This refers to an offset in the _updated_ document (as opposed\n  /// to the original tree).\n  from, /// The end of the unchanged range.\n  to, /// The tree that this fragment is based on.\n  tree, /// The offset between the fragment's tree and the document that\n  /// this fragment can be used against. Add this when going from\n  /// document to tree positions, subtract it to go from tree to\n  /// document positions.\n  offset) {\n    let openStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let openEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    this.from = from;\n    this.to = to;\n    this.tree = tree;\n    this.offset = offset;\n    this.open = (openStart ? 1\n    /* Start */\n    : 0) | (openEnd ? 2\n    /* End */\n    : 0);\n  } /// Whether the start of the fragment represents the start of a\n  /// parse, or the end of a change. (In the second case, it may not\n  /// be safe to reuse some nodes at the start, depending on the\n  /// parsing algorithm.)\n\n\n  get openStart() {\n    return (this.open & 1\n    /* Start */\n    ) > 0;\n  } /// Whether the end of the fragment represents the end of a\n  /// full-document parse, or the start of a change.\n\n\n  get openEnd() {\n    return (this.open & 2\n    /* End */\n    ) > 0;\n  } /// Create a set of fragments from a freshly parsed tree, or update\n  /// an existing set of fragments by replacing the ones that overlap\n  /// with a tree with content from the new tree. When `partial` is\n  /// true, the parse is treated as incomplete, and the resulting\n  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n  /// true.\n\n\n  static addTree(tree) {\n    let fragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let partial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n\n    for (let f of fragments) if (f.to > tree.length) result.push(f);\n\n    return result;\n  } /// Apply a set of edits to an array of fragments, removing or\n  /// splitting fragments as necessary to remove edited ranges, and\n  /// adjusting offsets for fragments that moved.\n\n\n  static applyChanges(fragments, changes) {\n    let minGap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 128;\n    if (!changes.length) return fragments;\n    let result = [];\n    let fI = 1,\n        nextF = fragments.length ? fragments[0] : null;\n\n    for (let cI = 0, pos = 0, off = 0;; cI++) {\n      let nextC = cI < changes.length ? changes[cI] : null;\n      let nextPos = nextC ? nextC.fromA : 1e9;\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut = nextF;\n\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off,\n              fTo = Math.min(cut.to, nextPos) - off;\n          cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n        }\n\n        if (cut) result.push(cut);\n        if (nextF.to > nextPos) break;\n        nextF = fI < fragments.length ? fragments[fI++] : null;\n      }\n      if (!nextC) break;\n      pos = nextC.toA;\n      off = nextC.toA - nextC.toB;\n    }\n\n    return result;\n  }\n\n} /// A superclass that parsers should extend.\n\n\nclass Parser {\n  /// Start a parse, returning a [partial parse](#common.PartialParse)\n  /// object. [`fragments`](#common.TreeFragment) can be passed in to\n  /// make the parse incremental.\n  ///\n  /// By default, the entire input is parsed. You can pass `ranges`,\n  /// which should be a sorted array of non-empty, non-overlapping\n  /// ranges, to parse only those ranges. The tree returned in that\n  /// case will start at `ranges[0].from`.\n  startParse(input, fragments, ranges) {\n    if (typeof input == \"string\") input = new StringInput(input);\n    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n    return this.createParse(input, fragments || [], ranges);\n  } /// Run a full parse, returning the resulting tree.\n\n\n  parse(input, fragments, ranges) {\n    let parse = this.startParse(input, fragments, ranges);\n\n    for (;;) {\n      let done = parse.advance();\n      if (done) return done;\n    }\n  }\n\n}\n\nclass StringInput {\n  constructor(string) {\n    this.string = string;\n  }\n\n  get length() {\n    return this.string.length;\n  }\n\n  chunk(from) {\n    return this.string.slice(from);\n  }\n\n  get lineChunks() {\n    return false;\n  }\n\n  read(from, to) {\n    return this.string.slice(from, to);\n  }\n\n} /// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\n///\n/// The nesting function is passed a cursor to provide context for a\n/// node, but _should not_ move that cursor, only inspect its\n/// properties and optionally access its\n/// [node object](#common.TreeCursor.node).\n\n\nfunction parseMixed(nest) {\n  return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\n\nclass InnerParse {\n  constructor(parser, parse, overlay, target, ranges) {\n    this.parser = parser;\n    this.parse = parse;\n    this.overlay = overlay;\n    this.target = target;\n    this.ranges = ranges;\n  }\n\n}\n\nclass ActiveOverlay {\n  constructor(parser, predicate, mounts, index, start, target, prev) {\n    this.parser = parser;\n    this.predicate = predicate;\n    this.mounts = mounts;\n    this.index = index;\n    this.start = start;\n    this.target = target;\n    this.prev = prev;\n    this.depth = 0;\n    this.ranges = [];\n  }\n\n}\n\nconst stoppedInner = new NodeProp({\n  perNode: true\n});\n\nclass MixedParse {\n  constructor(base, nest, input, fragments, ranges) {\n    this.nest = nest;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.inner = [];\n    this.innerDone = 0;\n    this.baseTree = null;\n    this.stoppedAt = null;\n    this.baseParse = base;\n  }\n\n  advance() {\n    if (this.baseParse) {\n      let done = this.baseParse.advance();\n      if (!done) return null;\n      this.baseParse = null;\n      this.baseTree = done;\n      this.startInner();\n      if (this.stoppedAt != null) for (let inner of this.inner) inner.parse.stopAt(this.stoppedAt);\n    }\n\n    if (this.innerDone == this.inner.length) {\n      let result = this.baseTree;\n      if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n      return result;\n    }\n\n    let inner = this.inner[this.innerDone],\n        done = inner.parse.advance();\n\n    if (done) {\n      this.innerDone++; // This is a somewhat dodgy but super helpful hack where we\n      // patch up nodes created by the inner parse (and thus\n      // presumably not aliased anywhere else) to hold the information\n      // about the inner parse.\n\n      let props = Object.assign(Object.create(null), inner.target.props);\n      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n      inner.target.props = props;\n    }\n\n    return null;\n  }\n\n  get parsedPos() {\n    if (this.baseParse) return 0;\n    let pos = this.input.length;\n\n    for (let i = this.innerDone; i < this.inner.length; i++) {\n      if (this.inner[i].ranges[0].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n    }\n\n    return pos;\n  }\n\n  stopAt(pos) {\n    this.stoppedAt = pos;\n    if (this.baseParse) this.baseParse.stopAt(pos);else for (let i = this.innerDone; i < this.inner.length; i++) this.inner[i].parse.stopAt(pos);\n  }\n\n  startInner() {\n    let fragmentCursor = new FragmentCursor(this.fragments);\n    let overlay = null;\n    let covered = null;\n    let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1\n    /* Full */\n    );\n\n    scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n      let enter = true,\n          range;\n\n      if (fragmentCursor.hasNode(cursor)) {\n        if (overlay) {\n          let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n          if (match) for (let r of match.mount.overlay) {\n            let from = r.from + match.pos,\n                to = r.to + match.pos;\n            if (from >= cursor.from && to <= cursor.to) overlay.ranges.push({\n              from,\n              to\n            });\n          }\n        }\n\n        enter = false;\n      } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n        enter = isCovered != 2\n        /* Full */\n        ;\n      } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n        if (!cursor.tree) materialize(cursor);\n        let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n\n        if (typeof nest.overlay == \"function\") {\n          overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n        } else {\n          let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n          if (ranges.length) this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n          if (!nest.overlay) enter = false;else if (ranges.length) covered = {\n            ranges,\n            depth: 0,\n            prev: covered\n          };\n        }\n      } else if (overlay && (range = overlay.predicate(cursor))) {\n        if (range === true) range = new Range(cursor.from, cursor.to);\n        if (range.from < range.to) overlay.ranges.push(range);\n      }\n\n      if (enter && cursor.firstChild()) {\n        if (overlay) overlay.depth++;\n        if (covered) covered.depth++;\n      } else {\n        for (;;) {\n          if (cursor.nextSibling()) break;\n          if (!cursor.parent()) break scan;\n\n          if (overlay && ! --overlay.depth) {\n            let ranges = punchRanges(this.ranges, overlay.ranges);\n            if (ranges.length) this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n            overlay = overlay.prev;\n          }\n\n          if (covered && ! --covered.depth) covered = covered.prev;\n        }\n      }\n    }\n  }\n\n}\n\nfunction checkCover(covered, from, to) {\n  for (let range of covered) {\n    if (range.from >= to) break;\n    if (range.to > from) return range.from <= from && range.to >= to ? 2\n    /* Full */\n    : 1\n    /* Partial */\n    ;\n  }\n\n  return 0\n  /* None */\n  ;\n} // Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\n\n\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n  if (startI < endI) {\n    let from = buf.buffer[startI + 1],\n        to = buf.buffer[endI - 2];\n    nodes.push(buf.slice(startI, endI, from, to));\n    positions.push(from - off);\n  }\n} // This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\n\n\nfunction materialize(cursor) {\n  let {\n    node\n  } = cursor,\n      depth = 0; // Scan up to the nearest tree\n\n  do {\n    cursor.parent();\n    depth++;\n  } while (!cursor.tree); // Find the index of the buffer in that tree\n\n\n  let i = 0,\n      base = cursor.tree,\n      off = 0;\n\n  for (;; i++) {\n    off = base.positions[i] + cursor.from;\n    if (off <= node.from && off + base.children[i].length >= node.to) break;\n  }\n\n  let buf = base.children[i],\n      b = buf.buffer; // Split a level in the buffer, putting the nodes before and after\n  // the child that contains `node` into new buffers.\n\n  function split(startI, endI, type, innerOffset, length) {\n    let i = startI;\n\n    while (b[i + 2] + off <= node.from) i = b[i + 3];\n\n    let children = [],\n        positions = [];\n    sliceBuf(buf, startI, i, children, positions, innerOffset);\n    let from = b[i + 1],\n        to = b[i + 2];\n    let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n    children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n    positions.push(from - innerOffset);\n    sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n    return new Tree(type, children, positions, length);\n  }\n\n  base.children[i] = split(0, b.length, NodeType.none, 0, buf.length); // Move the cursor back to the target node\n\n  for (let d = 0; d <= depth; d++) cursor.childAfter(node.from);\n}\n\nclass StructureCursor {\n  constructor(root, offset) {\n    this.offset = offset;\n    this.done = false;\n    this.cursor = root.fullCursor();\n  } // Move to the first node (in pre-order) that starts at or after `pos`.\n\n\n  moveTo(pos) {\n    let {\n      cursor\n    } = this,\n        p = pos - this.offset;\n\n    while (!this.done && cursor.from < p) {\n      if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;else if (!cursor.next(false)) this.done = true;\n    }\n  }\n\n  hasNode(cursor) {\n    this.moveTo(cursor.from);\n\n    if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n      for (let tree = this.cursor.tree;;) {\n        if (tree == cursor.tree) return true;\n        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];else break;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass FragmentCursor {\n  constructor(fragments) {\n    var _a;\n\n    this.fragments = fragments;\n    this.curTo = 0;\n    this.fragI = 0;\n\n    if (fragments.length) {\n      let first = this.curFrag = fragments[0];\n      this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n      this.inner = new StructureCursor(first.tree, -first.offset);\n    } else {\n      this.curFrag = this.inner = null;\n    }\n  }\n\n  hasNode(node) {\n    while (this.curFrag && node.from >= this.curTo) this.nextFrag();\n\n    return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n  }\n\n  nextFrag() {\n    var _a;\n\n    this.fragI++;\n\n    if (this.fragI == this.fragments.length) {\n      this.curFrag = this.inner = null;\n    } else {\n      let frag = this.curFrag = this.fragments[this.fragI];\n      this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n      this.inner = new StructureCursor(frag.tree, -frag.offset);\n    }\n  }\n\n  findMounts(pos, parser) {\n    var _a;\n\n    let result = [];\n\n    if (this.inner) {\n      this.inner.cursor.moveTo(pos, 1);\n\n      for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n        let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n\n        if (mount && mount.parser == parser) {\n          for (let i = this.fragI; i < this.fragments.length; i++) {\n            let frag = this.fragments[i];\n            if (frag.from >= pos.to) break;\n            if (frag.tree == this.curFrag.tree) result.push({\n              frag,\n              pos: pos.from - frag.offset,\n              mount\n            });\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n}\n\nfunction punchRanges(outer, ranges) {\n  let copy = null,\n      current = ranges;\n\n  for (let i = 1, j = 0; i < outer.length; i++) {\n    let gapFrom = outer[i - 1].to,\n        gapTo = outer[i].from;\n\n    for (; j < current.length; j++) {\n      let r = current[j];\n      if (r.from >= gapTo) break;\n      if (r.to <= gapFrom) continue;\n      if (!copy) current = copy = ranges.slice();\n\n      if (r.from < gapFrom) {\n        copy[j] = new Range(r.from, gapFrom);\n        if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n      } else if (r.to > gapTo) {\n        copy[j--] = new Range(gapTo, r.to);\n      } else {\n        copy.splice(j--, 1);\n      }\n    }\n  }\n\n  return current;\n}\n\nfunction findCoverChanges(a, b, from, to) {\n  let iA = 0,\n      iB = 0,\n      inA = false,\n      inB = false,\n      pos = -1e9;\n  let result = [];\n\n  for (;;) {\n    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n\n    if (inA != inB) {\n      let start = Math.max(pos, from),\n          end = Math.min(nextA, nextB, to);\n      if (start < end) result.push(new Range(start, end));\n    }\n\n    pos = Math.min(nextA, nextB);\n    if (pos == 1e9) break;\n\n    if (nextA == pos) {\n      if (!inA) inA = true;else {\n        inA = false;\n        iA++;\n      }\n    }\n\n    if (nextB == pos) {\n      if (!inB) inB = true;else {\n        inB = false;\n        iB++;\n      }\n    }\n  }\n\n  return result;\n} // Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\n\n\nfunction enterFragments(mounts, ranges) {\n  let result = [];\n\n  for (let {\n    pos,\n    mount,\n    frag\n  } of mounts) {\n    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),\n        endPos = startPos + mount.tree.length;\n    let from = Math.max(frag.from, startPos),\n        to = Math.min(frag.to, endPos);\n\n    if (mount.overlay) {\n      let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n      let changes = findCoverChanges(ranges, overlay, from, to);\n\n      for (let i = 0, pos = from;; i++) {\n        let last = i == changes.length,\n            end = last ? to : changes[i].from;\n        if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));\n        if (last) break;\n        pos = changes[i].to;\n      }\n    } else {\n      result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));\n    }\n  }\n\n  return result;\n}\n\nexport { DefaultBufferLength, MountedTree, NodeProp, NodeSet, NodeType, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };","map":null,"metadata":{},"sourceType":"module"}